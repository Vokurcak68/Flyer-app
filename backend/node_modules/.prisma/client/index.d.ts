
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserBrand
 * 
 */
export type UserBrand = $Result.DefaultSelection<Prisma.$UserBrandPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Icon
 * 
 */
export type Icon = $Result.DefaultSelection<Prisma.$IconPayload>
/**
 * Model ProductIcon
 * 
 */
export type ProductIcon = $Result.DefaultSelection<Prisma.$ProductIconPayload>
/**
 * Model PromoImage
 * 
 */
export type PromoImage = $Result.DefaultSelection<Prisma.$PromoImagePayload>
/**
 * Model Flyer
 * 
 */
export type Flyer = $Result.DefaultSelection<Prisma.$FlyerPayload>
/**
 * Model FlyerPage
 * 
 */
export type FlyerPage = $Result.DefaultSelection<Prisma.$FlyerPagePayload>
/**
 * Model FlyerPageSlot
 * 
 */
export type FlyerPageSlot = $Result.DefaultSelection<Prisma.$FlyerPageSlotPayload>
/**
 * Model VerificationLog
 * 
 */
export type VerificationLog = $Result.DefaultSelection<Prisma.$VerificationLogPayload>
/**
 * Model Approval
 * 
 */
export type Approval = $Result.DefaultSelection<Prisma.$ApprovalPayload>
/**
 * Model ApprovalWorkflow
 * 
 */
export type ApprovalWorkflow = $Result.DefaultSelection<Prisma.$ApprovalWorkflowPayload>
/**
 * Model FlyerVersion
 * 
 */
export type FlyerVersion = $Result.DefaultSelection<Prisma.$FlyerVersionPayload>
/**
 * Model FlyerEditHistory
 * 
 */
export type FlyerEditHistory = $Result.DefaultSelection<Prisma.$FlyerEditHistoryPayload>
/**
 * Model UserFlyer
 * 
 */
export type UserFlyer = $Result.DefaultSelection<Prisma.$UserFlyerPayload>
/**
 * Model UserFlyerPage
 * 
 */
export type UserFlyerPage = $Result.DefaultSelection<Prisma.$UserFlyerPagePayload>
/**
 * Model UserFlyerPageProduct
 * 
 */
export type UserFlyerPageProduct = $Result.DefaultSelection<Prisma.$UserFlyerPageProductPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  admin: 'admin',
  supplier: 'supplier',
  approver: 'approver',
  end_user: 'end_user'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PromoSlotSize: {
  single: 'single',
  horizontal: 'horizontal',
  square: 'square',
  full_page: 'full_page',
  footer: 'footer'
};

export type PromoSlotSize = (typeof PromoSlotSize)[keyof typeof PromoSlotSize]


export const FlyerStatus: {
  draft: 'draft',
  pending_verification: 'pending_verification',
  pending_approval: 'pending_approval',
  approved: 'approved',
  rejected: 'rejected',
  active: 'active',
  expired: 'expired'
};

export type FlyerStatus = (typeof FlyerStatus)[keyof typeof FlyerStatus]


export const SlotType: {
  product: 'product',
  promo: 'promo',
  empty: 'empty'
};

export type SlotType = (typeof SlotType)[keyof typeof SlotType]


export const VerificationStatus: {
  success: 'success',
  failed: 'failed'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const ApprovalStatus: {
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const FlyerActionType: {
  add_product: 'add_product',
  remove_product: 'remove_product',
  add_page: 'add_page',
  remove_page: 'remove_page',
  update_info: 'update_info',
  reorder: 'reorder'
};

export type FlyerActionType = (typeof FlyerActionType)[keyof typeof FlyerActionType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PromoSlotSize = $Enums.PromoSlotSize

export const PromoSlotSize: typeof $Enums.PromoSlotSize

export type FlyerStatus = $Enums.FlyerStatus

export const FlyerStatus: typeof $Enums.FlyerStatus

export type SlotType = $Enums.SlotType

export const SlotType: typeof $Enums.SlotType

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type FlyerActionType = $Enums.FlyerActionType

export const FlyerActionType: typeof $Enums.FlyerActionType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userBrand`: Exposes CRUD operations for the **UserBrand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBrands
    * const userBrands = await prisma.userBrand.findMany()
    * ```
    */
  get userBrand(): Prisma.UserBrandDelegate<ExtArgs>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.icon`: Exposes CRUD operations for the **Icon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Icons
    * const icons = await prisma.icon.findMany()
    * ```
    */
  get icon(): Prisma.IconDelegate<ExtArgs>;

  /**
   * `prisma.productIcon`: Exposes CRUD operations for the **ProductIcon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductIcons
    * const productIcons = await prisma.productIcon.findMany()
    * ```
    */
  get productIcon(): Prisma.ProductIconDelegate<ExtArgs>;

  /**
   * `prisma.promoImage`: Exposes CRUD operations for the **PromoImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PromoImages
    * const promoImages = await prisma.promoImage.findMany()
    * ```
    */
  get promoImage(): Prisma.PromoImageDelegate<ExtArgs>;

  /**
   * `prisma.flyer`: Exposes CRUD operations for the **Flyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flyers
    * const flyers = await prisma.flyer.findMany()
    * ```
    */
  get flyer(): Prisma.FlyerDelegate<ExtArgs>;

  /**
   * `prisma.flyerPage`: Exposes CRUD operations for the **FlyerPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlyerPages
    * const flyerPages = await prisma.flyerPage.findMany()
    * ```
    */
  get flyerPage(): Prisma.FlyerPageDelegate<ExtArgs>;

  /**
   * `prisma.flyerPageSlot`: Exposes CRUD operations for the **FlyerPageSlot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlyerPageSlots
    * const flyerPageSlots = await prisma.flyerPageSlot.findMany()
    * ```
    */
  get flyerPageSlot(): Prisma.FlyerPageSlotDelegate<ExtArgs>;

  /**
   * `prisma.verificationLog`: Exposes CRUD operations for the **VerificationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationLogs
    * const verificationLogs = await prisma.verificationLog.findMany()
    * ```
    */
  get verificationLog(): Prisma.VerificationLogDelegate<ExtArgs>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<ExtArgs>;

  /**
   * `prisma.approvalWorkflow`: Exposes CRUD operations for the **ApprovalWorkflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalWorkflows
    * const approvalWorkflows = await prisma.approvalWorkflow.findMany()
    * ```
    */
  get approvalWorkflow(): Prisma.ApprovalWorkflowDelegate<ExtArgs>;

  /**
   * `prisma.flyerVersion`: Exposes CRUD operations for the **FlyerVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlyerVersions
    * const flyerVersions = await prisma.flyerVersion.findMany()
    * ```
    */
  get flyerVersion(): Prisma.FlyerVersionDelegate<ExtArgs>;

  /**
   * `prisma.flyerEditHistory`: Exposes CRUD operations for the **FlyerEditHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlyerEditHistories
    * const flyerEditHistories = await prisma.flyerEditHistory.findMany()
    * ```
    */
  get flyerEditHistory(): Prisma.FlyerEditHistoryDelegate<ExtArgs>;

  /**
   * `prisma.userFlyer`: Exposes CRUD operations for the **UserFlyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFlyers
    * const userFlyers = await prisma.userFlyer.findMany()
    * ```
    */
  get userFlyer(): Prisma.UserFlyerDelegate<ExtArgs>;

  /**
   * `prisma.userFlyerPage`: Exposes CRUD operations for the **UserFlyerPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFlyerPages
    * const userFlyerPages = await prisma.userFlyerPage.findMany()
    * ```
    */
  get userFlyerPage(): Prisma.UserFlyerPageDelegate<ExtArgs>;

  /**
   * `prisma.userFlyerPageProduct`: Exposes CRUD operations for the **UserFlyerPageProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserFlyerPageProducts
    * const userFlyerPageProducts = await prisma.userFlyerPageProduct.findMany()
    * ```
    */
  get userFlyerPageProduct(): Prisma.UserFlyerPageProductDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserBrand: 'UserBrand',
    Brand: 'Brand',
    Product: 'Product',
    Icon: 'Icon',
    ProductIcon: 'ProductIcon',
    PromoImage: 'PromoImage',
    Flyer: 'Flyer',
    FlyerPage: 'FlyerPage',
    FlyerPageSlot: 'FlyerPageSlot',
    VerificationLog: 'VerificationLog',
    Approval: 'Approval',
    ApprovalWorkflow: 'ApprovalWorkflow',
    FlyerVersion: 'FlyerVersion',
    FlyerEditHistory: 'FlyerEditHistory',
    UserFlyer: 'UserFlyer',
    UserFlyerPage: 'UserFlyerPage',
    UserFlyerPageProduct: 'UserFlyerPageProduct',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userBrand" | "brand" | "product" | "icon" | "productIcon" | "promoImage" | "flyer" | "flyerPage" | "flyerPageSlot" | "verificationLog" | "approval" | "approvalWorkflow" | "flyerVersion" | "flyerEditHistory" | "userFlyer" | "userFlyerPage" | "userFlyerPageProduct" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserBrand: {
        payload: Prisma.$UserBrandPayload<ExtArgs>
        fields: Prisma.UserBrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>
          }
          findFirst: {
            args: Prisma.UserBrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>
          }
          findMany: {
            args: Prisma.UserBrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>[]
          }
          create: {
            args: Prisma.UserBrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>
          }
          createMany: {
            args: Prisma.UserBrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>[]
          }
          delete: {
            args: Prisma.UserBrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>
          }
          update: {
            args: Prisma.UserBrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>
          }
          deleteMany: {
            args: Prisma.UserBrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBrandPayload>
          }
          aggregate: {
            args: Prisma.UserBrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBrand>
          }
          groupBy: {
            args: Prisma.UserBrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBrandCountArgs<ExtArgs>
            result: $Utils.Optional<UserBrandCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Icon: {
        payload: Prisma.$IconPayload<ExtArgs>
        fields: Prisma.IconFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IconFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IconFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>
          }
          findFirst: {
            args: Prisma.IconFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IconFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>
          }
          findMany: {
            args: Prisma.IconFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>[]
          }
          create: {
            args: Prisma.IconCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>
          }
          createMany: {
            args: Prisma.IconCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IconCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>[]
          }
          delete: {
            args: Prisma.IconDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>
          }
          update: {
            args: Prisma.IconUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>
          }
          deleteMany: {
            args: Prisma.IconDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IconUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IconUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IconPayload>
          }
          aggregate: {
            args: Prisma.IconAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIcon>
          }
          groupBy: {
            args: Prisma.IconGroupByArgs<ExtArgs>
            result: $Utils.Optional<IconGroupByOutputType>[]
          }
          count: {
            args: Prisma.IconCountArgs<ExtArgs>
            result: $Utils.Optional<IconCountAggregateOutputType> | number
          }
        }
      }
      ProductIcon: {
        payload: Prisma.$ProductIconPayload<ExtArgs>
        fields: Prisma.ProductIconFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductIconFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductIconFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>
          }
          findFirst: {
            args: Prisma.ProductIconFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductIconFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>
          }
          findMany: {
            args: Prisma.ProductIconFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>[]
          }
          create: {
            args: Prisma.ProductIconCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>
          }
          createMany: {
            args: Prisma.ProductIconCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductIconCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>[]
          }
          delete: {
            args: Prisma.ProductIconDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>
          }
          update: {
            args: Prisma.ProductIconUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>
          }
          deleteMany: {
            args: Prisma.ProductIconDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductIconUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductIconUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductIconPayload>
          }
          aggregate: {
            args: Prisma.ProductIconAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductIcon>
          }
          groupBy: {
            args: Prisma.ProductIconGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductIconGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductIconCountArgs<ExtArgs>
            result: $Utils.Optional<ProductIconCountAggregateOutputType> | number
          }
        }
      }
      PromoImage: {
        payload: Prisma.$PromoImagePayload<ExtArgs>
        fields: Prisma.PromoImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PromoImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PromoImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>
          }
          findFirst: {
            args: Prisma.PromoImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PromoImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>
          }
          findMany: {
            args: Prisma.PromoImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>[]
          }
          create: {
            args: Prisma.PromoImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>
          }
          createMany: {
            args: Prisma.PromoImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PromoImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>[]
          }
          delete: {
            args: Prisma.PromoImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>
          }
          update: {
            args: Prisma.PromoImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>
          }
          deleteMany: {
            args: Prisma.PromoImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PromoImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PromoImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PromoImagePayload>
          }
          aggregate: {
            args: Prisma.PromoImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePromoImage>
          }
          groupBy: {
            args: Prisma.PromoImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PromoImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PromoImageCountArgs<ExtArgs>
            result: $Utils.Optional<PromoImageCountAggregateOutputType> | number
          }
        }
      }
      Flyer: {
        payload: Prisma.$FlyerPayload<ExtArgs>
        fields: Prisma.FlyerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlyerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlyerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>
          }
          findFirst: {
            args: Prisma.FlyerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlyerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>
          }
          findMany: {
            args: Prisma.FlyerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>[]
          }
          create: {
            args: Prisma.FlyerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>
          }
          createMany: {
            args: Prisma.FlyerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlyerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>[]
          }
          delete: {
            args: Prisma.FlyerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>
          }
          update: {
            args: Prisma.FlyerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>
          }
          deleteMany: {
            args: Prisma.FlyerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlyerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlyerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPayload>
          }
          aggregate: {
            args: Prisma.FlyerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlyer>
          }
          groupBy: {
            args: Prisma.FlyerGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlyerGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlyerCountArgs<ExtArgs>
            result: $Utils.Optional<FlyerCountAggregateOutputType> | number
          }
        }
      }
      FlyerPage: {
        payload: Prisma.$FlyerPagePayload<ExtArgs>
        fields: Prisma.FlyerPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlyerPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlyerPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>
          }
          findFirst: {
            args: Prisma.FlyerPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlyerPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>
          }
          findMany: {
            args: Prisma.FlyerPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>[]
          }
          create: {
            args: Prisma.FlyerPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>
          }
          createMany: {
            args: Prisma.FlyerPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlyerPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>[]
          }
          delete: {
            args: Prisma.FlyerPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>
          }
          update: {
            args: Prisma.FlyerPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>
          }
          deleteMany: {
            args: Prisma.FlyerPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlyerPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlyerPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPagePayload>
          }
          aggregate: {
            args: Prisma.FlyerPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlyerPage>
          }
          groupBy: {
            args: Prisma.FlyerPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlyerPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlyerPageCountArgs<ExtArgs>
            result: $Utils.Optional<FlyerPageCountAggregateOutputType> | number
          }
        }
      }
      FlyerPageSlot: {
        payload: Prisma.$FlyerPageSlotPayload<ExtArgs>
        fields: Prisma.FlyerPageSlotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlyerPageSlotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlyerPageSlotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>
          }
          findFirst: {
            args: Prisma.FlyerPageSlotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlyerPageSlotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>
          }
          findMany: {
            args: Prisma.FlyerPageSlotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>[]
          }
          create: {
            args: Prisma.FlyerPageSlotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>
          }
          createMany: {
            args: Prisma.FlyerPageSlotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlyerPageSlotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>[]
          }
          delete: {
            args: Prisma.FlyerPageSlotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>
          }
          update: {
            args: Prisma.FlyerPageSlotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>
          }
          deleteMany: {
            args: Prisma.FlyerPageSlotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlyerPageSlotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlyerPageSlotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerPageSlotPayload>
          }
          aggregate: {
            args: Prisma.FlyerPageSlotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlyerPageSlot>
          }
          groupBy: {
            args: Prisma.FlyerPageSlotGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlyerPageSlotGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlyerPageSlotCountArgs<ExtArgs>
            result: $Utils.Optional<FlyerPageSlotCountAggregateOutputType> | number
          }
        }
      }
      VerificationLog: {
        payload: Prisma.$VerificationLogPayload<ExtArgs>
        fields: Prisma.VerificationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>
          }
          findFirst: {
            args: Prisma.VerificationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>
          }
          findMany: {
            args: Prisma.VerificationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>[]
          }
          create: {
            args: Prisma.VerificationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>
          }
          createMany: {
            args: Prisma.VerificationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>[]
          }
          delete: {
            args: Prisma.VerificationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>
          }
          update: {
            args: Prisma.VerificationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>
          }
          deleteMany: {
            args: Prisma.VerificationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationLogPayload>
          }
          aggregate: {
            args: Prisma.VerificationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationLog>
          }
          groupBy: {
            args: Prisma.VerificationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationLogCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationLogCountAggregateOutputType> | number
          }
        }
      }
      Approval: {
        payload: Prisma.$ApprovalPayload<ExtArgs>
        fields: Prisma.ApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findFirst: {
            args: Prisma.ApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findMany: {
            args: Prisma.ApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          create: {
            args: Prisma.ApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          createMany: {
            args: Prisma.ApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          delete: {
            args: Prisma.ApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          update: {
            args: Prisma.ApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          aggregate: {
            args: Prisma.ApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApproval>
          }
          groupBy: {
            args: Prisma.ApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalCountAggregateOutputType> | number
          }
        }
      }
      ApprovalWorkflow: {
        payload: Prisma.$ApprovalWorkflowPayload<ExtArgs>
        fields: Prisma.ApprovalWorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalWorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalWorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          findFirst: {
            args: Prisma.ApprovalWorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalWorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          findMany: {
            args: Prisma.ApprovalWorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>[]
          }
          create: {
            args: Prisma.ApprovalWorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          createMany: {
            args: Prisma.ApprovalWorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalWorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>[]
          }
          delete: {
            args: Prisma.ApprovalWorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          update: {
            args: Prisma.ApprovalWorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalWorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalWorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApprovalWorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalWorkflowPayload>
          }
          aggregate: {
            args: Prisma.ApprovalWorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalWorkflow>
          }
          groupBy: {
            args: Prisma.ApprovalWorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalWorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalWorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalWorkflowCountAggregateOutputType> | number
          }
        }
      }
      FlyerVersion: {
        payload: Prisma.$FlyerVersionPayload<ExtArgs>
        fields: Prisma.FlyerVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlyerVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlyerVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>
          }
          findFirst: {
            args: Prisma.FlyerVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlyerVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>
          }
          findMany: {
            args: Prisma.FlyerVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>[]
          }
          create: {
            args: Prisma.FlyerVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>
          }
          createMany: {
            args: Prisma.FlyerVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlyerVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>[]
          }
          delete: {
            args: Prisma.FlyerVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>
          }
          update: {
            args: Prisma.FlyerVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>
          }
          deleteMany: {
            args: Prisma.FlyerVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlyerVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlyerVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerVersionPayload>
          }
          aggregate: {
            args: Prisma.FlyerVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlyerVersion>
          }
          groupBy: {
            args: Prisma.FlyerVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlyerVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlyerVersionCountArgs<ExtArgs>
            result: $Utils.Optional<FlyerVersionCountAggregateOutputType> | number
          }
        }
      }
      FlyerEditHistory: {
        payload: Prisma.$FlyerEditHistoryPayload<ExtArgs>
        fields: Prisma.FlyerEditHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlyerEditHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlyerEditHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>
          }
          findFirst: {
            args: Prisma.FlyerEditHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlyerEditHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>
          }
          findMany: {
            args: Prisma.FlyerEditHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>[]
          }
          create: {
            args: Prisma.FlyerEditHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>
          }
          createMany: {
            args: Prisma.FlyerEditHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlyerEditHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>[]
          }
          delete: {
            args: Prisma.FlyerEditHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>
          }
          update: {
            args: Prisma.FlyerEditHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>
          }
          deleteMany: {
            args: Prisma.FlyerEditHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlyerEditHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlyerEditHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlyerEditHistoryPayload>
          }
          aggregate: {
            args: Prisma.FlyerEditHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlyerEditHistory>
          }
          groupBy: {
            args: Prisma.FlyerEditHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlyerEditHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlyerEditHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<FlyerEditHistoryCountAggregateOutputType> | number
          }
        }
      }
      UserFlyer: {
        payload: Prisma.$UserFlyerPayload<ExtArgs>
        fields: Prisma.UserFlyerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFlyerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFlyerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>
          }
          findFirst: {
            args: Prisma.UserFlyerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFlyerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>
          }
          findMany: {
            args: Prisma.UserFlyerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>[]
          }
          create: {
            args: Prisma.UserFlyerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>
          }
          createMany: {
            args: Prisma.UserFlyerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFlyerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>[]
          }
          delete: {
            args: Prisma.UserFlyerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>
          }
          update: {
            args: Prisma.UserFlyerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>
          }
          deleteMany: {
            args: Prisma.UserFlyerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFlyerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFlyerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPayload>
          }
          aggregate: {
            args: Prisma.UserFlyerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFlyer>
          }
          groupBy: {
            args: Prisma.UserFlyerGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFlyerGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFlyerCountArgs<ExtArgs>
            result: $Utils.Optional<UserFlyerCountAggregateOutputType> | number
          }
        }
      }
      UserFlyerPage: {
        payload: Prisma.$UserFlyerPagePayload<ExtArgs>
        fields: Prisma.UserFlyerPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFlyerPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFlyerPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>
          }
          findFirst: {
            args: Prisma.UserFlyerPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFlyerPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>
          }
          findMany: {
            args: Prisma.UserFlyerPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>[]
          }
          create: {
            args: Prisma.UserFlyerPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>
          }
          createMany: {
            args: Prisma.UserFlyerPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFlyerPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>[]
          }
          delete: {
            args: Prisma.UserFlyerPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>
          }
          update: {
            args: Prisma.UserFlyerPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>
          }
          deleteMany: {
            args: Prisma.UserFlyerPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFlyerPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFlyerPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPagePayload>
          }
          aggregate: {
            args: Prisma.UserFlyerPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFlyerPage>
          }
          groupBy: {
            args: Prisma.UserFlyerPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFlyerPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFlyerPageCountArgs<ExtArgs>
            result: $Utils.Optional<UserFlyerPageCountAggregateOutputType> | number
          }
        }
      }
      UserFlyerPageProduct: {
        payload: Prisma.$UserFlyerPageProductPayload<ExtArgs>
        fields: Prisma.UserFlyerPageProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFlyerPageProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFlyerPageProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>
          }
          findFirst: {
            args: Prisma.UserFlyerPageProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFlyerPageProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>
          }
          findMany: {
            args: Prisma.UserFlyerPageProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>[]
          }
          create: {
            args: Prisma.UserFlyerPageProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>
          }
          createMany: {
            args: Prisma.UserFlyerPageProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserFlyerPageProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>[]
          }
          delete: {
            args: Prisma.UserFlyerPageProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>
          }
          update: {
            args: Prisma.UserFlyerPageProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>
          }
          deleteMany: {
            args: Prisma.UserFlyerPageProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserFlyerPageProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserFlyerPageProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserFlyerPageProductPayload>
          }
          aggregate: {
            args: Prisma.UserFlyerPageProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserFlyerPageProduct>
          }
          groupBy: {
            args: Prisma.UserFlyerPageProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserFlyerPageProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserFlyerPageProductCountArgs<ExtArgs>
            result: $Utils.Optional<UserFlyerPageProductCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    brands: number
    products: number
    flyers: number
    approvals: number
    userFlyers: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | UserCountOutputTypeCountBrandsArgs
    products?: boolean | UserCountOutputTypeCountProductsArgs
    flyers?: boolean | UserCountOutputTypeCountFlyersArgs
    approvals?: boolean | UserCountOutputTypeCountApprovalsArgs
    userFlyers?: boolean | UserCountOutputTypeCountUserFlyersArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBrandWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlyersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserFlyersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    users: number
    products: number
    promoImages: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | BrandCountOutputTypeCountUsersArgs
    products?: boolean | BrandCountOutputTypeCountProductsArgs
    promoImages?: boolean | BrandCountOutputTypeCountPromoImagesArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBrandWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountPromoImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoImageWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    icons: number
    flyerPageSlots: number
    userFlyerPageProducts: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    icons?: boolean | ProductCountOutputTypeCountIconsArgs
    flyerPageSlots?: boolean | ProductCountOutputTypeCountFlyerPageSlotsArgs
    userFlyerPageProducts?: boolean | ProductCountOutputTypeCountUserFlyerPageProductsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountIconsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductIconWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountFlyerPageSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageSlotWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountUserFlyerPageProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerPageProductWhereInput
  }


  /**
   * Count Type IconCountOutputType
   */

  export type IconCountOutputType = {
    productIcons: number
  }

  export type IconCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productIcons?: boolean | IconCountOutputTypeCountProductIconsArgs
  }

  // Custom InputTypes
  /**
   * IconCountOutputType without action
   */
  export type IconCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IconCountOutputType
     */
    select?: IconCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IconCountOutputType without action
   */
  export type IconCountOutputTypeCountProductIconsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductIconWhereInput
  }


  /**
   * Count Type PromoImageCountOutputType
   */

  export type PromoImageCountOutputType = {
    flyerPageSlots: number
    footerPages: number
  }

  export type PromoImageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyerPageSlots?: boolean | PromoImageCountOutputTypeCountFlyerPageSlotsArgs
    footerPages?: boolean | PromoImageCountOutputTypeCountFooterPagesArgs
  }

  // Custom InputTypes
  /**
   * PromoImageCountOutputType without action
   */
  export type PromoImageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImageCountOutputType
     */
    select?: PromoImageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PromoImageCountOutputType without action
   */
  export type PromoImageCountOutputTypeCountFlyerPageSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageSlotWhereInput
  }

  /**
   * PromoImageCountOutputType without action
   */
  export type PromoImageCountOutputTypeCountFooterPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageWhereInput
  }


  /**
   * Count Type FlyerCountOutputType
   */

  export type FlyerCountOutputType = {
    pages: number
    verificationLogs: number
    approvals: number
    versions: number
    editHistory: number
  }

  export type FlyerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | FlyerCountOutputTypeCountPagesArgs
    verificationLogs?: boolean | FlyerCountOutputTypeCountVerificationLogsArgs
    approvals?: boolean | FlyerCountOutputTypeCountApprovalsArgs
    versions?: boolean | FlyerCountOutputTypeCountVersionsArgs
    editHistory?: boolean | FlyerCountOutputTypeCountEditHistoryArgs
  }

  // Custom InputTypes
  /**
   * FlyerCountOutputType without action
   */
  export type FlyerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerCountOutputType
     */
    select?: FlyerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlyerCountOutputType without action
   */
  export type FlyerCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageWhereInput
  }

  /**
   * FlyerCountOutputType without action
   */
  export type FlyerCountOutputTypeCountVerificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationLogWhereInput
  }

  /**
   * FlyerCountOutputType without action
   */
  export type FlyerCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * FlyerCountOutputType without action
   */
  export type FlyerCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerVersionWhereInput
  }

  /**
   * FlyerCountOutputType without action
   */
  export type FlyerCountOutputTypeCountEditHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerEditHistoryWhereInput
  }


  /**
   * Count Type FlyerPageCountOutputType
   */

  export type FlyerPageCountOutputType = {
    slots: number
  }

  export type FlyerPageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    slots?: boolean | FlyerPageCountOutputTypeCountSlotsArgs
  }

  // Custom InputTypes
  /**
   * FlyerPageCountOutputType without action
   */
  export type FlyerPageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageCountOutputType
     */
    select?: FlyerPageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlyerPageCountOutputType without action
   */
  export type FlyerPageCountOutputTypeCountSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageSlotWhereInput
  }


  /**
   * Count Type FlyerPageSlotCountOutputType
   */

  export type FlyerPageSlotCountOutputType = {
    promoSpannedSlots: number
  }

  export type FlyerPageSlotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    promoSpannedSlots?: boolean | FlyerPageSlotCountOutputTypeCountPromoSpannedSlotsArgs
  }

  // Custom InputTypes
  /**
   * FlyerPageSlotCountOutputType without action
   */
  export type FlyerPageSlotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlotCountOutputType
     */
    select?: FlyerPageSlotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FlyerPageSlotCountOutputType without action
   */
  export type FlyerPageSlotCountOutputTypeCountPromoSpannedSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageSlotWhereInput
  }


  /**
   * Count Type UserFlyerCountOutputType
   */

  export type UserFlyerCountOutputType = {
    pages: number
  }

  export type UserFlyerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pages?: boolean | UserFlyerCountOutputTypeCountPagesArgs
  }

  // Custom InputTypes
  /**
   * UserFlyerCountOutputType without action
   */
  export type UserFlyerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerCountOutputType
     */
    select?: UserFlyerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserFlyerCountOutputType without action
   */
  export type UserFlyerCountOutputTypeCountPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerPageWhereInput
  }


  /**
   * Count Type UserFlyerPageCountOutputType
   */

  export type UserFlyerPageCountOutputType = {
    products: number
  }

  export type UserFlyerPageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | UserFlyerPageCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * UserFlyerPageCountOutputType without action
   */
  export type UserFlyerPageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageCountOutputType
     */
    select?: UserFlyerPageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserFlyerPageCountOutputType without action
   */
  export type UserFlyerPageCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerPageProductWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    brands?: boolean | User$brandsArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    flyers?: boolean | User$flyersArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    userFlyers?: boolean | User$userFlyersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brands?: boolean | User$brandsArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    flyers?: boolean | User$flyersArgs<ExtArgs>
    approvals?: boolean | User$approvalsArgs<ExtArgs>
    userFlyers?: boolean | User$userFlyersArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      brands: Prisma.$UserBrandPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      flyers: Prisma.$FlyerPayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
      userFlyers: Prisma.$UserFlyerPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      firstName: string | null
      lastName: string | null
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brands<T extends User$brandsArgs<ExtArgs> = {}>(args?: Subset<T, User$brandsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends User$productsArgs<ExtArgs> = {}>(args?: Subset<T, User$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    flyers<T extends User$flyersArgs<ExtArgs> = {}>(args?: Subset<T, User$flyersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends User$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    userFlyers<T extends User$userFlyersArgs<ExtArgs> = {}>(args?: Subset<T, User$userFlyersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.brands
   */
  export type User$brandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    where?: UserBrandWhereInput
    orderBy?: UserBrandOrderByWithRelationInput | UserBrandOrderByWithRelationInput[]
    cursor?: UserBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBrandScalarFieldEnum | UserBrandScalarFieldEnum[]
  }

  /**
   * User.products
   */
  export type User$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User.flyers
   */
  export type User$flyersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    where?: FlyerWhereInput
    orderBy?: FlyerOrderByWithRelationInput | FlyerOrderByWithRelationInput[]
    cursor?: FlyerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerScalarFieldEnum | FlyerScalarFieldEnum[]
  }

  /**
   * User.approvals
   */
  export type User$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * User.userFlyers
   */
  export type User$userFlyersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    where?: UserFlyerWhereInput
    orderBy?: UserFlyerOrderByWithRelationInput | UserFlyerOrderByWithRelationInput[]
    cursor?: UserFlyerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFlyerScalarFieldEnum | UserFlyerScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserBrand
   */

  export type AggregateUserBrand = {
    _count: UserBrandCountAggregateOutputType | null
    _min: UserBrandMinAggregateOutputType | null
    _max: UserBrandMaxAggregateOutputType | null
  }

  export type UserBrandMinAggregateOutputType = {
    id: string | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
  }

  export type UserBrandMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    brandId: string | null
    createdAt: Date | null
  }

  export type UserBrandCountAggregateOutputType = {
    id: number
    userId: number
    brandId: number
    createdAt: number
    _all: number
  }


  export type UserBrandMinAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
  }

  export type UserBrandMaxAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
  }

  export type UserBrandCountAggregateInputType = {
    id?: true
    userId?: true
    brandId?: true
    createdAt?: true
    _all?: true
  }

  export type UserBrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBrand to aggregate.
     */
    where?: UserBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBrands to fetch.
     */
    orderBy?: UserBrandOrderByWithRelationInput | UserBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBrands
    **/
    _count?: true | UserBrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBrandMaxAggregateInputType
  }

  export type GetUserBrandAggregateType<T extends UserBrandAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBrand[P]>
      : GetScalarType<T[P], AggregateUserBrand[P]>
  }




  export type UserBrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBrandWhereInput
    orderBy?: UserBrandOrderByWithAggregationInput | UserBrandOrderByWithAggregationInput[]
    by: UserBrandScalarFieldEnum[] | UserBrandScalarFieldEnum
    having?: UserBrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBrandCountAggregateInputType | true
    _min?: UserBrandMinAggregateInputType
    _max?: UserBrandMaxAggregateInputType
  }

  export type UserBrandGroupByOutputType = {
    id: string
    userId: string
    brandId: string
    createdAt: Date
    _count: UserBrandCountAggregateOutputType | null
    _min: UserBrandMinAggregateOutputType | null
    _max: UserBrandMaxAggregateOutputType | null
  }

  type GetUserBrandGroupByPayload<T extends UserBrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBrandGroupByOutputType[P]>
            : GetScalarType<T[P], UserBrandGroupByOutputType[P]>
        }
      >
    >


  export type UserBrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBrand"]>

  export type UserBrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBrand"]>

  export type UserBrandSelectScalar = {
    id?: boolean
    userId?: boolean
    brandId?: boolean
    createdAt?: boolean
  }

  export type UserBrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type UserBrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $UserBrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBrand"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      brand: Prisma.$BrandPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      brandId: string
      createdAt: Date
    }, ExtArgs["result"]["userBrand"]>
    composites: {}
  }

  type UserBrandGetPayload<S extends boolean | null | undefined | UserBrandDefaultArgs> = $Result.GetResult<Prisma.$UserBrandPayload, S>

  type UserBrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBrandCountAggregateInputType | true
    }

  export interface UserBrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBrand'], meta: { name: 'UserBrand' } }
    /**
     * Find zero or one UserBrand that matches the filter.
     * @param {UserBrandFindUniqueArgs} args - Arguments to find a UserBrand
     * @example
     * // Get one UserBrand
     * const userBrand = await prisma.userBrand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBrandFindUniqueArgs>(args: SelectSubset<T, UserBrandFindUniqueArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBrand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBrandFindUniqueOrThrowArgs} args - Arguments to find a UserBrand
     * @example
     * // Get one UserBrand
     * const userBrand = await prisma.userBrand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBrandFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBrand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandFindFirstArgs} args - Arguments to find a UserBrand
     * @example
     * // Get one UserBrand
     * const userBrand = await prisma.userBrand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBrandFindFirstArgs>(args?: SelectSubset<T, UserBrandFindFirstArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBrand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandFindFirstOrThrowArgs} args - Arguments to find a UserBrand
     * @example
     * // Get one UserBrand
     * const userBrand = await prisma.userBrand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBrandFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBrands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBrands
     * const userBrands = await prisma.userBrand.findMany()
     * 
     * // Get first 10 UserBrands
     * const userBrands = await prisma.userBrand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBrandWithIdOnly = await prisma.userBrand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBrandFindManyArgs>(args?: SelectSubset<T, UserBrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBrand.
     * @param {UserBrandCreateArgs} args - Arguments to create a UserBrand.
     * @example
     * // Create one UserBrand
     * const UserBrand = await prisma.userBrand.create({
     *   data: {
     *     // ... data to create a UserBrand
     *   }
     * })
     * 
     */
    create<T extends UserBrandCreateArgs>(args: SelectSubset<T, UserBrandCreateArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBrands.
     * @param {UserBrandCreateManyArgs} args - Arguments to create many UserBrands.
     * @example
     * // Create many UserBrands
     * const userBrand = await prisma.userBrand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBrandCreateManyArgs>(args?: SelectSubset<T, UserBrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBrands and returns the data saved in the database.
     * @param {UserBrandCreateManyAndReturnArgs} args - Arguments to create many UserBrands.
     * @example
     * // Create many UserBrands
     * const userBrand = await prisma.userBrand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBrands and only return the `id`
     * const userBrandWithIdOnly = await prisma.userBrand.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBrandCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserBrand.
     * @param {UserBrandDeleteArgs} args - Arguments to delete one UserBrand.
     * @example
     * // Delete one UserBrand
     * const UserBrand = await prisma.userBrand.delete({
     *   where: {
     *     // ... filter to delete one UserBrand
     *   }
     * })
     * 
     */
    delete<T extends UserBrandDeleteArgs>(args: SelectSubset<T, UserBrandDeleteArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBrand.
     * @param {UserBrandUpdateArgs} args - Arguments to update one UserBrand.
     * @example
     * // Update one UserBrand
     * const userBrand = await prisma.userBrand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBrandUpdateArgs>(args: SelectSubset<T, UserBrandUpdateArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBrands.
     * @param {UserBrandDeleteManyArgs} args - Arguments to filter UserBrands to delete.
     * @example
     * // Delete a few UserBrands
     * const { count } = await prisma.userBrand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBrandDeleteManyArgs>(args?: SelectSubset<T, UserBrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBrands
     * const userBrand = await prisma.userBrand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBrandUpdateManyArgs>(args: SelectSubset<T, UserBrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBrand.
     * @param {UserBrandUpsertArgs} args - Arguments to update or create a UserBrand.
     * @example
     * // Update or create a UserBrand
     * const userBrand = await prisma.userBrand.upsert({
     *   create: {
     *     // ... data to create a UserBrand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBrand we want to update
     *   }
     * })
     */
    upsert<T extends UserBrandUpsertArgs>(args: SelectSubset<T, UserBrandUpsertArgs<ExtArgs>>): Prisma__UserBrandClient<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBrands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandCountArgs} args - Arguments to filter UserBrands to count.
     * @example
     * // Count the number of UserBrands
     * const count = await prisma.userBrand.count({
     *   where: {
     *     // ... the filter for the UserBrands we want to count
     *   }
     * })
    **/
    count<T extends UserBrandCountArgs>(
      args?: Subset<T, UserBrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBrandAggregateArgs>(args: Subset<T, UserBrandAggregateArgs>): Prisma.PrismaPromise<GetUserBrandAggregateType<T>>

    /**
     * Group by UserBrand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBrandGroupByArgs['orderBy'] }
        : { orderBy?: UserBrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBrand model
   */
  readonly fields: UserBrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBrand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBrand model
   */ 
  interface UserBrandFieldRefs {
    readonly id: FieldRef<"UserBrand", 'String'>
    readonly userId: FieldRef<"UserBrand", 'String'>
    readonly brandId: FieldRef<"UserBrand", 'String'>
    readonly createdAt: FieldRef<"UserBrand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBrand findUnique
   */
  export type UserBrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * Filter, which UserBrand to fetch.
     */
    where: UserBrandWhereUniqueInput
  }

  /**
   * UserBrand findUniqueOrThrow
   */
  export type UserBrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * Filter, which UserBrand to fetch.
     */
    where: UserBrandWhereUniqueInput
  }

  /**
   * UserBrand findFirst
   */
  export type UserBrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * Filter, which UserBrand to fetch.
     */
    where?: UserBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBrands to fetch.
     */
    orderBy?: UserBrandOrderByWithRelationInput | UserBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBrands.
     */
    cursor?: UserBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBrands.
     */
    distinct?: UserBrandScalarFieldEnum | UserBrandScalarFieldEnum[]
  }

  /**
   * UserBrand findFirstOrThrow
   */
  export type UserBrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * Filter, which UserBrand to fetch.
     */
    where?: UserBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBrands to fetch.
     */
    orderBy?: UserBrandOrderByWithRelationInput | UserBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBrands.
     */
    cursor?: UserBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBrands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBrands.
     */
    distinct?: UserBrandScalarFieldEnum | UserBrandScalarFieldEnum[]
  }

  /**
   * UserBrand findMany
   */
  export type UserBrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * Filter, which UserBrands to fetch.
     */
    where?: UserBrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBrands to fetch.
     */
    orderBy?: UserBrandOrderByWithRelationInput | UserBrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBrands.
     */
    cursor?: UserBrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBrands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBrands.
     */
    skip?: number
    distinct?: UserBrandScalarFieldEnum | UserBrandScalarFieldEnum[]
  }

  /**
   * UserBrand create
   */
  export type UserBrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBrand.
     */
    data: XOR<UserBrandCreateInput, UserBrandUncheckedCreateInput>
  }

  /**
   * UserBrand createMany
   */
  export type UserBrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBrands.
     */
    data: UserBrandCreateManyInput | UserBrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBrand createManyAndReturn
   */
  export type UserBrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserBrands.
     */
    data: UserBrandCreateManyInput | UserBrandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBrand update
   */
  export type UserBrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBrand.
     */
    data: XOR<UserBrandUpdateInput, UserBrandUncheckedUpdateInput>
    /**
     * Choose, which UserBrand to update.
     */
    where: UserBrandWhereUniqueInput
  }

  /**
   * UserBrand updateMany
   */
  export type UserBrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBrands.
     */
    data: XOR<UserBrandUpdateManyMutationInput, UserBrandUncheckedUpdateManyInput>
    /**
     * Filter which UserBrands to update
     */
    where?: UserBrandWhereInput
  }

  /**
   * UserBrand upsert
   */
  export type UserBrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBrand to update in case it exists.
     */
    where: UserBrandWhereUniqueInput
    /**
     * In case the UserBrand found by the `where` argument doesn't exist, create a new UserBrand with this data.
     */
    create: XOR<UserBrandCreateInput, UserBrandUncheckedCreateInput>
    /**
     * In case the UserBrand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBrandUpdateInput, UserBrandUncheckedUpdateInput>
  }

  /**
   * UserBrand delete
   */
  export type UserBrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    /**
     * Filter which UserBrand to delete.
     */
    where: UserBrandWhereUniqueInput
  }

  /**
   * UserBrand deleteMany
   */
  export type UserBrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBrands to delete
     */
    where?: UserBrandWhereInput
  }

  /**
   * UserBrand without action
   */
  export type UserBrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    name: string | null
    logoData: Buffer | null
    logoMimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    name: string | null
    logoData: Buffer | null
    logoMimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    logoData: number
    logoMimeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    logoData?: true
    logoMimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    logoData?: true
    logoMimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    logoData?: true
    logoMimeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    name: string
    logoData: Buffer | null
    logoMimeType: string | null
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoData?: boolean
    logoMimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Brand$usersArgs<ExtArgs>
    products?: boolean | Brand$productsArgs<ExtArgs>
    promoImages?: boolean | Brand$promoImagesArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    logoData?: boolean
    logoMimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    logoData?: boolean
    logoMimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Brand$usersArgs<ExtArgs>
    products?: boolean | Brand$productsArgs<ExtArgs>
    promoImages?: boolean | Brand$promoImagesArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      users: Prisma.$UserBrandPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      promoImages: Prisma.$PromoImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      logoData: Buffer | null
      logoMimeType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Brand$usersArgs<ExtArgs> = {}>(args?: Subset<T, Brand$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBrandPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Brand$productsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    promoImages<T extends Brand$promoImagesArgs<ExtArgs> = {}>(args?: Subset<T, Brand$promoImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */ 
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly logoData: FieldRef<"Brand", 'Bytes'>
    readonly logoMimeType: FieldRef<"Brand", 'String'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
  }

  /**
   * Brand.users
   */
  export type Brand$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBrand
     */
    select?: UserBrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBrandInclude<ExtArgs> | null
    where?: UserBrandWhereInput
    orderBy?: UserBrandOrderByWithRelationInput | UserBrandOrderByWithRelationInput[]
    cursor?: UserBrandWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBrandScalarFieldEnum | UserBrandScalarFieldEnum[]
  }

  /**
   * Brand.products
   */
  export type Brand$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Brand.promoImages
   */
  export type Brand$promoImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    where?: PromoImageWhereInput
    orderBy?: PromoImageOrderByWithRelationInput | PromoImageOrderByWithRelationInput[]
    cursor?: PromoImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PromoImageScalarFieldEnum | PromoImageScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: Decimal | null
    originalPrice: Decimal | null
  }

  export type ProductSumAggregateOutputType = {
    price: Decimal | null
    originalPrice: Decimal | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    brandId: string | null
    eanCode: string | null
    name: string | null
    description: string | null
    imageData: Buffer | null
    imageMimeType: string | null
    price: Decimal | null
    originalPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    brandId: string | null
    eanCode: string | null
    name: string | null
    description: string | null
    imageData: Buffer | null
    imageMimeType: string | null
    price: Decimal | null
    originalPrice: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    supplierId: number
    brandId: number
    eanCode: number
    name: number
    description: number
    imageData: number
    imageMimeType: number
    price: number
    originalPrice: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    originalPrice?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    originalPrice?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    eanCode?: true
    name?: true
    description?: true
    imageData?: true
    imageMimeType?: true
    price?: true
    originalPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    eanCode?: true
    name?: true
    description?: true
    imageData?: true
    imageMimeType?: true
    price?: true
    originalPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    eanCode?: true
    name?: true
    description?: true
    imageData?: true
    imageMimeType?: true
    price?: true
    originalPrice?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    supplierId: string
    brandId: string
    eanCode: string
    name: string
    description: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal
    originalPrice: Decimal | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    eanCode?: boolean
    name?: boolean
    description?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    price?: boolean
    originalPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    icons?: boolean | Product$iconsArgs<ExtArgs>
    flyerPageSlots?: boolean | Product$flyerPageSlotsArgs<ExtArgs>
    userFlyerPageProducts?: boolean | Product$userFlyerPageProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    eanCode?: boolean
    name?: boolean
    description?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    price?: boolean
    originalPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    eanCode?: boolean
    name?: boolean
    description?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    price?: boolean
    originalPrice?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    icons?: boolean | Product$iconsArgs<ExtArgs>
    flyerPageSlots?: boolean | Product$flyerPageSlotsArgs<ExtArgs>
    userFlyerPageProducts?: boolean | Product$userFlyerPageProductsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | UserDefaultArgs<ExtArgs>
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      supplier: Prisma.$UserPayload<ExtArgs>
      brand: Prisma.$BrandPayload<ExtArgs>
      icons: Prisma.$ProductIconPayload<ExtArgs>[]
      flyerPageSlots: Prisma.$FlyerPageSlotPayload<ExtArgs>[]
      userFlyerPageProducts: Prisma.$UserFlyerPageProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      brandId: string
      eanCode: string
      name: string
      description: string | null
      imageData: Buffer
      imageMimeType: string
      price: Prisma.Decimal
      originalPrice: Prisma.Decimal | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    icons<T extends Product$iconsArgs<ExtArgs> = {}>(args?: Subset<T, Product$iconsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findMany"> | Null>
    flyerPageSlots<T extends Product$flyerPageSlotsArgs<ExtArgs> = {}>(args?: Subset<T, Product$flyerPageSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findMany"> | Null>
    userFlyerPageProducts<T extends Product$userFlyerPageProductsArgs<ExtArgs> = {}>(args?: Subset<T, Product$userFlyerPageProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly supplierId: FieldRef<"Product", 'String'>
    readonly brandId: FieldRef<"Product", 'String'>
    readonly eanCode: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly imageData: FieldRef<"Product", 'Bytes'>
    readonly imageMimeType: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Decimal'>
    readonly originalPrice: FieldRef<"Product", 'Decimal'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.icons
   */
  export type Product$iconsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    where?: ProductIconWhereInput
    orderBy?: ProductIconOrderByWithRelationInput | ProductIconOrderByWithRelationInput[]
    cursor?: ProductIconWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductIconScalarFieldEnum | ProductIconScalarFieldEnum[]
  }

  /**
   * Product.flyerPageSlots
   */
  export type Product$flyerPageSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    where?: FlyerPageSlotWhereInput
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    cursor?: FlyerPageSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * Product.userFlyerPageProducts
   */
  export type Product$userFlyerPageProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    where?: UserFlyerPageProductWhereInput
    orderBy?: UserFlyerPageProductOrderByWithRelationInput | UserFlyerPageProductOrderByWithRelationInput[]
    cursor?: UserFlyerPageProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFlyerPageProductScalarFieldEnum | UserFlyerPageProductScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Icon
   */

  export type AggregateIcon = {
    _count: IconCountAggregateOutputType | null
    _min: IconMinAggregateOutputType | null
    _max: IconMaxAggregateOutputType | null
  }

  export type IconMinAggregateOutputType = {
    id: string | null
    name: string | null
    imageData: Buffer | null
    imageMimeType: string | null
    isEnergyClass: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IconMaxAggregateOutputType = {
    id: string | null
    name: string | null
    imageData: Buffer | null
    imageMimeType: string | null
    isEnergyClass: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IconCountAggregateOutputType = {
    id: number
    name: number
    imageData: number
    imageMimeType: number
    isEnergyClass: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IconMinAggregateInputType = {
    id?: true
    name?: true
    imageData?: true
    imageMimeType?: true
    isEnergyClass?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IconMaxAggregateInputType = {
    id?: true
    name?: true
    imageData?: true
    imageMimeType?: true
    isEnergyClass?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IconCountAggregateInputType = {
    id?: true
    name?: true
    imageData?: true
    imageMimeType?: true
    isEnergyClass?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IconAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Icon to aggregate.
     */
    where?: IconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Icons to fetch.
     */
    orderBy?: IconOrderByWithRelationInput | IconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Icons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Icons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Icons
    **/
    _count?: true | IconCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IconMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IconMaxAggregateInputType
  }

  export type GetIconAggregateType<T extends IconAggregateArgs> = {
        [P in keyof T & keyof AggregateIcon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIcon[P]>
      : GetScalarType<T[P], AggregateIcon[P]>
  }




  export type IconGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IconWhereInput
    orderBy?: IconOrderByWithAggregationInput | IconOrderByWithAggregationInput[]
    by: IconScalarFieldEnum[] | IconScalarFieldEnum
    having?: IconScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IconCountAggregateInputType | true
    _min?: IconMinAggregateInputType
    _max?: IconMaxAggregateInputType
  }

  export type IconGroupByOutputType = {
    id: string
    name: string
    imageData: Buffer
    imageMimeType: string
    isEnergyClass: boolean
    createdAt: Date
    updatedAt: Date
    _count: IconCountAggregateOutputType | null
    _min: IconMinAggregateOutputType | null
    _max: IconMaxAggregateOutputType | null
  }

  type GetIconGroupByPayload<T extends IconGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IconGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IconGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IconGroupByOutputType[P]>
            : GetScalarType<T[P], IconGroupByOutputType[P]>
        }
      >
    >


  export type IconSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    isEnergyClass?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    productIcons?: boolean | Icon$productIconsArgs<ExtArgs>
    _count?: boolean | IconCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["icon"]>

  export type IconSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    isEnergyClass?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["icon"]>

  export type IconSelectScalar = {
    id?: boolean
    name?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    isEnergyClass?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IconInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productIcons?: boolean | Icon$productIconsArgs<ExtArgs>
    _count?: boolean | IconCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IconIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IconPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Icon"
    objects: {
      productIcons: Prisma.$ProductIconPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      imageData: Buffer
      imageMimeType: string
      isEnergyClass: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["icon"]>
    composites: {}
  }

  type IconGetPayload<S extends boolean | null | undefined | IconDefaultArgs> = $Result.GetResult<Prisma.$IconPayload, S>

  type IconCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IconFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IconCountAggregateInputType | true
    }

  export interface IconDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Icon'], meta: { name: 'Icon' } }
    /**
     * Find zero or one Icon that matches the filter.
     * @param {IconFindUniqueArgs} args - Arguments to find a Icon
     * @example
     * // Get one Icon
     * const icon = await prisma.icon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IconFindUniqueArgs>(args: SelectSubset<T, IconFindUniqueArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Icon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IconFindUniqueOrThrowArgs} args - Arguments to find a Icon
     * @example
     * // Get one Icon
     * const icon = await prisma.icon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IconFindUniqueOrThrowArgs>(args: SelectSubset<T, IconFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Icon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconFindFirstArgs} args - Arguments to find a Icon
     * @example
     * // Get one Icon
     * const icon = await prisma.icon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IconFindFirstArgs>(args?: SelectSubset<T, IconFindFirstArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Icon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconFindFirstOrThrowArgs} args - Arguments to find a Icon
     * @example
     * // Get one Icon
     * const icon = await prisma.icon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IconFindFirstOrThrowArgs>(args?: SelectSubset<T, IconFindFirstOrThrowArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Icons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Icons
     * const icons = await prisma.icon.findMany()
     * 
     * // Get first 10 Icons
     * const icons = await prisma.icon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iconWithIdOnly = await prisma.icon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IconFindManyArgs>(args?: SelectSubset<T, IconFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Icon.
     * @param {IconCreateArgs} args - Arguments to create a Icon.
     * @example
     * // Create one Icon
     * const Icon = await prisma.icon.create({
     *   data: {
     *     // ... data to create a Icon
     *   }
     * })
     * 
     */
    create<T extends IconCreateArgs>(args: SelectSubset<T, IconCreateArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Icons.
     * @param {IconCreateManyArgs} args - Arguments to create many Icons.
     * @example
     * // Create many Icons
     * const icon = await prisma.icon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IconCreateManyArgs>(args?: SelectSubset<T, IconCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Icons and returns the data saved in the database.
     * @param {IconCreateManyAndReturnArgs} args - Arguments to create many Icons.
     * @example
     * // Create many Icons
     * const icon = await prisma.icon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Icons and only return the `id`
     * const iconWithIdOnly = await prisma.icon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IconCreateManyAndReturnArgs>(args?: SelectSubset<T, IconCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Icon.
     * @param {IconDeleteArgs} args - Arguments to delete one Icon.
     * @example
     * // Delete one Icon
     * const Icon = await prisma.icon.delete({
     *   where: {
     *     // ... filter to delete one Icon
     *   }
     * })
     * 
     */
    delete<T extends IconDeleteArgs>(args: SelectSubset<T, IconDeleteArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Icon.
     * @param {IconUpdateArgs} args - Arguments to update one Icon.
     * @example
     * // Update one Icon
     * const icon = await prisma.icon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IconUpdateArgs>(args: SelectSubset<T, IconUpdateArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Icons.
     * @param {IconDeleteManyArgs} args - Arguments to filter Icons to delete.
     * @example
     * // Delete a few Icons
     * const { count } = await prisma.icon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IconDeleteManyArgs>(args?: SelectSubset<T, IconDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Icons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Icons
     * const icon = await prisma.icon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IconUpdateManyArgs>(args: SelectSubset<T, IconUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Icon.
     * @param {IconUpsertArgs} args - Arguments to update or create a Icon.
     * @example
     * // Update or create a Icon
     * const icon = await prisma.icon.upsert({
     *   create: {
     *     // ... data to create a Icon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Icon we want to update
     *   }
     * })
     */
    upsert<T extends IconUpsertArgs>(args: SelectSubset<T, IconUpsertArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Icons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconCountArgs} args - Arguments to filter Icons to count.
     * @example
     * // Count the number of Icons
     * const count = await prisma.icon.count({
     *   where: {
     *     // ... the filter for the Icons we want to count
     *   }
     * })
    **/
    count<T extends IconCountArgs>(
      args?: Subset<T, IconCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IconCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Icon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IconAggregateArgs>(args: Subset<T, IconAggregateArgs>): Prisma.PrismaPromise<GetIconAggregateType<T>>

    /**
     * Group by Icon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IconGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IconGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IconGroupByArgs['orderBy'] }
        : { orderBy?: IconGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IconGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIconGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Icon model
   */
  readonly fields: IconFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Icon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IconClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productIcons<T extends Icon$productIconsArgs<ExtArgs> = {}>(args?: Subset<T, Icon$productIconsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Icon model
   */ 
  interface IconFieldRefs {
    readonly id: FieldRef<"Icon", 'String'>
    readonly name: FieldRef<"Icon", 'String'>
    readonly imageData: FieldRef<"Icon", 'Bytes'>
    readonly imageMimeType: FieldRef<"Icon", 'String'>
    readonly isEnergyClass: FieldRef<"Icon", 'Boolean'>
    readonly createdAt: FieldRef<"Icon", 'DateTime'>
    readonly updatedAt: FieldRef<"Icon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Icon findUnique
   */
  export type IconFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * Filter, which Icon to fetch.
     */
    where: IconWhereUniqueInput
  }

  /**
   * Icon findUniqueOrThrow
   */
  export type IconFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * Filter, which Icon to fetch.
     */
    where: IconWhereUniqueInput
  }

  /**
   * Icon findFirst
   */
  export type IconFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * Filter, which Icon to fetch.
     */
    where?: IconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Icons to fetch.
     */
    orderBy?: IconOrderByWithRelationInput | IconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Icons.
     */
    cursor?: IconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Icons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Icons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Icons.
     */
    distinct?: IconScalarFieldEnum | IconScalarFieldEnum[]
  }

  /**
   * Icon findFirstOrThrow
   */
  export type IconFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * Filter, which Icon to fetch.
     */
    where?: IconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Icons to fetch.
     */
    orderBy?: IconOrderByWithRelationInput | IconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Icons.
     */
    cursor?: IconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Icons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Icons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Icons.
     */
    distinct?: IconScalarFieldEnum | IconScalarFieldEnum[]
  }

  /**
   * Icon findMany
   */
  export type IconFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * Filter, which Icons to fetch.
     */
    where?: IconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Icons to fetch.
     */
    orderBy?: IconOrderByWithRelationInput | IconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Icons.
     */
    cursor?: IconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Icons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Icons.
     */
    skip?: number
    distinct?: IconScalarFieldEnum | IconScalarFieldEnum[]
  }

  /**
   * Icon create
   */
  export type IconCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * The data needed to create a Icon.
     */
    data: XOR<IconCreateInput, IconUncheckedCreateInput>
  }

  /**
   * Icon createMany
   */
  export type IconCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Icons.
     */
    data: IconCreateManyInput | IconCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Icon createManyAndReturn
   */
  export type IconCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Icons.
     */
    data: IconCreateManyInput | IconCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Icon update
   */
  export type IconUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * The data needed to update a Icon.
     */
    data: XOR<IconUpdateInput, IconUncheckedUpdateInput>
    /**
     * Choose, which Icon to update.
     */
    where: IconWhereUniqueInput
  }

  /**
   * Icon updateMany
   */
  export type IconUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Icons.
     */
    data: XOR<IconUpdateManyMutationInput, IconUncheckedUpdateManyInput>
    /**
     * Filter which Icons to update
     */
    where?: IconWhereInput
  }

  /**
   * Icon upsert
   */
  export type IconUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * The filter to search for the Icon to update in case it exists.
     */
    where: IconWhereUniqueInput
    /**
     * In case the Icon found by the `where` argument doesn't exist, create a new Icon with this data.
     */
    create: XOR<IconCreateInput, IconUncheckedCreateInput>
    /**
     * In case the Icon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IconUpdateInput, IconUncheckedUpdateInput>
  }

  /**
   * Icon delete
   */
  export type IconDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
    /**
     * Filter which Icon to delete.
     */
    where: IconWhereUniqueInput
  }

  /**
   * Icon deleteMany
   */
  export type IconDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Icons to delete
     */
    where?: IconWhereInput
  }

  /**
   * Icon.productIcons
   */
  export type Icon$productIconsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    where?: ProductIconWhereInput
    orderBy?: ProductIconOrderByWithRelationInput | ProductIconOrderByWithRelationInput[]
    cursor?: ProductIconWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductIconScalarFieldEnum | ProductIconScalarFieldEnum[]
  }

  /**
   * Icon without action
   */
  export type IconDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Icon
     */
    select?: IconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IconInclude<ExtArgs> | null
  }


  /**
   * Model ProductIcon
   */

  export type AggregateProductIcon = {
    _count: ProductIconCountAggregateOutputType | null
    _avg: ProductIconAvgAggregateOutputType | null
    _sum: ProductIconSumAggregateOutputType | null
    _min: ProductIconMinAggregateOutputType | null
    _max: ProductIconMaxAggregateOutputType | null
  }

  export type ProductIconAvgAggregateOutputType = {
    position: number | null
  }

  export type ProductIconSumAggregateOutputType = {
    position: number | null
  }

  export type ProductIconMinAggregateOutputType = {
    id: string | null
    productId: string | null
    iconId: string | null
    position: number | null
  }

  export type ProductIconMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    iconId: string | null
    position: number | null
  }

  export type ProductIconCountAggregateOutputType = {
    id: number
    productId: number
    iconId: number
    position: number
    _all: number
  }


  export type ProductIconAvgAggregateInputType = {
    position?: true
  }

  export type ProductIconSumAggregateInputType = {
    position?: true
  }

  export type ProductIconMinAggregateInputType = {
    id?: true
    productId?: true
    iconId?: true
    position?: true
  }

  export type ProductIconMaxAggregateInputType = {
    id?: true
    productId?: true
    iconId?: true
    position?: true
  }

  export type ProductIconCountAggregateInputType = {
    id?: true
    productId?: true
    iconId?: true
    position?: true
    _all?: true
  }

  export type ProductIconAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductIcon to aggregate.
     */
    where?: ProductIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIcons to fetch.
     */
    orderBy?: ProductIconOrderByWithRelationInput | ProductIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductIcons
    **/
    _count?: true | ProductIconCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductIconAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductIconSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductIconMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductIconMaxAggregateInputType
  }

  export type GetProductIconAggregateType<T extends ProductIconAggregateArgs> = {
        [P in keyof T & keyof AggregateProductIcon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductIcon[P]>
      : GetScalarType<T[P], AggregateProductIcon[P]>
  }




  export type ProductIconGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductIconWhereInput
    orderBy?: ProductIconOrderByWithAggregationInput | ProductIconOrderByWithAggregationInput[]
    by: ProductIconScalarFieldEnum[] | ProductIconScalarFieldEnum
    having?: ProductIconScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductIconCountAggregateInputType | true
    _avg?: ProductIconAvgAggregateInputType
    _sum?: ProductIconSumAggregateInputType
    _min?: ProductIconMinAggregateInputType
    _max?: ProductIconMaxAggregateInputType
  }

  export type ProductIconGroupByOutputType = {
    id: string
    productId: string
    iconId: string
    position: number
    _count: ProductIconCountAggregateOutputType | null
    _avg: ProductIconAvgAggregateOutputType | null
    _sum: ProductIconSumAggregateOutputType | null
    _min: ProductIconMinAggregateOutputType | null
    _max: ProductIconMaxAggregateOutputType | null
  }

  type GetProductIconGroupByPayload<T extends ProductIconGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductIconGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductIconGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductIconGroupByOutputType[P]>
            : GetScalarType<T[P], ProductIconGroupByOutputType[P]>
        }
      >
    >


  export type ProductIconSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    iconId?: boolean
    position?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    icon?: boolean | IconDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productIcon"]>

  export type ProductIconSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    iconId?: boolean
    position?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    icon?: boolean | IconDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productIcon"]>

  export type ProductIconSelectScalar = {
    id?: boolean
    productId?: boolean
    iconId?: boolean
    position?: boolean
  }

  export type ProductIconInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    icon?: boolean | IconDefaultArgs<ExtArgs>
  }
  export type ProductIconIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    icon?: boolean | IconDefaultArgs<ExtArgs>
  }

  export type $ProductIconPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductIcon"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      icon: Prisma.$IconPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      iconId: string
      position: number
    }, ExtArgs["result"]["productIcon"]>
    composites: {}
  }

  type ProductIconGetPayload<S extends boolean | null | undefined | ProductIconDefaultArgs> = $Result.GetResult<Prisma.$ProductIconPayload, S>

  type ProductIconCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductIconFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductIconCountAggregateInputType | true
    }

  export interface ProductIconDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductIcon'], meta: { name: 'ProductIcon' } }
    /**
     * Find zero or one ProductIcon that matches the filter.
     * @param {ProductIconFindUniqueArgs} args - Arguments to find a ProductIcon
     * @example
     * // Get one ProductIcon
     * const productIcon = await prisma.productIcon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductIconFindUniqueArgs>(args: SelectSubset<T, ProductIconFindUniqueArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductIcon that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductIconFindUniqueOrThrowArgs} args - Arguments to find a ProductIcon
     * @example
     * // Get one ProductIcon
     * const productIcon = await prisma.productIcon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductIconFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductIconFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductIcon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconFindFirstArgs} args - Arguments to find a ProductIcon
     * @example
     * // Get one ProductIcon
     * const productIcon = await prisma.productIcon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductIconFindFirstArgs>(args?: SelectSubset<T, ProductIconFindFirstArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductIcon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconFindFirstOrThrowArgs} args - Arguments to find a ProductIcon
     * @example
     * // Get one ProductIcon
     * const productIcon = await prisma.productIcon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductIconFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductIconFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductIcons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductIcons
     * const productIcons = await prisma.productIcon.findMany()
     * 
     * // Get first 10 ProductIcons
     * const productIcons = await prisma.productIcon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productIconWithIdOnly = await prisma.productIcon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductIconFindManyArgs>(args?: SelectSubset<T, ProductIconFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductIcon.
     * @param {ProductIconCreateArgs} args - Arguments to create a ProductIcon.
     * @example
     * // Create one ProductIcon
     * const ProductIcon = await prisma.productIcon.create({
     *   data: {
     *     // ... data to create a ProductIcon
     *   }
     * })
     * 
     */
    create<T extends ProductIconCreateArgs>(args: SelectSubset<T, ProductIconCreateArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductIcons.
     * @param {ProductIconCreateManyArgs} args - Arguments to create many ProductIcons.
     * @example
     * // Create many ProductIcons
     * const productIcon = await prisma.productIcon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductIconCreateManyArgs>(args?: SelectSubset<T, ProductIconCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductIcons and returns the data saved in the database.
     * @param {ProductIconCreateManyAndReturnArgs} args - Arguments to create many ProductIcons.
     * @example
     * // Create many ProductIcons
     * const productIcon = await prisma.productIcon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductIcons and only return the `id`
     * const productIconWithIdOnly = await prisma.productIcon.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductIconCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductIconCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductIcon.
     * @param {ProductIconDeleteArgs} args - Arguments to delete one ProductIcon.
     * @example
     * // Delete one ProductIcon
     * const ProductIcon = await prisma.productIcon.delete({
     *   where: {
     *     // ... filter to delete one ProductIcon
     *   }
     * })
     * 
     */
    delete<T extends ProductIconDeleteArgs>(args: SelectSubset<T, ProductIconDeleteArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductIcon.
     * @param {ProductIconUpdateArgs} args - Arguments to update one ProductIcon.
     * @example
     * // Update one ProductIcon
     * const productIcon = await prisma.productIcon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductIconUpdateArgs>(args: SelectSubset<T, ProductIconUpdateArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductIcons.
     * @param {ProductIconDeleteManyArgs} args - Arguments to filter ProductIcons to delete.
     * @example
     * // Delete a few ProductIcons
     * const { count } = await prisma.productIcon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductIconDeleteManyArgs>(args?: SelectSubset<T, ProductIconDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductIcons
     * const productIcon = await prisma.productIcon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductIconUpdateManyArgs>(args: SelectSubset<T, ProductIconUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductIcon.
     * @param {ProductIconUpsertArgs} args - Arguments to update or create a ProductIcon.
     * @example
     * // Update or create a ProductIcon
     * const productIcon = await prisma.productIcon.upsert({
     *   create: {
     *     // ... data to create a ProductIcon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductIcon we want to update
     *   }
     * })
     */
    upsert<T extends ProductIconUpsertArgs>(args: SelectSubset<T, ProductIconUpsertArgs<ExtArgs>>): Prisma__ProductIconClient<$Result.GetResult<Prisma.$ProductIconPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductIcons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconCountArgs} args - Arguments to filter ProductIcons to count.
     * @example
     * // Count the number of ProductIcons
     * const count = await prisma.productIcon.count({
     *   where: {
     *     // ... the filter for the ProductIcons we want to count
     *   }
     * })
    **/
    count<T extends ProductIconCountArgs>(
      args?: Subset<T, ProductIconCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductIconCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductIcon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductIconAggregateArgs>(args: Subset<T, ProductIconAggregateArgs>): Prisma.PrismaPromise<GetProductIconAggregateType<T>>

    /**
     * Group by ProductIcon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductIconGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductIconGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductIconGroupByArgs['orderBy'] }
        : { orderBy?: ProductIconGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductIconGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductIconGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductIcon model
   */
  readonly fields: ProductIconFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductIcon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductIconClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    icon<T extends IconDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IconDefaultArgs<ExtArgs>>): Prisma__IconClient<$Result.GetResult<Prisma.$IconPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductIcon model
   */ 
  interface ProductIconFieldRefs {
    readonly id: FieldRef<"ProductIcon", 'String'>
    readonly productId: FieldRef<"ProductIcon", 'String'>
    readonly iconId: FieldRef<"ProductIcon", 'String'>
    readonly position: FieldRef<"ProductIcon", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductIcon findUnique
   */
  export type ProductIconFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * Filter, which ProductIcon to fetch.
     */
    where: ProductIconWhereUniqueInput
  }

  /**
   * ProductIcon findUniqueOrThrow
   */
  export type ProductIconFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * Filter, which ProductIcon to fetch.
     */
    where: ProductIconWhereUniqueInput
  }

  /**
   * ProductIcon findFirst
   */
  export type ProductIconFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * Filter, which ProductIcon to fetch.
     */
    where?: ProductIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIcons to fetch.
     */
    orderBy?: ProductIconOrderByWithRelationInput | ProductIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductIcons.
     */
    cursor?: ProductIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductIcons.
     */
    distinct?: ProductIconScalarFieldEnum | ProductIconScalarFieldEnum[]
  }

  /**
   * ProductIcon findFirstOrThrow
   */
  export type ProductIconFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * Filter, which ProductIcon to fetch.
     */
    where?: ProductIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIcons to fetch.
     */
    orderBy?: ProductIconOrderByWithRelationInput | ProductIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductIcons.
     */
    cursor?: ProductIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIcons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductIcons.
     */
    distinct?: ProductIconScalarFieldEnum | ProductIconScalarFieldEnum[]
  }

  /**
   * ProductIcon findMany
   */
  export type ProductIconFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * Filter, which ProductIcons to fetch.
     */
    where?: ProductIconWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductIcons to fetch.
     */
    orderBy?: ProductIconOrderByWithRelationInput | ProductIconOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductIcons.
     */
    cursor?: ProductIconWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductIcons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductIcons.
     */
    skip?: number
    distinct?: ProductIconScalarFieldEnum | ProductIconScalarFieldEnum[]
  }

  /**
   * ProductIcon create
   */
  export type ProductIconCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductIcon.
     */
    data: XOR<ProductIconCreateInput, ProductIconUncheckedCreateInput>
  }

  /**
   * ProductIcon createMany
   */
  export type ProductIconCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductIcons.
     */
    data: ProductIconCreateManyInput | ProductIconCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductIcon createManyAndReturn
   */
  export type ProductIconCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductIcons.
     */
    data: ProductIconCreateManyInput | ProductIconCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductIcon update
   */
  export type ProductIconUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductIcon.
     */
    data: XOR<ProductIconUpdateInput, ProductIconUncheckedUpdateInput>
    /**
     * Choose, which ProductIcon to update.
     */
    where: ProductIconWhereUniqueInput
  }

  /**
   * ProductIcon updateMany
   */
  export type ProductIconUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductIcons.
     */
    data: XOR<ProductIconUpdateManyMutationInput, ProductIconUncheckedUpdateManyInput>
    /**
     * Filter which ProductIcons to update
     */
    where?: ProductIconWhereInput
  }

  /**
   * ProductIcon upsert
   */
  export type ProductIconUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductIcon to update in case it exists.
     */
    where: ProductIconWhereUniqueInput
    /**
     * In case the ProductIcon found by the `where` argument doesn't exist, create a new ProductIcon with this data.
     */
    create: XOR<ProductIconCreateInput, ProductIconUncheckedCreateInput>
    /**
     * In case the ProductIcon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductIconUpdateInput, ProductIconUncheckedUpdateInput>
  }

  /**
   * ProductIcon delete
   */
  export type ProductIconDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
    /**
     * Filter which ProductIcon to delete.
     */
    where: ProductIconWhereUniqueInput
  }

  /**
   * ProductIcon deleteMany
   */
  export type ProductIconDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductIcons to delete
     */
    where?: ProductIconWhereInput
  }

  /**
   * ProductIcon without action
   */
  export type ProductIconDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductIcon
     */
    select?: ProductIconSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIconInclude<ExtArgs> | null
  }


  /**
   * Model PromoImage
   */

  export type AggregatePromoImage = {
    _count: PromoImageCountAggregateOutputType | null
    _min: PromoImageMinAggregateOutputType | null
    _max: PromoImageMaxAggregateOutputType | null
  }

  export type PromoImageMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    brandId: string | null
    name: string | null
    imageData: Buffer | null
    imageMimeType: string | null
    defaultSize: $Enums.PromoSlotSize | null
    createdAt: Date | null
  }

  export type PromoImageMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    brandId: string | null
    name: string | null
    imageData: Buffer | null
    imageMimeType: string | null
    defaultSize: $Enums.PromoSlotSize | null
    createdAt: Date | null
  }

  export type PromoImageCountAggregateOutputType = {
    id: number
    supplierId: number
    brandId: number
    name: number
    imageData: number
    imageMimeType: number
    defaultSize: number
    createdAt: number
    _all: number
  }


  export type PromoImageMinAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    name?: true
    imageData?: true
    imageMimeType?: true
    defaultSize?: true
    createdAt?: true
  }

  export type PromoImageMaxAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    name?: true
    imageData?: true
    imageMimeType?: true
    defaultSize?: true
    createdAt?: true
  }

  export type PromoImageCountAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    name?: true
    imageData?: true
    imageMimeType?: true
    defaultSize?: true
    createdAt?: true
    _all?: true
  }

  export type PromoImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoImage to aggregate.
     */
    where?: PromoImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoImages to fetch.
     */
    orderBy?: PromoImageOrderByWithRelationInput | PromoImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PromoImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PromoImages
    **/
    _count?: true | PromoImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PromoImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PromoImageMaxAggregateInputType
  }

  export type GetPromoImageAggregateType<T extends PromoImageAggregateArgs> = {
        [P in keyof T & keyof AggregatePromoImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePromoImage[P]>
      : GetScalarType<T[P], AggregatePromoImage[P]>
  }




  export type PromoImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PromoImageWhereInput
    orderBy?: PromoImageOrderByWithAggregationInput | PromoImageOrderByWithAggregationInput[]
    by: PromoImageScalarFieldEnum[] | PromoImageScalarFieldEnum
    having?: PromoImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PromoImageCountAggregateInputType | true
    _min?: PromoImageMinAggregateInputType
    _max?: PromoImageMaxAggregateInputType
  }

  export type PromoImageGroupByOutputType = {
    id: string
    supplierId: string
    brandId: string | null
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize: $Enums.PromoSlotSize
    createdAt: Date
    _count: PromoImageCountAggregateOutputType | null
    _min: PromoImageMinAggregateOutputType | null
    _max: PromoImageMaxAggregateOutputType | null
  }

  type GetPromoImageGroupByPayload<T extends PromoImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PromoImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PromoImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PromoImageGroupByOutputType[P]>
            : GetScalarType<T[P], PromoImageGroupByOutputType[P]>
        }
      >
    >


  export type PromoImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    name?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    defaultSize?: boolean
    createdAt?: boolean
    brand?: boolean | PromoImage$brandArgs<ExtArgs>
    flyerPageSlots?: boolean | PromoImage$flyerPageSlotsArgs<ExtArgs>
    footerPages?: boolean | PromoImage$footerPagesArgs<ExtArgs>
    _count?: boolean | PromoImageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["promoImage"]>

  export type PromoImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    name?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    defaultSize?: boolean
    createdAt?: boolean
    brand?: boolean | PromoImage$brandArgs<ExtArgs>
  }, ExtArgs["result"]["promoImage"]>

  export type PromoImageSelectScalar = {
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    name?: boolean
    imageData?: boolean
    imageMimeType?: boolean
    defaultSize?: boolean
    createdAt?: boolean
  }

  export type PromoImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | PromoImage$brandArgs<ExtArgs>
    flyerPageSlots?: boolean | PromoImage$flyerPageSlotsArgs<ExtArgs>
    footerPages?: boolean | PromoImage$footerPagesArgs<ExtArgs>
    _count?: boolean | PromoImageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PromoImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | PromoImage$brandArgs<ExtArgs>
  }

  export type $PromoImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PromoImage"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs> | null
      flyerPageSlots: Prisma.$FlyerPageSlotPayload<ExtArgs>[]
      footerPages: Prisma.$FlyerPagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      brandId: string | null
      name: string
      imageData: Buffer
      imageMimeType: string
      defaultSize: $Enums.PromoSlotSize
      createdAt: Date
    }, ExtArgs["result"]["promoImage"]>
    composites: {}
  }

  type PromoImageGetPayload<S extends boolean | null | undefined | PromoImageDefaultArgs> = $Result.GetResult<Prisma.$PromoImagePayload, S>

  type PromoImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PromoImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PromoImageCountAggregateInputType | true
    }

  export interface PromoImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PromoImage'], meta: { name: 'PromoImage' } }
    /**
     * Find zero or one PromoImage that matches the filter.
     * @param {PromoImageFindUniqueArgs} args - Arguments to find a PromoImage
     * @example
     * // Get one PromoImage
     * const promoImage = await prisma.promoImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PromoImageFindUniqueArgs>(args: SelectSubset<T, PromoImageFindUniqueArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PromoImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PromoImageFindUniqueOrThrowArgs} args - Arguments to find a PromoImage
     * @example
     * // Get one PromoImage
     * const promoImage = await prisma.promoImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PromoImageFindUniqueOrThrowArgs>(args: SelectSubset<T, PromoImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PromoImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageFindFirstArgs} args - Arguments to find a PromoImage
     * @example
     * // Get one PromoImage
     * const promoImage = await prisma.promoImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PromoImageFindFirstArgs>(args?: SelectSubset<T, PromoImageFindFirstArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PromoImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageFindFirstOrThrowArgs} args - Arguments to find a PromoImage
     * @example
     * // Get one PromoImage
     * const promoImage = await prisma.promoImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PromoImageFindFirstOrThrowArgs>(args?: SelectSubset<T, PromoImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PromoImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PromoImages
     * const promoImages = await prisma.promoImage.findMany()
     * 
     * // Get first 10 PromoImages
     * const promoImages = await prisma.promoImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const promoImageWithIdOnly = await prisma.promoImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PromoImageFindManyArgs>(args?: SelectSubset<T, PromoImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PromoImage.
     * @param {PromoImageCreateArgs} args - Arguments to create a PromoImage.
     * @example
     * // Create one PromoImage
     * const PromoImage = await prisma.promoImage.create({
     *   data: {
     *     // ... data to create a PromoImage
     *   }
     * })
     * 
     */
    create<T extends PromoImageCreateArgs>(args: SelectSubset<T, PromoImageCreateArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PromoImages.
     * @param {PromoImageCreateManyArgs} args - Arguments to create many PromoImages.
     * @example
     * // Create many PromoImages
     * const promoImage = await prisma.promoImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PromoImageCreateManyArgs>(args?: SelectSubset<T, PromoImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PromoImages and returns the data saved in the database.
     * @param {PromoImageCreateManyAndReturnArgs} args - Arguments to create many PromoImages.
     * @example
     * // Create many PromoImages
     * const promoImage = await prisma.promoImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PromoImages and only return the `id`
     * const promoImageWithIdOnly = await prisma.promoImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PromoImageCreateManyAndReturnArgs>(args?: SelectSubset<T, PromoImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PromoImage.
     * @param {PromoImageDeleteArgs} args - Arguments to delete one PromoImage.
     * @example
     * // Delete one PromoImage
     * const PromoImage = await prisma.promoImage.delete({
     *   where: {
     *     // ... filter to delete one PromoImage
     *   }
     * })
     * 
     */
    delete<T extends PromoImageDeleteArgs>(args: SelectSubset<T, PromoImageDeleteArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PromoImage.
     * @param {PromoImageUpdateArgs} args - Arguments to update one PromoImage.
     * @example
     * // Update one PromoImage
     * const promoImage = await prisma.promoImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PromoImageUpdateArgs>(args: SelectSubset<T, PromoImageUpdateArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PromoImages.
     * @param {PromoImageDeleteManyArgs} args - Arguments to filter PromoImages to delete.
     * @example
     * // Delete a few PromoImages
     * const { count } = await prisma.promoImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PromoImageDeleteManyArgs>(args?: SelectSubset<T, PromoImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PromoImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PromoImages
     * const promoImage = await prisma.promoImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PromoImageUpdateManyArgs>(args: SelectSubset<T, PromoImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PromoImage.
     * @param {PromoImageUpsertArgs} args - Arguments to update or create a PromoImage.
     * @example
     * // Update or create a PromoImage
     * const promoImage = await prisma.promoImage.upsert({
     *   create: {
     *     // ... data to create a PromoImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PromoImage we want to update
     *   }
     * })
     */
    upsert<T extends PromoImageUpsertArgs>(args: SelectSubset<T, PromoImageUpsertArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PromoImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageCountArgs} args - Arguments to filter PromoImages to count.
     * @example
     * // Count the number of PromoImages
     * const count = await prisma.promoImage.count({
     *   where: {
     *     // ... the filter for the PromoImages we want to count
     *   }
     * })
    **/
    count<T extends PromoImageCountArgs>(
      args?: Subset<T, PromoImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PromoImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PromoImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PromoImageAggregateArgs>(args: Subset<T, PromoImageAggregateArgs>): Prisma.PrismaPromise<GetPromoImageAggregateType<T>>

    /**
     * Group by PromoImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PromoImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PromoImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PromoImageGroupByArgs['orderBy'] }
        : { orderBy?: PromoImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PromoImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPromoImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PromoImage model
   */
  readonly fields: PromoImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PromoImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PromoImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends PromoImage$brandArgs<ExtArgs> = {}>(args?: Subset<T, PromoImage$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    flyerPageSlots<T extends PromoImage$flyerPageSlotsArgs<ExtArgs> = {}>(args?: Subset<T, PromoImage$flyerPageSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findMany"> | Null>
    footerPages<T extends PromoImage$footerPagesArgs<ExtArgs> = {}>(args?: Subset<T, PromoImage$footerPagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PromoImage model
   */ 
  interface PromoImageFieldRefs {
    readonly id: FieldRef<"PromoImage", 'String'>
    readonly supplierId: FieldRef<"PromoImage", 'String'>
    readonly brandId: FieldRef<"PromoImage", 'String'>
    readonly name: FieldRef<"PromoImage", 'String'>
    readonly imageData: FieldRef<"PromoImage", 'Bytes'>
    readonly imageMimeType: FieldRef<"PromoImage", 'String'>
    readonly defaultSize: FieldRef<"PromoImage", 'PromoSlotSize'>
    readonly createdAt: FieldRef<"PromoImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PromoImage findUnique
   */
  export type PromoImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * Filter, which PromoImage to fetch.
     */
    where: PromoImageWhereUniqueInput
  }

  /**
   * PromoImage findUniqueOrThrow
   */
  export type PromoImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * Filter, which PromoImage to fetch.
     */
    where: PromoImageWhereUniqueInput
  }

  /**
   * PromoImage findFirst
   */
  export type PromoImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * Filter, which PromoImage to fetch.
     */
    where?: PromoImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoImages to fetch.
     */
    orderBy?: PromoImageOrderByWithRelationInput | PromoImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoImages.
     */
    cursor?: PromoImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoImages.
     */
    distinct?: PromoImageScalarFieldEnum | PromoImageScalarFieldEnum[]
  }

  /**
   * PromoImage findFirstOrThrow
   */
  export type PromoImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * Filter, which PromoImage to fetch.
     */
    where?: PromoImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoImages to fetch.
     */
    orderBy?: PromoImageOrderByWithRelationInput | PromoImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PromoImages.
     */
    cursor?: PromoImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PromoImages.
     */
    distinct?: PromoImageScalarFieldEnum | PromoImageScalarFieldEnum[]
  }

  /**
   * PromoImage findMany
   */
  export type PromoImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * Filter, which PromoImages to fetch.
     */
    where?: PromoImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PromoImages to fetch.
     */
    orderBy?: PromoImageOrderByWithRelationInput | PromoImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PromoImages.
     */
    cursor?: PromoImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PromoImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PromoImages.
     */
    skip?: number
    distinct?: PromoImageScalarFieldEnum | PromoImageScalarFieldEnum[]
  }

  /**
   * PromoImage create
   */
  export type PromoImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * The data needed to create a PromoImage.
     */
    data: XOR<PromoImageCreateInput, PromoImageUncheckedCreateInput>
  }

  /**
   * PromoImage createMany
   */
  export type PromoImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PromoImages.
     */
    data: PromoImageCreateManyInput | PromoImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PromoImage createManyAndReturn
   */
  export type PromoImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PromoImages.
     */
    data: PromoImageCreateManyInput | PromoImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PromoImage update
   */
  export type PromoImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * The data needed to update a PromoImage.
     */
    data: XOR<PromoImageUpdateInput, PromoImageUncheckedUpdateInput>
    /**
     * Choose, which PromoImage to update.
     */
    where: PromoImageWhereUniqueInput
  }

  /**
   * PromoImage updateMany
   */
  export type PromoImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PromoImages.
     */
    data: XOR<PromoImageUpdateManyMutationInput, PromoImageUncheckedUpdateManyInput>
    /**
     * Filter which PromoImages to update
     */
    where?: PromoImageWhereInput
  }

  /**
   * PromoImage upsert
   */
  export type PromoImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * The filter to search for the PromoImage to update in case it exists.
     */
    where: PromoImageWhereUniqueInput
    /**
     * In case the PromoImage found by the `where` argument doesn't exist, create a new PromoImage with this data.
     */
    create: XOR<PromoImageCreateInput, PromoImageUncheckedCreateInput>
    /**
     * In case the PromoImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PromoImageUpdateInput, PromoImageUncheckedUpdateInput>
  }

  /**
   * PromoImage delete
   */
  export type PromoImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    /**
     * Filter which PromoImage to delete.
     */
    where: PromoImageWhereUniqueInput
  }

  /**
   * PromoImage deleteMany
   */
  export type PromoImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PromoImages to delete
     */
    where?: PromoImageWhereInput
  }

  /**
   * PromoImage.brand
   */
  export type PromoImage$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * PromoImage.flyerPageSlots
   */
  export type PromoImage$flyerPageSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    where?: FlyerPageSlotWhereInput
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    cursor?: FlyerPageSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * PromoImage.footerPages
   */
  export type PromoImage$footerPagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    where?: FlyerPageWhereInput
    orderBy?: FlyerPageOrderByWithRelationInput | FlyerPageOrderByWithRelationInput[]
    cursor?: FlyerPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerPageScalarFieldEnum | FlyerPageScalarFieldEnum[]
  }

  /**
   * PromoImage without action
   */
  export type PromoImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
  }


  /**
   * Model Flyer
   */

  export type AggregateFlyer = {
    _count: FlyerCountAggregateOutputType | null
    _avg: FlyerAvgAggregateOutputType | null
    _sum: FlyerSumAggregateOutputType | null
    _min: FlyerMinAggregateOutputType | null
    _max: FlyerMaxAggregateOutputType | null
  }

  export type FlyerAvgAggregateOutputType = {
    autoSaveVersion: number | null
    completionPercentage: number | null
  }

  export type FlyerSumAggregateOutputType = {
    autoSaveVersion: number | null
    completionPercentage: number | null
  }

  export type FlyerMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    name: string | null
    validFrom: Date | null
    validTo: Date | null
    status: $Enums.FlyerStatus | null
    isDraft: boolean | null
    rejectionReason: string | null
    pdfData: Buffer | null
    pdfMimeType: string | null
    lastEditedAt: Date | null
    autoSaveVersion: number | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type FlyerMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    name: string | null
    validFrom: Date | null
    validTo: Date | null
    status: $Enums.FlyerStatus | null
    isDraft: boolean | null
    rejectionReason: string | null
    pdfData: Buffer | null
    pdfMimeType: string | null
    lastEditedAt: Date | null
    autoSaveVersion: number | null
    completionPercentage: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
  }

  export type FlyerCountAggregateOutputType = {
    id: number
    supplierId: number
    name: number
    validFrom: number
    validTo: number
    status: number
    isDraft: number
    rejectionReason: number
    pdfData: number
    pdfMimeType: number
    lastEditedAt: number
    autoSaveVersion: number
    completionPercentage: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    _all: number
  }


  export type FlyerAvgAggregateInputType = {
    autoSaveVersion?: true
    completionPercentage?: true
  }

  export type FlyerSumAggregateInputType = {
    autoSaveVersion?: true
    completionPercentage?: true
  }

  export type FlyerMinAggregateInputType = {
    id?: true
    supplierId?: true
    name?: true
    validFrom?: true
    validTo?: true
    status?: true
    isDraft?: true
    rejectionReason?: true
    pdfData?: true
    pdfMimeType?: true
    lastEditedAt?: true
    autoSaveVersion?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type FlyerMaxAggregateInputType = {
    id?: true
    supplierId?: true
    name?: true
    validFrom?: true
    validTo?: true
    status?: true
    isDraft?: true
    rejectionReason?: true
    pdfData?: true
    pdfMimeType?: true
    lastEditedAt?: true
    autoSaveVersion?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
  }

  export type FlyerCountAggregateInputType = {
    id?: true
    supplierId?: true
    name?: true
    validFrom?: true
    validTo?: true
    status?: true
    isDraft?: true
    rejectionReason?: true
    pdfData?: true
    pdfMimeType?: true
    lastEditedAt?: true
    autoSaveVersion?: true
    completionPercentage?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    _all?: true
  }

  export type FlyerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flyer to aggregate.
     */
    where?: FlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flyers to fetch.
     */
    orderBy?: FlyerOrderByWithRelationInput | FlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flyers
    **/
    _count?: true | FlyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlyerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlyerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlyerMaxAggregateInputType
  }

  export type GetFlyerAggregateType<T extends FlyerAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyer[P]>
      : GetScalarType<T[P], AggregateFlyer[P]>
  }




  export type FlyerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerWhereInput
    orderBy?: FlyerOrderByWithAggregationInput | FlyerOrderByWithAggregationInput[]
    by: FlyerScalarFieldEnum[] | FlyerScalarFieldEnum
    having?: FlyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlyerCountAggregateInputType | true
    _avg?: FlyerAvgAggregateInputType
    _sum?: FlyerSumAggregateInputType
    _min?: FlyerMinAggregateInputType
    _max?: FlyerMaxAggregateInputType
  }

  export type FlyerGroupByOutputType = {
    id: string
    supplierId: string
    name: string
    validFrom: Date | null
    validTo: Date | null
    status: $Enums.FlyerStatus
    isDraft: boolean
    rejectionReason: string | null
    pdfData: Buffer | null
    pdfMimeType: string | null
    lastEditedAt: Date
    autoSaveVersion: number
    completionPercentage: number
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    _count: FlyerCountAggregateOutputType | null
    _avg: FlyerAvgAggregateOutputType | null
    _sum: FlyerSumAggregateOutputType | null
    _min: FlyerMinAggregateOutputType | null
    _max: FlyerMaxAggregateOutputType | null
  }

  type GetFlyerGroupByPayload<T extends FlyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlyerGroupByOutputType[P]>
            : GetScalarType<T[P], FlyerGroupByOutputType[P]>
        }
      >
    >


  export type FlyerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    name?: boolean
    validFrom?: boolean
    validTo?: boolean
    status?: boolean
    isDraft?: boolean
    rejectionReason?: boolean
    pdfData?: boolean
    pdfMimeType?: boolean
    lastEditedAt?: boolean
    autoSaveVersion?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    supplier?: boolean | UserDefaultArgs<ExtArgs>
    pages?: boolean | Flyer$pagesArgs<ExtArgs>
    verificationLogs?: boolean | Flyer$verificationLogsArgs<ExtArgs>
    approvals?: boolean | Flyer$approvalsArgs<ExtArgs>
    approvalWorkflow?: boolean | Flyer$approvalWorkflowArgs<ExtArgs>
    versions?: boolean | Flyer$versionsArgs<ExtArgs>
    editHistory?: boolean | Flyer$editHistoryArgs<ExtArgs>
    _count?: boolean | FlyerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyer"]>

  export type FlyerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    name?: boolean
    validFrom?: boolean
    validTo?: boolean
    status?: boolean
    isDraft?: boolean
    rejectionReason?: boolean
    pdfData?: boolean
    pdfMimeType?: boolean
    lastEditedAt?: boolean
    autoSaveVersion?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    supplier?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyer"]>

  export type FlyerSelectScalar = {
    id?: boolean
    supplierId?: boolean
    name?: boolean
    validFrom?: boolean
    validTo?: boolean
    status?: boolean
    isDraft?: boolean
    rejectionReason?: boolean
    pdfData?: boolean
    pdfMimeType?: boolean
    lastEditedAt?: boolean
    autoSaveVersion?: boolean
    completionPercentage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
  }

  export type FlyerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | UserDefaultArgs<ExtArgs>
    pages?: boolean | Flyer$pagesArgs<ExtArgs>
    verificationLogs?: boolean | Flyer$verificationLogsArgs<ExtArgs>
    approvals?: boolean | Flyer$approvalsArgs<ExtArgs>
    approvalWorkflow?: boolean | Flyer$approvalWorkflowArgs<ExtArgs>
    versions?: boolean | Flyer$versionsArgs<ExtArgs>
    editHistory?: boolean | Flyer$editHistoryArgs<ExtArgs>
    _count?: boolean | FlyerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlyerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlyerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flyer"
    objects: {
      supplier: Prisma.$UserPayload<ExtArgs>
      pages: Prisma.$FlyerPagePayload<ExtArgs>[]
      verificationLogs: Prisma.$VerificationLogPayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
      approvalWorkflow: Prisma.$ApprovalWorkflowPayload<ExtArgs> | null
      versions: Prisma.$FlyerVersionPayload<ExtArgs>[]
      editHistory: Prisma.$FlyerEditHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string
      name: string
      validFrom: Date | null
      validTo: Date | null
      status: $Enums.FlyerStatus
      isDraft: boolean
      rejectionReason: string | null
      pdfData: Buffer | null
      pdfMimeType: string | null
      lastEditedAt: Date
      autoSaveVersion: number
      completionPercentage: number
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
    }, ExtArgs["result"]["flyer"]>
    composites: {}
  }

  type FlyerGetPayload<S extends boolean | null | undefined | FlyerDefaultArgs> = $Result.GetResult<Prisma.$FlyerPayload, S>

  type FlyerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlyerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlyerCountAggregateInputType | true
    }

  export interface FlyerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flyer'], meta: { name: 'Flyer' } }
    /**
     * Find zero or one Flyer that matches the filter.
     * @param {FlyerFindUniqueArgs} args - Arguments to find a Flyer
     * @example
     * // Get one Flyer
     * const flyer = await prisma.flyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlyerFindUniqueArgs>(args: SelectSubset<T, FlyerFindUniqueArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Flyer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlyerFindUniqueOrThrowArgs} args - Arguments to find a Flyer
     * @example
     * // Get one Flyer
     * const flyer = await prisma.flyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlyerFindUniqueOrThrowArgs>(args: SelectSubset<T, FlyerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Flyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerFindFirstArgs} args - Arguments to find a Flyer
     * @example
     * // Get one Flyer
     * const flyer = await prisma.flyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlyerFindFirstArgs>(args?: SelectSubset<T, FlyerFindFirstArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Flyer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerFindFirstOrThrowArgs} args - Arguments to find a Flyer
     * @example
     * // Get one Flyer
     * const flyer = await prisma.flyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlyerFindFirstOrThrowArgs>(args?: SelectSubset<T, FlyerFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Flyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flyers
     * const flyers = await prisma.flyer.findMany()
     * 
     * // Get first 10 Flyers
     * const flyers = await prisma.flyer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flyerWithIdOnly = await prisma.flyer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlyerFindManyArgs>(args?: SelectSubset<T, FlyerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Flyer.
     * @param {FlyerCreateArgs} args - Arguments to create a Flyer.
     * @example
     * // Create one Flyer
     * const Flyer = await prisma.flyer.create({
     *   data: {
     *     // ... data to create a Flyer
     *   }
     * })
     * 
     */
    create<T extends FlyerCreateArgs>(args: SelectSubset<T, FlyerCreateArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Flyers.
     * @param {FlyerCreateManyArgs} args - Arguments to create many Flyers.
     * @example
     * // Create many Flyers
     * const flyer = await prisma.flyer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlyerCreateManyArgs>(args?: SelectSubset<T, FlyerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flyers and returns the data saved in the database.
     * @param {FlyerCreateManyAndReturnArgs} args - Arguments to create many Flyers.
     * @example
     * // Create many Flyers
     * const flyer = await prisma.flyer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flyers and only return the `id`
     * const flyerWithIdOnly = await prisma.flyer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlyerCreateManyAndReturnArgs>(args?: SelectSubset<T, FlyerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Flyer.
     * @param {FlyerDeleteArgs} args - Arguments to delete one Flyer.
     * @example
     * // Delete one Flyer
     * const Flyer = await prisma.flyer.delete({
     *   where: {
     *     // ... filter to delete one Flyer
     *   }
     * })
     * 
     */
    delete<T extends FlyerDeleteArgs>(args: SelectSubset<T, FlyerDeleteArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Flyer.
     * @param {FlyerUpdateArgs} args - Arguments to update one Flyer.
     * @example
     * // Update one Flyer
     * const flyer = await prisma.flyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlyerUpdateArgs>(args: SelectSubset<T, FlyerUpdateArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Flyers.
     * @param {FlyerDeleteManyArgs} args - Arguments to filter Flyers to delete.
     * @example
     * // Delete a few Flyers
     * const { count } = await prisma.flyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlyerDeleteManyArgs>(args?: SelectSubset<T, FlyerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flyers
     * const flyer = await prisma.flyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlyerUpdateManyArgs>(args: SelectSubset<T, FlyerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flyer.
     * @param {FlyerUpsertArgs} args - Arguments to update or create a Flyer.
     * @example
     * // Update or create a Flyer
     * const flyer = await prisma.flyer.upsert({
     *   create: {
     *     // ... data to create a Flyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flyer we want to update
     *   }
     * })
     */
    upsert<T extends FlyerUpsertArgs>(args: SelectSubset<T, FlyerUpsertArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Flyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerCountArgs} args - Arguments to filter Flyers to count.
     * @example
     * // Count the number of Flyers
     * const count = await prisma.flyer.count({
     *   where: {
     *     // ... the filter for the Flyers we want to count
     *   }
     * })
    **/
    count<T extends FlyerCountArgs>(
      args?: Subset<T, FlyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlyerAggregateArgs>(args: Subset<T, FlyerAggregateArgs>): Prisma.PrismaPromise<GetFlyerAggregateType<T>>

    /**
     * Group by Flyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlyerGroupByArgs['orderBy'] }
        : { orderBy?: FlyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flyer model
   */
  readonly fields: FlyerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlyerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pages<T extends Flyer$pagesArgs<ExtArgs> = {}>(args?: Subset<T, Flyer$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findMany"> | Null>
    verificationLogs<T extends Flyer$verificationLogsArgs<ExtArgs> = {}>(args?: Subset<T, Flyer$verificationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "findMany"> | Null>
    approvals<T extends Flyer$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Flyer$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany"> | Null>
    approvalWorkflow<T extends Flyer$approvalWorkflowArgs<ExtArgs> = {}>(args?: Subset<T, Flyer$approvalWorkflowArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    versions<T extends Flyer$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Flyer$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "findMany"> | Null>
    editHistory<T extends Flyer$editHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Flyer$editHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flyer model
   */ 
  interface FlyerFieldRefs {
    readonly id: FieldRef<"Flyer", 'String'>
    readonly supplierId: FieldRef<"Flyer", 'String'>
    readonly name: FieldRef<"Flyer", 'String'>
    readonly validFrom: FieldRef<"Flyer", 'DateTime'>
    readonly validTo: FieldRef<"Flyer", 'DateTime'>
    readonly status: FieldRef<"Flyer", 'FlyerStatus'>
    readonly isDraft: FieldRef<"Flyer", 'Boolean'>
    readonly rejectionReason: FieldRef<"Flyer", 'String'>
    readonly pdfData: FieldRef<"Flyer", 'Bytes'>
    readonly pdfMimeType: FieldRef<"Flyer", 'String'>
    readonly lastEditedAt: FieldRef<"Flyer", 'DateTime'>
    readonly autoSaveVersion: FieldRef<"Flyer", 'Int'>
    readonly completionPercentage: FieldRef<"Flyer", 'Int'>
    readonly createdAt: FieldRef<"Flyer", 'DateTime'>
    readonly updatedAt: FieldRef<"Flyer", 'DateTime'>
    readonly publishedAt: FieldRef<"Flyer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flyer findUnique
   */
  export type FlyerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * Filter, which Flyer to fetch.
     */
    where: FlyerWhereUniqueInput
  }

  /**
   * Flyer findUniqueOrThrow
   */
  export type FlyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * Filter, which Flyer to fetch.
     */
    where: FlyerWhereUniqueInput
  }

  /**
   * Flyer findFirst
   */
  export type FlyerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * Filter, which Flyer to fetch.
     */
    where?: FlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flyers to fetch.
     */
    orderBy?: FlyerOrderByWithRelationInput | FlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flyers.
     */
    cursor?: FlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flyers.
     */
    distinct?: FlyerScalarFieldEnum | FlyerScalarFieldEnum[]
  }

  /**
   * Flyer findFirstOrThrow
   */
  export type FlyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * Filter, which Flyer to fetch.
     */
    where?: FlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flyers to fetch.
     */
    orderBy?: FlyerOrderByWithRelationInput | FlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flyers.
     */
    cursor?: FlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flyers.
     */
    distinct?: FlyerScalarFieldEnum | FlyerScalarFieldEnum[]
  }

  /**
   * Flyer findMany
   */
  export type FlyerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * Filter, which Flyers to fetch.
     */
    where?: FlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flyers to fetch.
     */
    orderBy?: FlyerOrderByWithRelationInput | FlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flyers.
     */
    cursor?: FlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flyers.
     */
    skip?: number
    distinct?: FlyerScalarFieldEnum | FlyerScalarFieldEnum[]
  }

  /**
   * Flyer create
   */
  export type FlyerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * The data needed to create a Flyer.
     */
    data: XOR<FlyerCreateInput, FlyerUncheckedCreateInput>
  }

  /**
   * Flyer createMany
   */
  export type FlyerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flyers.
     */
    data: FlyerCreateManyInput | FlyerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flyer createManyAndReturn
   */
  export type FlyerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Flyers.
     */
    data: FlyerCreateManyInput | FlyerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flyer update
   */
  export type FlyerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * The data needed to update a Flyer.
     */
    data: XOR<FlyerUpdateInput, FlyerUncheckedUpdateInput>
    /**
     * Choose, which Flyer to update.
     */
    where: FlyerWhereUniqueInput
  }

  /**
   * Flyer updateMany
   */
  export type FlyerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flyers.
     */
    data: XOR<FlyerUpdateManyMutationInput, FlyerUncheckedUpdateManyInput>
    /**
     * Filter which Flyers to update
     */
    where?: FlyerWhereInput
  }

  /**
   * Flyer upsert
   */
  export type FlyerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * The filter to search for the Flyer to update in case it exists.
     */
    where: FlyerWhereUniqueInput
    /**
     * In case the Flyer found by the `where` argument doesn't exist, create a new Flyer with this data.
     */
    create: XOR<FlyerCreateInput, FlyerUncheckedCreateInput>
    /**
     * In case the Flyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlyerUpdateInput, FlyerUncheckedUpdateInput>
  }

  /**
   * Flyer delete
   */
  export type FlyerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
    /**
     * Filter which Flyer to delete.
     */
    where: FlyerWhereUniqueInput
  }

  /**
   * Flyer deleteMany
   */
  export type FlyerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flyers to delete
     */
    where?: FlyerWhereInput
  }

  /**
   * Flyer.pages
   */
  export type Flyer$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    where?: FlyerPageWhereInput
    orderBy?: FlyerPageOrderByWithRelationInput | FlyerPageOrderByWithRelationInput[]
    cursor?: FlyerPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerPageScalarFieldEnum | FlyerPageScalarFieldEnum[]
  }

  /**
   * Flyer.verificationLogs
   */
  export type Flyer$verificationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    where?: VerificationLogWhereInput
    orderBy?: VerificationLogOrderByWithRelationInput | VerificationLogOrderByWithRelationInput[]
    cursor?: VerificationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationLogScalarFieldEnum | VerificationLogScalarFieldEnum[]
  }

  /**
   * Flyer.approvals
   */
  export type Flyer$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Flyer.approvalWorkflow
   */
  export type Flyer$approvalWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    where?: ApprovalWorkflowWhereInput
  }

  /**
   * Flyer.versions
   */
  export type Flyer$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    where?: FlyerVersionWhereInput
    orderBy?: FlyerVersionOrderByWithRelationInput | FlyerVersionOrderByWithRelationInput[]
    cursor?: FlyerVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerVersionScalarFieldEnum | FlyerVersionScalarFieldEnum[]
  }

  /**
   * Flyer.editHistory
   */
  export type Flyer$editHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    where?: FlyerEditHistoryWhereInput
    orderBy?: FlyerEditHistoryOrderByWithRelationInput | FlyerEditHistoryOrderByWithRelationInput[]
    cursor?: FlyerEditHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerEditHistoryScalarFieldEnum | FlyerEditHistoryScalarFieldEnum[]
  }

  /**
   * Flyer without action
   */
  export type FlyerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flyer
     */
    select?: FlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerInclude<ExtArgs> | null
  }


  /**
   * Model FlyerPage
   */

  export type AggregateFlyerPage = {
    _count: FlyerPageCountAggregateOutputType | null
    _avg: FlyerPageAvgAggregateOutputType | null
    _sum: FlyerPageSumAggregateOutputType | null
    _min: FlyerPageMinAggregateOutputType | null
    _max: FlyerPageMaxAggregateOutputType | null
  }

  export type FlyerPageAvgAggregateOutputType = {
    pageNumber: number | null
  }

  export type FlyerPageSumAggregateOutputType = {
    pageNumber: number | null
  }

  export type FlyerPageMinAggregateOutputType = {
    id: string | null
    flyerId: string | null
    pageNumber: number | null
    footerPromoImageId: string | null
  }

  export type FlyerPageMaxAggregateOutputType = {
    id: string | null
    flyerId: string | null
    pageNumber: number | null
    footerPromoImageId: string | null
  }

  export type FlyerPageCountAggregateOutputType = {
    id: number
    flyerId: number
    pageNumber: number
    footerPromoImageId: number
    _all: number
  }


  export type FlyerPageAvgAggregateInputType = {
    pageNumber?: true
  }

  export type FlyerPageSumAggregateInputType = {
    pageNumber?: true
  }

  export type FlyerPageMinAggregateInputType = {
    id?: true
    flyerId?: true
    pageNumber?: true
    footerPromoImageId?: true
  }

  export type FlyerPageMaxAggregateInputType = {
    id?: true
    flyerId?: true
    pageNumber?: true
    footerPromoImageId?: true
  }

  export type FlyerPageCountAggregateInputType = {
    id?: true
    flyerId?: true
    pageNumber?: true
    footerPromoImageId?: true
    _all?: true
  }

  export type FlyerPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerPage to aggregate.
     */
    where?: FlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPages to fetch.
     */
    orderBy?: FlyerPageOrderByWithRelationInput | FlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlyerPages
    **/
    _count?: true | FlyerPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlyerPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlyerPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlyerPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlyerPageMaxAggregateInputType
  }

  export type GetFlyerPageAggregateType<T extends FlyerPageAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyerPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyerPage[P]>
      : GetScalarType<T[P], AggregateFlyerPage[P]>
  }




  export type FlyerPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageWhereInput
    orderBy?: FlyerPageOrderByWithAggregationInput | FlyerPageOrderByWithAggregationInput[]
    by: FlyerPageScalarFieldEnum[] | FlyerPageScalarFieldEnum
    having?: FlyerPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlyerPageCountAggregateInputType | true
    _avg?: FlyerPageAvgAggregateInputType
    _sum?: FlyerPageSumAggregateInputType
    _min?: FlyerPageMinAggregateInputType
    _max?: FlyerPageMaxAggregateInputType
  }

  export type FlyerPageGroupByOutputType = {
    id: string
    flyerId: string
    pageNumber: number
    footerPromoImageId: string | null
    _count: FlyerPageCountAggregateOutputType | null
    _avg: FlyerPageAvgAggregateOutputType | null
    _sum: FlyerPageSumAggregateOutputType | null
    _min: FlyerPageMinAggregateOutputType | null
    _max: FlyerPageMaxAggregateOutputType | null
  }

  type GetFlyerPageGroupByPayload<T extends FlyerPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlyerPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlyerPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlyerPageGroupByOutputType[P]>
            : GetScalarType<T[P], FlyerPageGroupByOutputType[P]>
        }
      >
    >


  export type FlyerPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    pageNumber?: boolean
    footerPromoImageId?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    slots?: boolean | FlyerPage$slotsArgs<ExtArgs>
    footerPromoImage?: boolean | FlyerPage$footerPromoImageArgs<ExtArgs>
    _count?: boolean | FlyerPageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyerPage"]>

  export type FlyerPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    pageNumber?: boolean
    footerPromoImageId?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    footerPromoImage?: boolean | FlyerPage$footerPromoImageArgs<ExtArgs>
  }, ExtArgs["result"]["flyerPage"]>

  export type FlyerPageSelectScalar = {
    id?: boolean
    flyerId?: boolean
    pageNumber?: boolean
    footerPromoImageId?: boolean
  }

  export type FlyerPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    slots?: boolean | FlyerPage$slotsArgs<ExtArgs>
    footerPromoImage?: boolean | FlyerPage$footerPromoImageArgs<ExtArgs>
    _count?: boolean | FlyerPageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlyerPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    footerPromoImage?: boolean | FlyerPage$footerPromoImageArgs<ExtArgs>
  }

  export type $FlyerPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlyerPage"
    objects: {
      flyer: Prisma.$FlyerPayload<ExtArgs>
      slots: Prisma.$FlyerPageSlotPayload<ExtArgs>[]
      footerPromoImage: Prisma.$PromoImagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flyerId: string
      pageNumber: number
      footerPromoImageId: string | null
    }, ExtArgs["result"]["flyerPage"]>
    composites: {}
  }

  type FlyerPageGetPayload<S extends boolean | null | undefined | FlyerPageDefaultArgs> = $Result.GetResult<Prisma.$FlyerPagePayload, S>

  type FlyerPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlyerPageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlyerPageCountAggregateInputType | true
    }

  export interface FlyerPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlyerPage'], meta: { name: 'FlyerPage' } }
    /**
     * Find zero or one FlyerPage that matches the filter.
     * @param {FlyerPageFindUniqueArgs} args - Arguments to find a FlyerPage
     * @example
     * // Get one FlyerPage
     * const flyerPage = await prisma.flyerPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlyerPageFindUniqueArgs>(args: SelectSubset<T, FlyerPageFindUniqueArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlyerPage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlyerPageFindUniqueOrThrowArgs} args - Arguments to find a FlyerPage
     * @example
     * // Get one FlyerPage
     * const flyerPage = await prisma.flyerPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlyerPageFindUniqueOrThrowArgs>(args: SelectSubset<T, FlyerPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlyerPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageFindFirstArgs} args - Arguments to find a FlyerPage
     * @example
     * // Get one FlyerPage
     * const flyerPage = await prisma.flyerPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlyerPageFindFirstArgs>(args?: SelectSubset<T, FlyerPageFindFirstArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlyerPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageFindFirstOrThrowArgs} args - Arguments to find a FlyerPage
     * @example
     * // Get one FlyerPage
     * const flyerPage = await prisma.flyerPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlyerPageFindFirstOrThrowArgs>(args?: SelectSubset<T, FlyerPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlyerPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlyerPages
     * const flyerPages = await prisma.flyerPage.findMany()
     * 
     * // Get first 10 FlyerPages
     * const flyerPages = await prisma.flyerPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flyerPageWithIdOnly = await prisma.flyerPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlyerPageFindManyArgs>(args?: SelectSubset<T, FlyerPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlyerPage.
     * @param {FlyerPageCreateArgs} args - Arguments to create a FlyerPage.
     * @example
     * // Create one FlyerPage
     * const FlyerPage = await prisma.flyerPage.create({
     *   data: {
     *     // ... data to create a FlyerPage
     *   }
     * })
     * 
     */
    create<T extends FlyerPageCreateArgs>(args: SelectSubset<T, FlyerPageCreateArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlyerPages.
     * @param {FlyerPageCreateManyArgs} args - Arguments to create many FlyerPages.
     * @example
     * // Create many FlyerPages
     * const flyerPage = await prisma.flyerPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlyerPageCreateManyArgs>(args?: SelectSubset<T, FlyerPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlyerPages and returns the data saved in the database.
     * @param {FlyerPageCreateManyAndReturnArgs} args - Arguments to create many FlyerPages.
     * @example
     * // Create many FlyerPages
     * const flyerPage = await prisma.flyerPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlyerPages and only return the `id`
     * const flyerPageWithIdOnly = await prisma.flyerPage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlyerPageCreateManyAndReturnArgs>(args?: SelectSubset<T, FlyerPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlyerPage.
     * @param {FlyerPageDeleteArgs} args - Arguments to delete one FlyerPage.
     * @example
     * // Delete one FlyerPage
     * const FlyerPage = await prisma.flyerPage.delete({
     *   where: {
     *     // ... filter to delete one FlyerPage
     *   }
     * })
     * 
     */
    delete<T extends FlyerPageDeleteArgs>(args: SelectSubset<T, FlyerPageDeleteArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlyerPage.
     * @param {FlyerPageUpdateArgs} args - Arguments to update one FlyerPage.
     * @example
     * // Update one FlyerPage
     * const flyerPage = await prisma.flyerPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlyerPageUpdateArgs>(args: SelectSubset<T, FlyerPageUpdateArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlyerPages.
     * @param {FlyerPageDeleteManyArgs} args - Arguments to filter FlyerPages to delete.
     * @example
     * // Delete a few FlyerPages
     * const { count } = await prisma.flyerPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlyerPageDeleteManyArgs>(args?: SelectSubset<T, FlyerPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlyerPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlyerPages
     * const flyerPage = await prisma.flyerPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlyerPageUpdateManyArgs>(args: SelectSubset<T, FlyerPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlyerPage.
     * @param {FlyerPageUpsertArgs} args - Arguments to update or create a FlyerPage.
     * @example
     * // Update or create a FlyerPage
     * const flyerPage = await prisma.flyerPage.upsert({
     *   create: {
     *     // ... data to create a FlyerPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlyerPage we want to update
     *   }
     * })
     */
    upsert<T extends FlyerPageUpsertArgs>(args: SelectSubset<T, FlyerPageUpsertArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlyerPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageCountArgs} args - Arguments to filter FlyerPages to count.
     * @example
     * // Count the number of FlyerPages
     * const count = await prisma.flyerPage.count({
     *   where: {
     *     // ... the filter for the FlyerPages we want to count
     *   }
     * })
    **/
    count<T extends FlyerPageCountArgs>(
      args?: Subset<T, FlyerPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlyerPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlyerPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlyerPageAggregateArgs>(args: Subset<T, FlyerPageAggregateArgs>): Prisma.PrismaPromise<GetFlyerPageAggregateType<T>>

    /**
     * Group by FlyerPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlyerPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlyerPageGroupByArgs['orderBy'] }
        : { orderBy?: FlyerPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlyerPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyerPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlyerPage model
   */
  readonly fields: FlyerPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlyerPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlyerPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flyer<T extends FlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerDefaultArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    slots<T extends FlyerPage$slotsArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPage$slotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findMany"> | Null>
    footerPromoImage<T extends FlyerPage$footerPromoImageArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPage$footerPromoImageArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlyerPage model
   */ 
  interface FlyerPageFieldRefs {
    readonly id: FieldRef<"FlyerPage", 'String'>
    readonly flyerId: FieldRef<"FlyerPage", 'String'>
    readonly pageNumber: FieldRef<"FlyerPage", 'Int'>
    readonly footerPromoImageId: FieldRef<"FlyerPage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FlyerPage findUnique
   */
  export type FlyerPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPage to fetch.
     */
    where: FlyerPageWhereUniqueInput
  }

  /**
   * FlyerPage findUniqueOrThrow
   */
  export type FlyerPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPage to fetch.
     */
    where: FlyerPageWhereUniqueInput
  }

  /**
   * FlyerPage findFirst
   */
  export type FlyerPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPage to fetch.
     */
    where?: FlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPages to fetch.
     */
    orderBy?: FlyerPageOrderByWithRelationInput | FlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerPages.
     */
    cursor?: FlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerPages.
     */
    distinct?: FlyerPageScalarFieldEnum | FlyerPageScalarFieldEnum[]
  }

  /**
   * FlyerPage findFirstOrThrow
   */
  export type FlyerPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPage to fetch.
     */
    where?: FlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPages to fetch.
     */
    orderBy?: FlyerPageOrderByWithRelationInput | FlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerPages.
     */
    cursor?: FlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerPages.
     */
    distinct?: FlyerPageScalarFieldEnum | FlyerPageScalarFieldEnum[]
  }

  /**
   * FlyerPage findMany
   */
  export type FlyerPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPages to fetch.
     */
    where?: FlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPages to fetch.
     */
    orderBy?: FlyerPageOrderByWithRelationInput | FlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlyerPages.
     */
    cursor?: FlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPages.
     */
    skip?: number
    distinct?: FlyerPageScalarFieldEnum | FlyerPageScalarFieldEnum[]
  }

  /**
   * FlyerPage create
   */
  export type FlyerPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * The data needed to create a FlyerPage.
     */
    data: XOR<FlyerPageCreateInput, FlyerPageUncheckedCreateInput>
  }

  /**
   * FlyerPage createMany
   */
  export type FlyerPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlyerPages.
     */
    data: FlyerPageCreateManyInput | FlyerPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlyerPage createManyAndReturn
   */
  export type FlyerPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlyerPages.
     */
    data: FlyerPageCreateManyInput | FlyerPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlyerPage update
   */
  export type FlyerPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * The data needed to update a FlyerPage.
     */
    data: XOR<FlyerPageUpdateInput, FlyerPageUncheckedUpdateInput>
    /**
     * Choose, which FlyerPage to update.
     */
    where: FlyerPageWhereUniqueInput
  }

  /**
   * FlyerPage updateMany
   */
  export type FlyerPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlyerPages.
     */
    data: XOR<FlyerPageUpdateManyMutationInput, FlyerPageUncheckedUpdateManyInput>
    /**
     * Filter which FlyerPages to update
     */
    where?: FlyerPageWhereInput
  }

  /**
   * FlyerPage upsert
   */
  export type FlyerPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * The filter to search for the FlyerPage to update in case it exists.
     */
    where: FlyerPageWhereUniqueInput
    /**
     * In case the FlyerPage found by the `where` argument doesn't exist, create a new FlyerPage with this data.
     */
    create: XOR<FlyerPageCreateInput, FlyerPageUncheckedCreateInput>
    /**
     * In case the FlyerPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlyerPageUpdateInput, FlyerPageUncheckedUpdateInput>
  }

  /**
   * FlyerPage delete
   */
  export type FlyerPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
    /**
     * Filter which FlyerPage to delete.
     */
    where: FlyerPageWhereUniqueInput
  }

  /**
   * FlyerPage deleteMany
   */
  export type FlyerPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerPages to delete
     */
    where?: FlyerPageWhereInput
  }

  /**
   * FlyerPage.slots
   */
  export type FlyerPage$slotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    where?: FlyerPageSlotWhereInput
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    cursor?: FlyerPageSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * FlyerPage.footerPromoImage
   */
  export type FlyerPage$footerPromoImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    where?: PromoImageWhereInput
  }

  /**
   * FlyerPage without action
   */
  export type FlyerPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPage
     */
    select?: FlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageInclude<ExtArgs> | null
  }


  /**
   * Model FlyerPageSlot
   */

  export type AggregateFlyerPageSlot = {
    _count: FlyerPageSlotCountAggregateOutputType | null
    _avg: FlyerPageSlotAvgAggregateOutputType | null
    _sum: FlyerPageSlotSumAggregateOutputType | null
    _min: FlyerPageSlotMinAggregateOutputType | null
    _max: FlyerPageSlotMaxAggregateOutputType | null
  }

  export type FlyerPageSlotAvgAggregateOutputType = {
    slotPosition: number | null
  }

  export type FlyerPageSlotSumAggregateOutputType = {
    slotPosition: number | null
  }

  export type FlyerPageSlotMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    slotPosition: number | null
    slotType: $Enums.SlotType | null
    productId: string | null
    promoImageId: string | null
    promoSize: $Enums.PromoSlotSize | null
    isPromoAnchor: boolean | null
    promoAnchorId: string | null
  }

  export type FlyerPageSlotMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    slotPosition: number | null
    slotType: $Enums.SlotType | null
    productId: string | null
    promoImageId: string | null
    promoSize: $Enums.PromoSlotSize | null
    isPromoAnchor: boolean | null
    promoAnchorId: string | null
  }

  export type FlyerPageSlotCountAggregateOutputType = {
    id: number
    pageId: number
    slotPosition: number
    slotType: number
    productId: number
    promoImageId: number
    promoSize: number
    isPromoAnchor: number
    promoAnchorId: number
    _all: number
  }


  export type FlyerPageSlotAvgAggregateInputType = {
    slotPosition?: true
  }

  export type FlyerPageSlotSumAggregateInputType = {
    slotPosition?: true
  }

  export type FlyerPageSlotMinAggregateInputType = {
    id?: true
    pageId?: true
    slotPosition?: true
    slotType?: true
    productId?: true
    promoImageId?: true
    promoSize?: true
    isPromoAnchor?: true
    promoAnchorId?: true
  }

  export type FlyerPageSlotMaxAggregateInputType = {
    id?: true
    pageId?: true
    slotPosition?: true
    slotType?: true
    productId?: true
    promoImageId?: true
    promoSize?: true
    isPromoAnchor?: true
    promoAnchorId?: true
  }

  export type FlyerPageSlotCountAggregateInputType = {
    id?: true
    pageId?: true
    slotPosition?: true
    slotType?: true
    productId?: true
    promoImageId?: true
    promoSize?: true
    isPromoAnchor?: true
    promoAnchorId?: true
    _all?: true
  }

  export type FlyerPageSlotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerPageSlot to aggregate.
     */
    where?: FlyerPageSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPageSlots to fetch.
     */
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlyerPageSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPageSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPageSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlyerPageSlots
    **/
    _count?: true | FlyerPageSlotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlyerPageSlotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlyerPageSlotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlyerPageSlotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlyerPageSlotMaxAggregateInputType
  }

  export type GetFlyerPageSlotAggregateType<T extends FlyerPageSlotAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyerPageSlot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyerPageSlot[P]>
      : GetScalarType<T[P], AggregateFlyerPageSlot[P]>
  }




  export type FlyerPageSlotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerPageSlotWhereInput
    orderBy?: FlyerPageSlotOrderByWithAggregationInput | FlyerPageSlotOrderByWithAggregationInput[]
    by: FlyerPageSlotScalarFieldEnum[] | FlyerPageSlotScalarFieldEnum
    having?: FlyerPageSlotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlyerPageSlotCountAggregateInputType | true
    _avg?: FlyerPageSlotAvgAggregateInputType
    _sum?: FlyerPageSlotSumAggregateInputType
    _min?: FlyerPageSlotMinAggregateInputType
    _max?: FlyerPageSlotMaxAggregateInputType
  }

  export type FlyerPageSlotGroupByOutputType = {
    id: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId: string | null
    promoImageId: string | null
    promoSize: $Enums.PromoSlotSize | null
    isPromoAnchor: boolean
    promoAnchorId: string | null
    _count: FlyerPageSlotCountAggregateOutputType | null
    _avg: FlyerPageSlotAvgAggregateOutputType | null
    _sum: FlyerPageSlotSumAggregateOutputType | null
    _min: FlyerPageSlotMinAggregateOutputType | null
    _max: FlyerPageSlotMaxAggregateOutputType | null
  }

  type GetFlyerPageSlotGroupByPayload<T extends FlyerPageSlotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlyerPageSlotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlyerPageSlotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlyerPageSlotGroupByOutputType[P]>
            : GetScalarType<T[P], FlyerPageSlotGroupByOutputType[P]>
        }
      >
    >


  export type FlyerPageSlotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    slotPosition?: boolean
    slotType?: boolean
    productId?: boolean
    promoImageId?: boolean
    promoSize?: boolean
    isPromoAnchor?: boolean
    promoAnchorId?: boolean
    page?: boolean | FlyerPageDefaultArgs<ExtArgs>
    product?: boolean | FlyerPageSlot$productArgs<ExtArgs>
    promoImage?: boolean | FlyerPageSlot$promoImageArgs<ExtArgs>
    promoAnchor?: boolean | FlyerPageSlot$promoAnchorArgs<ExtArgs>
    promoSpannedSlots?: boolean | FlyerPageSlot$promoSpannedSlotsArgs<ExtArgs>
    _count?: boolean | FlyerPageSlotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyerPageSlot"]>

  export type FlyerPageSlotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    slotPosition?: boolean
    slotType?: boolean
    productId?: boolean
    promoImageId?: boolean
    promoSize?: boolean
    isPromoAnchor?: boolean
    promoAnchorId?: boolean
    page?: boolean | FlyerPageDefaultArgs<ExtArgs>
    product?: boolean | FlyerPageSlot$productArgs<ExtArgs>
    promoImage?: boolean | FlyerPageSlot$promoImageArgs<ExtArgs>
    promoAnchor?: boolean | FlyerPageSlot$promoAnchorArgs<ExtArgs>
  }, ExtArgs["result"]["flyerPageSlot"]>

  export type FlyerPageSlotSelectScalar = {
    id?: boolean
    pageId?: boolean
    slotPosition?: boolean
    slotType?: boolean
    productId?: boolean
    promoImageId?: boolean
    promoSize?: boolean
    isPromoAnchor?: boolean
    promoAnchorId?: boolean
  }

  export type FlyerPageSlotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | FlyerPageDefaultArgs<ExtArgs>
    product?: boolean | FlyerPageSlot$productArgs<ExtArgs>
    promoImage?: boolean | FlyerPageSlot$promoImageArgs<ExtArgs>
    promoAnchor?: boolean | FlyerPageSlot$promoAnchorArgs<ExtArgs>
    promoSpannedSlots?: boolean | FlyerPageSlot$promoSpannedSlotsArgs<ExtArgs>
    _count?: boolean | FlyerPageSlotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FlyerPageSlotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | FlyerPageDefaultArgs<ExtArgs>
    product?: boolean | FlyerPageSlot$productArgs<ExtArgs>
    promoImage?: boolean | FlyerPageSlot$promoImageArgs<ExtArgs>
    promoAnchor?: boolean | FlyerPageSlot$promoAnchorArgs<ExtArgs>
  }

  export type $FlyerPageSlotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlyerPageSlot"
    objects: {
      page: Prisma.$FlyerPagePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs> | null
      promoImage: Prisma.$PromoImagePayload<ExtArgs> | null
      promoAnchor: Prisma.$FlyerPageSlotPayload<ExtArgs> | null
      promoSpannedSlots: Prisma.$FlyerPageSlotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      slotPosition: number
      slotType: $Enums.SlotType
      productId: string | null
      promoImageId: string | null
      promoSize: $Enums.PromoSlotSize | null
      isPromoAnchor: boolean
      promoAnchorId: string | null
    }, ExtArgs["result"]["flyerPageSlot"]>
    composites: {}
  }

  type FlyerPageSlotGetPayload<S extends boolean | null | undefined | FlyerPageSlotDefaultArgs> = $Result.GetResult<Prisma.$FlyerPageSlotPayload, S>

  type FlyerPageSlotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlyerPageSlotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlyerPageSlotCountAggregateInputType | true
    }

  export interface FlyerPageSlotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlyerPageSlot'], meta: { name: 'FlyerPageSlot' } }
    /**
     * Find zero or one FlyerPageSlot that matches the filter.
     * @param {FlyerPageSlotFindUniqueArgs} args - Arguments to find a FlyerPageSlot
     * @example
     * // Get one FlyerPageSlot
     * const flyerPageSlot = await prisma.flyerPageSlot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlyerPageSlotFindUniqueArgs>(args: SelectSubset<T, FlyerPageSlotFindUniqueArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlyerPageSlot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlyerPageSlotFindUniqueOrThrowArgs} args - Arguments to find a FlyerPageSlot
     * @example
     * // Get one FlyerPageSlot
     * const flyerPageSlot = await prisma.flyerPageSlot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlyerPageSlotFindUniqueOrThrowArgs>(args: SelectSubset<T, FlyerPageSlotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlyerPageSlot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotFindFirstArgs} args - Arguments to find a FlyerPageSlot
     * @example
     * // Get one FlyerPageSlot
     * const flyerPageSlot = await prisma.flyerPageSlot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlyerPageSlotFindFirstArgs>(args?: SelectSubset<T, FlyerPageSlotFindFirstArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlyerPageSlot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotFindFirstOrThrowArgs} args - Arguments to find a FlyerPageSlot
     * @example
     * // Get one FlyerPageSlot
     * const flyerPageSlot = await prisma.flyerPageSlot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlyerPageSlotFindFirstOrThrowArgs>(args?: SelectSubset<T, FlyerPageSlotFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlyerPageSlots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlyerPageSlots
     * const flyerPageSlots = await prisma.flyerPageSlot.findMany()
     * 
     * // Get first 10 FlyerPageSlots
     * const flyerPageSlots = await prisma.flyerPageSlot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flyerPageSlotWithIdOnly = await prisma.flyerPageSlot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlyerPageSlotFindManyArgs>(args?: SelectSubset<T, FlyerPageSlotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlyerPageSlot.
     * @param {FlyerPageSlotCreateArgs} args - Arguments to create a FlyerPageSlot.
     * @example
     * // Create one FlyerPageSlot
     * const FlyerPageSlot = await prisma.flyerPageSlot.create({
     *   data: {
     *     // ... data to create a FlyerPageSlot
     *   }
     * })
     * 
     */
    create<T extends FlyerPageSlotCreateArgs>(args: SelectSubset<T, FlyerPageSlotCreateArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlyerPageSlots.
     * @param {FlyerPageSlotCreateManyArgs} args - Arguments to create many FlyerPageSlots.
     * @example
     * // Create many FlyerPageSlots
     * const flyerPageSlot = await prisma.flyerPageSlot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlyerPageSlotCreateManyArgs>(args?: SelectSubset<T, FlyerPageSlotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlyerPageSlots and returns the data saved in the database.
     * @param {FlyerPageSlotCreateManyAndReturnArgs} args - Arguments to create many FlyerPageSlots.
     * @example
     * // Create many FlyerPageSlots
     * const flyerPageSlot = await prisma.flyerPageSlot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlyerPageSlots and only return the `id`
     * const flyerPageSlotWithIdOnly = await prisma.flyerPageSlot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlyerPageSlotCreateManyAndReturnArgs>(args?: SelectSubset<T, FlyerPageSlotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlyerPageSlot.
     * @param {FlyerPageSlotDeleteArgs} args - Arguments to delete one FlyerPageSlot.
     * @example
     * // Delete one FlyerPageSlot
     * const FlyerPageSlot = await prisma.flyerPageSlot.delete({
     *   where: {
     *     // ... filter to delete one FlyerPageSlot
     *   }
     * })
     * 
     */
    delete<T extends FlyerPageSlotDeleteArgs>(args: SelectSubset<T, FlyerPageSlotDeleteArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlyerPageSlot.
     * @param {FlyerPageSlotUpdateArgs} args - Arguments to update one FlyerPageSlot.
     * @example
     * // Update one FlyerPageSlot
     * const flyerPageSlot = await prisma.flyerPageSlot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlyerPageSlotUpdateArgs>(args: SelectSubset<T, FlyerPageSlotUpdateArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlyerPageSlots.
     * @param {FlyerPageSlotDeleteManyArgs} args - Arguments to filter FlyerPageSlots to delete.
     * @example
     * // Delete a few FlyerPageSlots
     * const { count } = await prisma.flyerPageSlot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlyerPageSlotDeleteManyArgs>(args?: SelectSubset<T, FlyerPageSlotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlyerPageSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlyerPageSlots
     * const flyerPageSlot = await prisma.flyerPageSlot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlyerPageSlotUpdateManyArgs>(args: SelectSubset<T, FlyerPageSlotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlyerPageSlot.
     * @param {FlyerPageSlotUpsertArgs} args - Arguments to update or create a FlyerPageSlot.
     * @example
     * // Update or create a FlyerPageSlot
     * const flyerPageSlot = await prisma.flyerPageSlot.upsert({
     *   create: {
     *     // ... data to create a FlyerPageSlot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlyerPageSlot we want to update
     *   }
     * })
     */
    upsert<T extends FlyerPageSlotUpsertArgs>(args: SelectSubset<T, FlyerPageSlotUpsertArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlyerPageSlots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotCountArgs} args - Arguments to filter FlyerPageSlots to count.
     * @example
     * // Count the number of FlyerPageSlots
     * const count = await prisma.flyerPageSlot.count({
     *   where: {
     *     // ... the filter for the FlyerPageSlots we want to count
     *   }
     * })
    **/
    count<T extends FlyerPageSlotCountArgs>(
      args?: Subset<T, FlyerPageSlotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlyerPageSlotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlyerPageSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlyerPageSlotAggregateArgs>(args: Subset<T, FlyerPageSlotAggregateArgs>): Prisma.PrismaPromise<GetFlyerPageSlotAggregateType<T>>

    /**
     * Group by FlyerPageSlot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerPageSlotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlyerPageSlotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlyerPageSlotGroupByArgs['orderBy'] }
        : { orderBy?: FlyerPageSlotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlyerPageSlotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyerPageSlotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlyerPageSlot model
   */
  readonly fields: FlyerPageSlotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlyerPageSlot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlyerPageSlotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends FlyerPageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPageDefaultArgs<ExtArgs>>): Prisma__FlyerPageClient<$Result.GetResult<Prisma.$FlyerPagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends FlyerPageSlot$productArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPageSlot$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    promoImage<T extends FlyerPageSlot$promoImageArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPageSlot$promoImageArgs<ExtArgs>>): Prisma__PromoImageClient<$Result.GetResult<Prisma.$PromoImagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    promoAnchor<T extends FlyerPageSlot$promoAnchorArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPageSlot$promoAnchorArgs<ExtArgs>>): Prisma__FlyerPageSlotClient<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    promoSpannedSlots<T extends FlyerPageSlot$promoSpannedSlotsArgs<ExtArgs> = {}>(args?: Subset<T, FlyerPageSlot$promoSpannedSlotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerPageSlotPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlyerPageSlot model
   */ 
  interface FlyerPageSlotFieldRefs {
    readonly id: FieldRef<"FlyerPageSlot", 'String'>
    readonly pageId: FieldRef<"FlyerPageSlot", 'String'>
    readonly slotPosition: FieldRef<"FlyerPageSlot", 'Int'>
    readonly slotType: FieldRef<"FlyerPageSlot", 'SlotType'>
    readonly productId: FieldRef<"FlyerPageSlot", 'String'>
    readonly promoImageId: FieldRef<"FlyerPageSlot", 'String'>
    readonly promoSize: FieldRef<"FlyerPageSlot", 'PromoSlotSize'>
    readonly isPromoAnchor: FieldRef<"FlyerPageSlot", 'Boolean'>
    readonly promoAnchorId: FieldRef<"FlyerPageSlot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FlyerPageSlot findUnique
   */
  export type FlyerPageSlotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPageSlot to fetch.
     */
    where: FlyerPageSlotWhereUniqueInput
  }

  /**
   * FlyerPageSlot findUniqueOrThrow
   */
  export type FlyerPageSlotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPageSlot to fetch.
     */
    where: FlyerPageSlotWhereUniqueInput
  }

  /**
   * FlyerPageSlot findFirst
   */
  export type FlyerPageSlotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPageSlot to fetch.
     */
    where?: FlyerPageSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPageSlots to fetch.
     */
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerPageSlots.
     */
    cursor?: FlyerPageSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPageSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPageSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerPageSlots.
     */
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * FlyerPageSlot findFirstOrThrow
   */
  export type FlyerPageSlotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPageSlot to fetch.
     */
    where?: FlyerPageSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPageSlots to fetch.
     */
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerPageSlots.
     */
    cursor?: FlyerPageSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPageSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPageSlots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerPageSlots.
     */
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * FlyerPageSlot findMany
   */
  export type FlyerPageSlotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * Filter, which FlyerPageSlots to fetch.
     */
    where?: FlyerPageSlotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerPageSlots to fetch.
     */
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlyerPageSlots.
     */
    cursor?: FlyerPageSlotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerPageSlots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerPageSlots.
     */
    skip?: number
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * FlyerPageSlot create
   */
  export type FlyerPageSlotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * The data needed to create a FlyerPageSlot.
     */
    data: XOR<FlyerPageSlotCreateInput, FlyerPageSlotUncheckedCreateInput>
  }

  /**
   * FlyerPageSlot createMany
   */
  export type FlyerPageSlotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlyerPageSlots.
     */
    data: FlyerPageSlotCreateManyInput | FlyerPageSlotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlyerPageSlot createManyAndReturn
   */
  export type FlyerPageSlotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlyerPageSlots.
     */
    data: FlyerPageSlotCreateManyInput | FlyerPageSlotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlyerPageSlot update
   */
  export type FlyerPageSlotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * The data needed to update a FlyerPageSlot.
     */
    data: XOR<FlyerPageSlotUpdateInput, FlyerPageSlotUncheckedUpdateInput>
    /**
     * Choose, which FlyerPageSlot to update.
     */
    where: FlyerPageSlotWhereUniqueInput
  }

  /**
   * FlyerPageSlot updateMany
   */
  export type FlyerPageSlotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlyerPageSlots.
     */
    data: XOR<FlyerPageSlotUpdateManyMutationInput, FlyerPageSlotUncheckedUpdateManyInput>
    /**
     * Filter which FlyerPageSlots to update
     */
    where?: FlyerPageSlotWhereInput
  }

  /**
   * FlyerPageSlot upsert
   */
  export type FlyerPageSlotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * The filter to search for the FlyerPageSlot to update in case it exists.
     */
    where: FlyerPageSlotWhereUniqueInput
    /**
     * In case the FlyerPageSlot found by the `where` argument doesn't exist, create a new FlyerPageSlot with this data.
     */
    create: XOR<FlyerPageSlotCreateInput, FlyerPageSlotUncheckedCreateInput>
    /**
     * In case the FlyerPageSlot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlyerPageSlotUpdateInput, FlyerPageSlotUncheckedUpdateInput>
  }

  /**
   * FlyerPageSlot delete
   */
  export type FlyerPageSlotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    /**
     * Filter which FlyerPageSlot to delete.
     */
    where: FlyerPageSlotWhereUniqueInput
  }

  /**
   * FlyerPageSlot deleteMany
   */
  export type FlyerPageSlotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerPageSlots to delete
     */
    where?: FlyerPageSlotWhereInput
  }

  /**
   * FlyerPageSlot.product
   */
  export type FlyerPageSlot$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * FlyerPageSlot.promoImage
   */
  export type FlyerPageSlot$promoImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PromoImage
     */
    select?: PromoImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PromoImageInclude<ExtArgs> | null
    where?: PromoImageWhereInput
  }

  /**
   * FlyerPageSlot.promoAnchor
   */
  export type FlyerPageSlot$promoAnchorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    where?: FlyerPageSlotWhereInput
  }

  /**
   * FlyerPageSlot.promoSpannedSlots
   */
  export type FlyerPageSlot$promoSpannedSlotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
    where?: FlyerPageSlotWhereInput
    orderBy?: FlyerPageSlotOrderByWithRelationInput | FlyerPageSlotOrderByWithRelationInput[]
    cursor?: FlyerPageSlotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlyerPageSlotScalarFieldEnum | FlyerPageSlotScalarFieldEnum[]
  }

  /**
   * FlyerPageSlot without action
   */
  export type FlyerPageSlotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerPageSlot
     */
    select?: FlyerPageSlotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerPageSlotInclude<ExtArgs> | null
  }


  /**
   * Model VerificationLog
   */

  export type AggregateVerificationLog = {
    _count: VerificationLogCountAggregateOutputType | null
    _min: VerificationLogMinAggregateOutputType | null
    _max: VerificationLogMaxAggregateOutputType | null
  }

  export type VerificationLogMinAggregateOutputType = {
    id: string | null
    flyerId: string | null
    verificationDate: Date | null
    status: $Enums.VerificationStatus | null
    createdAt: Date | null
  }

  export type VerificationLogMaxAggregateOutputType = {
    id: string | null
    flyerId: string | null
    verificationDate: Date | null
    status: $Enums.VerificationStatus | null
    createdAt: Date | null
  }

  export type VerificationLogCountAggregateOutputType = {
    id: number
    flyerId: number
    verificationDate: number
    status: number
    details: number
    createdAt: number
    _all: number
  }


  export type VerificationLogMinAggregateInputType = {
    id?: true
    flyerId?: true
    verificationDate?: true
    status?: true
    createdAt?: true
  }

  export type VerificationLogMaxAggregateInputType = {
    id?: true
    flyerId?: true
    verificationDate?: true
    status?: true
    createdAt?: true
  }

  export type VerificationLogCountAggregateInputType = {
    id?: true
    flyerId?: true
    verificationDate?: true
    status?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type VerificationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationLog to aggregate.
     */
    where?: VerificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationLogs to fetch.
     */
    orderBy?: VerificationLogOrderByWithRelationInput | VerificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationLogs
    **/
    _count?: true | VerificationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationLogMaxAggregateInputType
  }

  export type GetVerificationLogAggregateType<T extends VerificationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationLog[P]>
      : GetScalarType<T[P], AggregateVerificationLog[P]>
  }




  export type VerificationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationLogWhereInput
    orderBy?: VerificationLogOrderByWithAggregationInput | VerificationLogOrderByWithAggregationInput[]
    by: VerificationLogScalarFieldEnum[] | VerificationLogScalarFieldEnum
    having?: VerificationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationLogCountAggregateInputType | true
    _min?: VerificationLogMinAggregateInputType
    _max?: VerificationLogMaxAggregateInputType
  }

  export type VerificationLogGroupByOutputType = {
    id: string
    flyerId: string
    verificationDate: Date
    status: $Enums.VerificationStatus
    details: JsonValue
    createdAt: Date
    _count: VerificationLogCountAggregateOutputType | null
    _min: VerificationLogMinAggregateOutputType | null
    _max: VerificationLogMaxAggregateOutputType | null
  }

  type GetVerificationLogGroupByPayload<T extends VerificationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationLogGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationLogGroupByOutputType[P]>
        }
      >
    >


  export type VerificationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    verificationDate?: boolean
    status?: boolean
    details?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationLog"]>

  export type VerificationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    verificationDate?: boolean
    status?: boolean
    details?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationLog"]>

  export type VerificationLogSelectScalar = {
    id?: boolean
    flyerId?: boolean
    verificationDate?: boolean
    status?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type VerificationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }
  export type VerificationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }

  export type $VerificationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationLog"
    objects: {
      flyer: Prisma.$FlyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flyerId: string
      verificationDate: Date
      status: $Enums.VerificationStatus
      details: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["verificationLog"]>
    composites: {}
  }

  type VerificationLogGetPayload<S extends boolean | null | undefined | VerificationLogDefaultArgs> = $Result.GetResult<Prisma.$VerificationLogPayload, S>

  type VerificationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationLogCountAggregateInputType | true
    }

  export interface VerificationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationLog'], meta: { name: 'VerificationLog' } }
    /**
     * Find zero or one VerificationLog that matches the filter.
     * @param {VerificationLogFindUniqueArgs} args - Arguments to find a VerificationLog
     * @example
     * // Get one VerificationLog
     * const verificationLog = await prisma.verificationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationLogFindUniqueArgs>(args: SelectSubset<T, VerificationLogFindUniqueArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationLogFindUniqueOrThrowArgs} args - Arguments to find a VerificationLog
     * @example
     * // Get one VerificationLog
     * const verificationLog = await prisma.verificationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogFindFirstArgs} args - Arguments to find a VerificationLog
     * @example
     * // Get one VerificationLog
     * const verificationLog = await prisma.verificationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationLogFindFirstArgs>(args?: SelectSubset<T, VerificationLogFindFirstArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogFindFirstOrThrowArgs} args - Arguments to find a VerificationLog
     * @example
     * // Get one VerificationLog
     * const verificationLog = await prisma.verificationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationLogs
     * const verificationLogs = await prisma.verificationLog.findMany()
     * 
     * // Get first 10 VerificationLogs
     * const verificationLogs = await prisma.verificationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationLogWithIdOnly = await prisma.verificationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationLogFindManyArgs>(args?: SelectSubset<T, VerificationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationLog.
     * @param {VerificationLogCreateArgs} args - Arguments to create a VerificationLog.
     * @example
     * // Create one VerificationLog
     * const VerificationLog = await prisma.verificationLog.create({
     *   data: {
     *     // ... data to create a VerificationLog
     *   }
     * })
     * 
     */
    create<T extends VerificationLogCreateArgs>(args: SelectSubset<T, VerificationLogCreateArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationLogs.
     * @param {VerificationLogCreateManyArgs} args - Arguments to create many VerificationLogs.
     * @example
     * // Create many VerificationLogs
     * const verificationLog = await prisma.verificationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationLogCreateManyArgs>(args?: SelectSubset<T, VerificationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationLogs and returns the data saved in the database.
     * @param {VerificationLogCreateManyAndReturnArgs} args - Arguments to create many VerificationLogs.
     * @example
     * // Create many VerificationLogs
     * const verificationLog = await prisma.verificationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationLogs and only return the `id`
     * const verificationLogWithIdOnly = await prisma.verificationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VerificationLog.
     * @param {VerificationLogDeleteArgs} args - Arguments to delete one VerificationLog.
     * @example
     * // Delete one VerificationLog
     * const VerificationLog = await prisma.verificationLog.delete({
     *   where: {
     *     // ... filter to delete one VerificationLog
     *   }
     * })
     * 
     */
    delete<T extends VerificationLogDeleteArgs>(args: SelectSubset<T, VerificationLogDeleteArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationLog.
     * @param {VerificationLogUpdateArgs} args - Arguments to update one VerificationLog.
     * @example
     * // Update one VerificationLog
     * const verificationLog = await prisma.verificationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationLogUpdateArgs>(args: SelectSubset<T, VerificationLogUpdateArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationLogs.
     * @param {VerificationLogDeleteManyArgs} args - Arguments to filter VerificationLogs to delete.
     * @example
     * // Delete a few VerificationLogs
     * const { count } = await prisma.verificationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationLogDeleteManyArgs>(args?: SelectSubset<T, VerificationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationLogs
     * const verificationLog = await prisma.verificationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationLogUpdateManyArgs>(args: SelectSubset<T, VerificationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationLog.
     * @param {VerificationLogUpsertArgs} args - Arguments to update or create a VerificationLog.
     * @example
     * // Update or create a VerificationLog
     * const verificationLog = await prisma.verificationLog.upsert({
     *   create: {
     *     // ... data to create a VerificationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationLog we want to update
     *   }
     * })
     */
    upsert<T extends VerificationLogUpsertArgs>(args: SelectSubset<T, VerificationLogUpsertArgs<ExtArgs>>): Prisma__VerificationLogClient<$Result.GetResult<Prisma.$VerificationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogCountArgs} args - Arguments to filter VerificationLogs to count.
     * @example
     * // Count the number of VerificationLogs
     * const count = await prisma.verificationLog.count({
     *   where: {
     *     // ... the filter for the VerificationLogs we want to count
     *   }
     * })
    **/
    count<T extends VerificationLogCountArgs>(
      args?: Subset<T, VerificationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationLogAggregateArgs>(args: Subset<T, VerificationLogAggregateArgs>): Prisma.PrismaPromise<GetVerificationLogAggregateType<T>>

    /**
     * Group by VerificationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationLogGroupByArgs['orderBy'] }
        : { orderBy?: VerificationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationLog model
   */
  readonly fields: VerificationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flyer<T extends FlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerDefaultArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationLog model
   */ 
  interface VerificationLogFieldRefs {
    readonly id: FieldRef<"VerificationLog", 'String'>
    readonly flyerId: FieldRef<"VerificationLog", 'String'>
    readonly verificationDate: FieldRef<"VerificationLog", 'DateTime'>
    readonly status: FieldRef<"VerificationLog", 'VerificationStatus'>
    readonly details: FieldRef<"VerificationLog", 'Json'>
    readonly createdAt: FieldRef<"VerificationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationLog findUnique
   */
  export type VerificationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * Filter, which VerificationLog to fetch.
     */
    where: VerificationLogWhereUniqueInput
  }

  /**
   * VerificationLog findUniqueOrThrow
   */
  export type VerificationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * Filter, which VerificationLog to fetch.
     */
    where: VerificationLogWhereUniqueInput
  }

  /**
   * VerificationLog findFirst
   */
  export type VerificationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * Filter, which VerificationLog to fetch.
     */
    where?: VerificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationLogs to fetch.
     */
    orderBy?: VerificationLogOrderByWithRelationInput | VerificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationLogs.
     */
    cursor?: VerificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationLogs.
     */
    distinct?: VerificationLogScalarFieldEnum | VerificationLogScalarFieldEnum[]
  }

  /**
   * VerificationLog findFirstOrThrow
   */
  export type VerificationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * Filter, which VerificationLog to fetch.
     */
    where?: VerificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationLogs to fetch.
     */
    orderBy?: VerificationLogOrderByWithRelationInput | VerificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationLogs.
     */
    cursor?: VerificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationLogs.
     */
    distinct?: VerificationLogScalarFieldEnum | VerificationLogScalarFieldEnum[]
  }

  /**
   * VerificationLog findMany
   */
  export type VerificationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * Filter, which VerificationLogs to fetch.
     */
    where?: VerificationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationLogs to fetch.
     */
    orderBy?: VerificationLogOrderByWithRelationInput | VerificationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationLogs.
     */
    cursor?: VerificationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationLogs.
     */
    skip?: number
    distinct?: VerificationLogScalarFieldEnum | VerificationLogScalarFieldEnum[]
  }

  /**
   * VerificationLog create
   */
  export type VerificationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationLog.
     */
    data: XOR<VerificationLogCreateInput, VerificationLogUncheckedCreateInput>
  }

  /**
   * VerificationLog createMany
   */
  export type VerificationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationLogs.
     */
    data: VerificationLogCreateManyInput | VerificationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationLog createManyAndReturn
   */
  export type VerificationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VerificationLogs.
     */
    data: VerificationLogCreateManyInput | VerificationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationLog update
   */
  export type VerificationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationLog.
     */
    data: XOR<VerificationLogUpdateInput, VerificationLogUncheckedUpdateInput>
    /**
     * Choose, which VerificationLog to update.
     */
    where: VerificationLogWhereUniqueInput
  }

  /**
   * VerificationLog updateMany
   */
  export type VerificationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationLogs.
     */
    data: XOR<VerificationLogUpdateManyMutationInput, VerificationLogUncheckedUpdateManyInput>
    /**
     * Filter which VerificationLogs to update
     */
    where?: VerificationLogWhereInput
  }

  /**
   * VerificationLog upsert
   */
  export type VerificationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationLog to update in case it exists.
     */
    where: VerificationLogWhereUniqueInput
    /**
     * In case the VerificationLog found by the `where` argument doesn't exist, create a new VerificationLog with this data.
     */
    create: XOR<VerificationLogCreateInput, VerificationLogUncheckedCreateInput>
    /**
     * In case the VerificationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationLogUpdateInput, VerificationLogUncheckedUpdateInput>
  }

  /**
   * VerificationLog delete
   */
  export type VerificationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
    /**
     * Filter which VerificationLog to delete.
     */
    where: VerificationLogWhereUniqueInput
  }

  /**
   * VerificationLog deleteMany
   */
  export type VerificationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationLogs to delete
     */
    where?: VerificationLogWhereInput
  }

  /**
   * VerificationLog without action
   */
  export type VerificationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationLog
     */
    select?: VerificationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationLogInclude<ExtArgs> | null
  }


  /**
   * Model Approval
   */

  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalMinAggregateOutputType = {
    id: string | null
    flyerId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    decidedAt: Date | null
    createdAt: Date | null
  }

  export type ApprovalMaxAggregateOutputType = {
    id: string | null
    flyerId: string | null
    approverId: string | null
    status: $Enums.ApprovalStatus | null
    comment: string | null
    decidedAt: Date | null
    createdAt: Date | null
  }

  export type ApprovalCountAggregateOutputType = {
    id: number
    flyerId: number
    approverId: number
    status: number
    comment: number
    decidedAt: number
    createdAt: number
    _all: number
  }


  export type ApprovalMinAggregateInputType = {
    id?: true
    flyerId?: true
    approverId?: true
    status?: true
    comment?: true
    decidedAt?: true
    createdAt?: true
  }

  export type ApprovalMaxAggregateInputType = {
    id?: true
    flyerId?: true
    approverId?: true
    status?: true
    comment?: true
    decidedAt?: true
    createdAt?: true
  }

  export type ApprovalCountAggregateInputType = {
    id?: true
    flyerId?: true
    approverId?: true
    status?: true
    comment?: true
    decidedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approval to aggregate.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithAggregationInput | ApprovalOrderByWithAggregationInput[]
    by: ApprovalScalarFieldEnum[] | ApprovalScalarFieldEnum
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }

  export type ApprovalGroupByOutputType = {
    id: string
    flyerId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment: string | null
    decidedAt: Date | null
    createdAt: Date
    _count: ApprovalCountAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    decidedAt?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    decidedAt?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectScalar = {
    id?: boolean
    flyerId?: boolean
    approverId?: boolean
    status?: boolean
    comment?: boolean
    decidedAt?: boolean
    createdAt?: boolean
  }

  export type ApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
    approver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Approval"
    objects: {
      flyer: Prisma.$FlyerPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flyerId: string
      approverId: string
      status: $Enums.ApprovalStatus
      comment: string | null
      decidedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["approval"]>
    composites: {}
  }

  type ApprovalGetPayload<S extends boolean | null | undefined | ApprovalDefaultArgs> = $Result.GetResult<Prisma.$ApprovalPayload, S>

  type ApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalCountAggregateInputType | true
    }

  export interface ApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Approval'], meta: { name: 'Approval' } }
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalFindUniqueArgs>(args: SelectSubset<T, ApprovalFindUniqueArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Approval that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalFindUniqueOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalFindFirstArgs>(args?: SelectSubset<T, ApprovalFindFirstArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWithIdOnly = await prisma.approval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalFindManyArgs>(args?: SelectSubset<T, ApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
     */
    create<T extends ApprovalCreateArgs>(args: SelectSubset<T, ApprovalCreateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Approvals.
     * @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalCreateManyArgs>(args?: SelectSubset<T, ApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Approvals and returns the data saved in the database.
     * @param {ApprovalCreateManyAndReturnArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
     */
    delete<T extends ApprovalDeleteArgs>(args: SelectSubset<T, ApprovalDeleteArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalUpdateArgs>(args: SelectSubset<T, ApprovalUpdateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalDeleteManyArgs>(args?: SelectSubset<T, ApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalUpdateManyArgs>(args: SelectSubset<T, ApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalUpsertArgs>(args: SelectSubset<T, ApprovalUpsertArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): Prisma.PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Approval model
   */
  readonly fields: ApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flyer<T extends FlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerDefaultArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    approver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Approval model
   */ 
  interface ApprovalFieldRefs {
    readonly id: FieldRef<"Approval", 'String'>
    readonly flyerId: FieldRef<"Approval", 'String'>
    readonly approverId: FieldRef<"Approval", 'String'>
    readonly status: FieldRef<"Approval", 'ApprovalStatus'>
    readonly comment: FieldRef<"Approval", 'String'>
    readonly decidedAt: FieldRef<"Approval", 'DateTime'>
    readonly createdAt: FieldRef<"Approval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findUniqueOrThrow
   */
  export type ApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findFirstOrThrow
   */
  export type ApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approvals to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval create
   */
  export type ApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a Approval.
     */
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }

  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Approval createManyAndReturn
   */
  export type ApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval update
   */
  export type ApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a Approval.
     */
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
  }

  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the Approval to update in case it exists.
     */
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     */
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }

  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter which Approval to delete.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approvals to delete
     */
    where?: ApprovalWhereInput
  }

  /**
   * Approval without action
   */
  export type ApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalWorkflow
   */

  export type AggregateApprovalWorkflow = {
    _count: ApprovalWorkflowCountAggregateOutputType | null
    _avg: ApprovalWorkflowAvgAggregateOutputType | null
    _sum: ApprovalWorkflowSumAggregateOutputType | null
    _min: ApprovalWorkflowMinAggregateOutputType | null
    _max: ApprovalWorkflowMaxAggregateOutputType | null
  }

  export type ApprovalWorkflowAvgAggregateOutputType = {
    requiredApprovers: number | null
    currentApprovals: number | null
  }

  export type ApprovalWorkflowSumAggregateOutputType = {
    requiredApprovers: number | null
    currentApprovals: number | null
  }

  export type ApprovalWorkflowMinAggregateOutputType = {
    id: string | null
    flyerId: string | null
    requiredApprovers: number | null
    currentApprovals: number | null
    isComplete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalWorkflowMaxAggregateOutputType = {
    id: string | null
    flyerId: string | null
    requiredApprovers: number | null
    currentApprovals: number | null
    isComplete: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalWorkflowCountAggregateOutputType = {
    id: number
    flyerId: number
    requiredApprovers: number
    currentApprovals: number
    isComplete: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalWorkflowAvgAggregateInputType = {
    requiredApprovers?: true
    currentApprovals?: true
  }

  export type ApprovalWorkflowSumAggregateInputType = {
    requiredApprovers?: true
    currentApprovals?: true
  }

  export type ApprovalWorkflowMinAggregateInputType = {
    id?: true
    flyerId?: true
    requiredApprovers?: true
    currentApprovals?: true
    isComplete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalWorkflowMaxAggregateInputType = {
    id?: true
    flyerId?: true
    requiredApprovers?: true
    currentApprovals?: true
    isComplete?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalWorkflowCountAggregateInputType = {
    id?: true
    flyerId?: true
    requiredApprovers?: true
    currentApprovals?: true
    isComplete?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalWorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalWorkflow to aggregate.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalWorkflows
    **/
    _count?: true | ApprovalWorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalWorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalWorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalWorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalWorkflowMaxAggregateInputType
  }

  export type GetApprovalWorkflowAggregateType<T extends ApprovalWorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalWorkflow[P]>
      : GetScalarType<T[P], AggregateApprovalWorkflow[P]>
  }




  export type ApprovalWorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWorkflowWhereInput
    orderBy?: ApprovalWorkflowOrderByWithAggregationInput | ApprovalWorkflowOrderByWithAggregationInput[]
    by: ApprovalWorkflowScalarFieldEnum[] | ApprovalWorkflowScalarFieldEnum
    having?: ApprovalWorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalWorkflowCountAggregateInputType | true
    _avg?: ApprovalWorkflowAvgAggregateInputType
    _sum?: ApprovalWorkflowSumAggregateInputType
    _min?: ApprovalWorkflowMinAggregateInputType
    _max?: ApprovalWorkflowMaxAggregateInputType
  }

  export type ApprovalWorkflowGroupByOutputType = {
    id: string
    flyerId: string
    requiredApprovers: number
    currentApprovals: number
    isComplete: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApprovalWorkflowCountAggregateOutputType | null
    _avg: ApprovalWorkflowAvgAggregateOutputType | null
    _sum: ApprovalWorkflowSumAggregateOutputType | null
    _min: ApprovalWorkflowMinAggregateOutputType | null
    _max: ApprovalWorkflowMaxAggregateOutputType | null
  }

  type GetApprovalWorkflowGroupByPayload<T extends ApprovalWorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalWorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalWorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalWorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalWorkflowGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalWorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    requiredApprovers?: boolean
    currentApprovals?: boolean
    isComplete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalWorkflow"]>

  export type ApprovalWorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    requiredApprovers?: boolean
    currentApprovals?: boolean
    isComplete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalWorkflow"]>

  export type ApprovalWorkflowSelectScalar = {
    id?: boolean
    flyerId?: boolean
    requiredApprovers?: boolean
    currentApprovals?: boolean
    isComplete?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalWorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }
  export type ApprovalWorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }

  export type $ApprovalWorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalWorkflow"
    objects: {
      flyer: Prisma.$FlyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flyerId: string
      requiredApprovers: number
      currentApprovals: number
      isComplete: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalWorkflow"]>
    composites: {}
  }

  type ApprovalWorkflowGetPayload<S extends boolean | null | undefined | ApprovalWorkflowDefaultArgs> = $Result.GetResult<Prisma.$ApprovalWorkflowPayload, S>

  type ApprovalWorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ApprovalWorkflowFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ApprovalWorkflowCountAggregateInputType | true
    }

  export interface ApprovalWorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalWorkflow'], meta: { name: 'ApprovalWorkflow' } }
    /**
     * Find zero or one ApprovalWorkflow that matches the filter.
     * @param {ApprovalWorkflowFindUniqueArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalWorkflowFindUniqueArgs>(args: SelectSubset<T, ApprovalWorkflowFindUniqueArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ApprovalWorkflow that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ApprovalWorkflowFindUniqueOrThrowArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalWorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalWorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ApprovalWorkflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowFindFirstArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalWorkflowFindFirstArgs>(args?: SelectSubset<T, ApprovalWorkflowFindFirstArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ApprovalWorkflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowFindFirstOrThrowArgs} args - Arguments to find a ApprovalWorkflow
     * @example
     * // Get one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalWorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalWorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ApprovalWorkflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalWorkflows
     * const approvalWorkflows = await prisma.approvalWorkflow.findMany()
     * 
     * // Get first 10 ApprovalWorkflows
     * const approvalWorkflows = await prisma.approvalWorkflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWorkflowWithIdOnly = await prisma.approvalWorkflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalWorkflowFindManyArgs>(args?: SelectSubset<T, ApprovalWorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ApprovalWorkflow.
     * @param {ApprovalWorkflowCreateArgs} args - Arguments to create a ApprovalWorkflow.
     * @example
     * // Create one ApprovalWorkflow
     * const ApprovalWorkflow = await prisma.approvalWorkflow.create({
     *   data: {
     *     // ... data to create a ApprovalWorkflow
     *   }
     * })
     * 
     */
    create<T extends ApprovalWorkflowCreateArgs>(args: SelectSubset<T, ApprovalWorkflowCreateArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ApprovalWorkflows.
     * @param {ApprovalWorkflowCreateManyArgs} args - Arguments to create many ApprovalWorkflows.
     * @example
     * // Create many ApprovalWorkflows
     * const approvalWorkflow = await prisma.approvalWorkflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalWorkflowCreateManyArgs>(args?: SelectSubset<T, ApprovalWorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalWorkflows and returns the data saved in the database.
     * @param {ApprovalWorkflowCreateManyAndReturnArgs} args - Arguments to create many ApprovalWorkflows.
     * @example
     * // Create many ApprovalWorkflows
     * const approvalWorkflow = await prisma.approvalWorkflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalWorkflows and only return the `id`
     * const approvalWorkflowWithIdOnly = await prisma.approvalWorkflow.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalWorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalWorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ApprovalWorkflow.
     * @param {ApprovalWorkflowDeleteArgs} args - Arguments to delete one ApprovalWorkflow.
     * @example
     * // Delete one ApprovalWorkflow
     * const ApprovalWorkflow = await prisma.approvalWorkflow.delete({
     *   where: {
     *     // ... filter to delete one ApprovalWorkflow
     *   }
     * })
     * 
     */
    delete<T extends ApprovalWorkflowDeleteArgs>(args: SelectSubset<T, ApprovalWorkflowDeleteArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ApprovalWorkflow.
     * @param {ApprovalWorkflowUpdateArgs} args - Arguments to update one ApprovalWorkflow.
     * @example
     * // Update one ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalWorkflowUpdateArgs>(args: SelectSubset<T, ApprovalWorkflowUpdateArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ApprovalWorkflows.
     * @param {ApprovalWorkflowDeleteManyArgs} args - Arguments to filter ApprovalWorkflows to delete.
     * @example
     * // Delete a few ApprovalWorkflows
     * const { count } = await prisma.approvalWorkflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalWorkflowDeleteManyArgs>(args?: SelectSubset<T, ApprovalWorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalWorkflows
     * const approvalWorkflow = await prisma.approvalWorkflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalWorkflowUpdateManyArgs>(args: SelectSubset<T, ApprovalWorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ApprovalWorkflow.
     * @param {ApprovalWorkflowUpsertArgs} args - Arguments to update or create a ApprovalWorkflow.
     * @example
     * // Update or create a ApprovalWorkflow
     * const approvalWorkflow = await prisma.approvalWorkflow.upsert({
     *   create: {
     *     // ... data to create a ApprovalWorkflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalWorkflow we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalWorkflowUpsertArgs>(args: SelectSubset<T, ApprovalWorkflowUpsertArgs<ExtArgs>>): Prisma__ApprovalWorkflowClient<$Result.GetResult<Prisma.$ApprovalWorkflowPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ApprovalWorkflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowCountArgs} args - Arguments to filter ApprovalWorkflows to count.
     * @example
     * // Count the number of ApprovalWorkflows
     * const count = await prisma.approvalWorkflow.count({
     *   where: {
     *     // ... the filter for the ApprovalWorkflows we want to count
     *   }
     * })
    **/
    count<T extends ApprovalWorkflowCountArgs>(
      args?: Subset<T, ApprovalWorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalWorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalWorkflowAggregateArgs>(args: Subset<T, ApprovalWorkflowAggregateArgs>): Prisma.PrismaPromise<GetApprovalWorkflowAggregateType<T>>

    /**
     * Group by ApprovalWorkflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalWorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalWorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalWorkflowGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalWorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalWorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalWorkflow model
   */
  readonly fields: ApprovalWorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalWorkflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalWorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flyer<T extends FlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerDefaultArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalWorkflow model
   */ 
  interface ApprovalWorkflowFieldRefs {
    readonly id: FieldRef<"ApprovalWorkflow", 'String'>
    readonly flyerId: FieldRef<"ApprovalWorkflow", 'String'>
    readonly requiredApprovers: FieldRef<"ApprovalWorkflow", 'Int'>
    readonly currentApprovals: FieldRef<"ApprovalWorkflow", 'Int'>
    readonly isComplete: FieldRef<"ApprovalWorkflow", 'Boolean'>
    readonly createdAt: FieldRef<"ApprovalWorkflow", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalWorkflow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalWorkflow findUnique
   */
  export type ApprovalWorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow findUniqueOrThrow
   */
  export type ApprovalWorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow findFirst
   */
  export type ApprovalWorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalWorkflows.
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalWorkflows.
     */
    distinct?: ApprovalWorkflowScalarFieldEnum | ApprovalWorkflowScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow findFirstOrThrow
   */
  export type ApprovalWorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflow to fetch.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalWorkflows.
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalWorkflows.
     */
    distinct?: ApprovalWorkflowScalarFieldEnum | ApprovalWorkflowScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow findMany
   */
  export type ApprovalWorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalWorkflows to fetch.
     */
    where?: ApprovalWorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalWorkflows to fetch.
     */
    orderBy?: ApprovalWorkflowOrderByWithRelationInput | ApprovalWorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalWorkflows.
     */
    cursor?: ApprovalWorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalWorkflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalWorkflows.
     */
    skip?: number
    distinct?: ApprovalWorkflowScalarFieldEnum | ApprovalWorkflowScalarFieldEnum[]
  }

  /**
   * ApprovalWorkflow create
   */
  export type ApprovalWorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalWorkflow.
     */
    data: XOR<ApprovalWorkflowCreateInput, ApprovalWorkflowUncheckedCreateInput>
  }

  /**
   * ApprovalWorkflow createMany
   */
  export type ApprovalWorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalWorkflows.
     */
    data: ApprovalWorkflowCreateManyInput | ApprovalWorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalWorkflow createManyAndReturn
   */
  export type ApprovalWorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ApprovalWorkflows.
     */
    data: ApprovalWorkflowCreateManyInput | ApprovalWorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalWorkflow update
   */
  export type ApprovalWorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalWorkflow.
     */
    data: XOR<ApprovalWorkflowUpdateInput, ApprovalWorkflowUncheckedUpdateInput>
    /**
     * Choose, which ApprovalWorkflow to update.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow updateMany
   */
  export type ApprovalWorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalWorkflows.
     */
    data: XOR<ApprovalWorkflowUpdateManyMutationInput, ApprovalWorkflowUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalWorkflows to update
     */
    where?: ApprovalWorkflowWhereInput
  }

  /**
   * ApprovalWorkflow upsert
   */
  export type ApprovalWorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalWorkflow to update in case it exists.
     */
    where: ApprovalWorkflowWhereUniqueInput
    /**
     * In case the ApprovalWorkflow found by the `where` argument doesn't exist, create a new ApprovalWorkflow with this data.
     */
    create: XOR<ApprovalWorkflowCreateInput, ApprovalWorkflowUncheckedCreateInput>
    /**
     * In case the ApprovalWorkflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalWorkflowUpdateInput, ApprovalWorkflowUncheckedUpdateInput>
  }

  /**
   * ApprovalWorkflow delete
   */
  export type ApprovalWorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
    /**
     * Filter which ApprovalWorkflow to delete.
     */
    where: ApprovalWorkflowWhereUniqueInput
  }

  /**
   * ApprovalWorkflow deleteMany
   */
  export type ApprovalWorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalWorkflows to delete
     */
    where?: ApprovalWorkflowWhereInput
  }

  /**
   * ApprovalWorkflow without action
   */
  export type ApprovalWorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalWorkflow
     */
    select?: ApprovalWorkflowSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalWorkflowInclude<ExtArgs> | null
  }


  /**
   * Model FlyerVersion
   */

  export type AggregateFlyerVersion = {
    _count: FlyerVersionCountAggregateOutputType | null
    _avg: FlyerVersionAvgAggregateOutputType | null
    _sum: FlyerVersionSumAggregateOutputType | null
    _min: FlyerVersionMinAggregateOutputType | null
    _max: FlyerVersionMaxAggregateOutputType | null
  }

  export type FlyerVersionAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type FlyerVersionSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type FlyerVersionMinAggregateOutputType = {
    id: string | null
    flyerId: string | null
    versionNumber: number | null
    createdBy: string | null
    changeDescription: string | null
    createdAt: Date | null
  }

  export type FlyerVersionMaxAggregateOutputType = {
    id: string | null
    flyerId: string | null
    versionNumber: number | null
    createdBy: string | null
    changeDescription: string | null
    createdAt: Date | null
  }

  export type FlyerVersionCountAggregateOutputType = {
    id: number
    flyerId: number
    versionNumber: number
    snapshotData: number
    createdBy: number
    changeDescription: number
    createdAt: number
    _all: number
  }


  export type FlyerVersionAvgAggregateInputType = {
    versionNumber?: true
  }

  export type FlyerVersionSumAggregateInputType = {
    versionNumber?: true
  }

  export type FlyerVersionMinAggregateInputType = {
    id?: true
    flyerId?: true
    versionNumber?: true
    createdBy?: true
    changeDescription?: true
    createdAt?: true
  }

  export type FlyerVersionMaxAggregateInputType = {
    id?: true
    flyerId?: true
    versionNumber?: true
    createdBy?: true
    changeDescription?: true
    createdAt?: true
  }

  export type FlyerVersionCountAggregateInputType = {
    id?: true
    flyerId?: true
    versionNumber?: true
    snapshotData?: true
    createdBy?: true
    changeDescription?: true
    createdAt?: true
    _all?: true
  }

  export type FlyerVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerVersion to aggregate.
     */
    where?: FlyerVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerVersions to fetch.
     */
    orderBy?: FlyerVersionOrderByWithRelationInput | FlyerVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlyerVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlyerVersions
    **/
    _count?: true | FlyerVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlyerVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlyerVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlyerVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlyerVersionMaxAggregateInputType
  }

  export type GetFlyerVersionAggregateType<T extends FlyerVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyerVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyerVersion[P]>
      : GetScalarType<T[P], AggregateFlyerVersion[P]>
  }




  export type FlyerVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerVersionWhereInput
    orderBy?: FlyerVersionOrderByWithAggregationInput | FlyerVersionOrderByWithAggregationInput[]
    by: FlyerVersionScalarFieldEnum[] | FlyerVersionScalarFieldEnum
    having?: FlyerVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlyerVersionCountAggregateInputType | true
    _avg?: FlyerVersionAvgAggregateInputType
    _sum?: FlyerVersionSumAggregateInputType
    _min?: FlyerVersionMinAggregateInputType
    _max?: FlyerVersionMaxAggregateInputType
  }

  export type FlyerVersionGroupByOutputType = {
    id: string
    flyerId: string
    versionNumber: number
    snapshotData: JsonValue
    createdBy: string
    changeDescription: string | null
    createdAt: Date
    _count: FlyerVersionCountAggregateOutputType | null
    _avg: FlyerVersionAvgAggregateOutputType | null
    _sum: FlyerVersionSumAggregateOutputType | null
    _min: FlyerVersionMinAggregateOutputType | null
    _max: FlyerVersionMaxAggregateOutputType | null
  }

  type GetFlyerVersionGroupByPayload<T extends FlyerVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlyerVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlyerVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlyerVersionGroupByOutputType[P]>
            : GetScalarType<T[P], FlyerVersionGroupByOutputType[P]>
        }
      >
    >


  export type FlyerVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    createdBy?: boolean
    changeDescription?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyerVersion"]>

  export type FlyerVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    createdBy?: boolean
    changeDescription?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyerVersion"]>

  export type FlyerVersionSelectScalar = {
    id?: boolean
    flyerId?: boolean
    versionNumber?: boolean
    snapshotData?: boolean
    createdBy?: boolean
    changeDescription?: boolean
    createdAt?: boolean
  }

  export type FlyerVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }
  export type FlyerVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }

  export type $FlyerVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlyerVersion"
    objects: {
      flyer: Prisma.$FlyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flyerId: string
      versionNumber: number
      snapshotData: Prisma.JsonValue
      createdBy: string
      changeDescription: string | null
      createdAt: Date
    }, ExtArgs["result"]["flyerVersion"]>
    composites: {}
  }

  type FlyerVersionGetPayload<S extends boolean | null | undefined | FlyerVersionDefaultArgs> = $Result.GetResult<Prisma.$FlyerVersionPayload, S>

  type FlyerVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlyerVersionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlyerVersionCountAggregateInputType | true
    }

  export interface FlyerVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlyerVersion'], meta: { name: 'FlyerVersion' } }
    /**
     * Find zero or one FlyerVersion that matches the filter.
     * @param {FlyerVersionFindUniqueArgs} args - Arguments to find a FlyerVersion
     * @example
     * // Get one FlyerVersion
     * const flyerVersion = await prisma.flyerVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlyerVersionFindUniqueArgs>(args: SelectSubset<T, FlyerVersionFindUniqueArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlyerVersion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlyerVersionFindUniqueOrThrowArgs} args - Arguments to find a FlyerVersion
     * @example
     * // Get one FlyerVersion
     * const flyerVersion = await prisma.flyerVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlyerVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, FlyerVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlyerVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionFindFirstArgs} args - Arguments to find a FlyerVersion
     * @example
     * // Get one FlyerVersion
     * const flyerVersion = await prisma.flyerVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlyerVersionFindFirstArgs>(args?: SelectSubset<T, FlyerVersionFindFirstArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlyerVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionFindFirstOrThrowArgs} args - Arguments to find a FlyerVersion
     * @example
     * // Get one FlyerVersion
     * const flyerVersion = await prisma.flyerVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlyerVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, FlyerVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlyerVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlyerVersions
     * const flyerVersions = await prisma.flyerVersion.findMany()
     * 
     * // Get first 10 FlyerVersions
     * const flyerVersions = await prisma.flyerVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flyerVersionWithIdOnly = await prisma.flyerVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlyerVersionFindManyArgs>(args?: SelectSubset<T, FlyerVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlyerVersion.
     * @param {FlyerVersionCreateArgs} args - Arguments to create a FlyerVersion.
     * @example
     * // Create one FlyerVersion
     * const FlyerVersion = await prisma.flyerVersion.create({
     *   data: {
     *     // ... data to create a FlyerVersion
     *   }
     * })
     * 
     */
    create<T extends FlyerVersionCreateArgs>(args: SelectSubset<T, FlyerVersionCreateArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlyerVersions.
     * @param {FlyerVersionCreateManyArgs} args - Arguments to create many FlyerVersions.
     * @example
     * // Create many FlyerVersions
     * const flyerVersion = await prisma.flyerVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlyerVersionCreateManyArgs>(args?: SelectSubset<T, FlyerVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlyerVersions and returns the data saved in the database.
     * @param {FlyerVersionCreateManyAndReturnArgs} args - Arguments to create many FlyerVersions.
     * @example
     * // Create many FlyerVersions
     * const flyerVersion = await prisma.flyerVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlyerVersions and only return the `id`
     * const flyerVersionWithIdOnly = await prisma.flyerVersion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlyerVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, FlyerVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlyerVersion.
     * @param {FlyerVersionDeleteArgs} args - Arguments to delete one FlyerVersion.
     * @example
     * // Delete one FlyerVersion
     * const FlyerVersion = await prisma.flyerVersion.delete({
     *   where: {
     *     // ... filter to delete one FlyerVersion
     *   }
     * })
     * 
     */
    delete<T extends FlyerVersionDeleteArgs>(args: SelectSubset<T, FlyerVersionDeleteArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlyerVersion.
     * @param {FlyerVersionUpdateArgs} args - Arguments to update one FlyerVersion.
     * @example
     * // Update one FlyerVersion
     * const flyerVersion = await prisma.flyerVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlyerVersionUpdateArgs>(args: SelectSubset<T, FlyerVersionUpdateArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlyerVersions.
     * @param {FlyerVersionDeleteManyArgs} args - Arguments to filter FlyerVersions to delete.
     * @example
     * // Delete a few FlyerVersions
     * const { count } = await prisma.flyerVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlyerVersionDeleteManyArgs>(args?: SelectSubset<T, FlyerVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlyerVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlyerVersions
     * const flyerVersion = await prisma.flyerVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlyerVersionUpdateManyArgs>(args: SelectSubset<T, FlyerVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlyerVersion.
     * @param {FlyerVersionUpsertArgs} args - Arguments to update or create a FlyerVersion.
     * @example
     * // Update or create a FlyerVersion
     * const flyerVersion = await prisma.flyerVersion.upsert({
     *   create: {
     *     // ... data to create a FlyerVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlyerVersion we want to update
     *   }
     * })
     */
    upsert<T extends FlyerVersionUpsertArgs>(args: SelectSubset<T, FlyerVersionUpsertArgs<ExtArgs>>): Prisma__FlyerVersionClient<$Result.GetResult<Prisma.$FlyerVersionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlyerVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionCountArgs} args - Arguments to filter FlyerVersions to count.
     * @example
     * // Count the number of FlyerVersions
     * const count = await prisma.flyerVersion.count({
     *   where: {
     *     // ... the filter for the FlyerVersions we want to count
     *   }
     * })
    **/
    count<T extends FlyerVersionCountArgs>(
      args?: Subset<T, FlyerVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlyerVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlyerVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlyerVersionAggregateArgs>(args: Subset<T, FlyerVersionAggregateArgs>): Prisma.PrismaPromise<GetFlyerVersionAggregateType<T>>

    /**
     * Group by FlyerVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlyerVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlyerVersionGroupByArgs['orderBy'] }
        : { orderBy?: FlyerVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlyerVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyerVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlyerVersion model
   */
  readonly fields: FlyerVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlyerVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlyerVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flyer<T extends FlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerDefaultArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlyerVersion model
   */ 
  interface FlyerVersionFieldRefs {
    readonly id: FieldRef<"FlyerVersion", 'String'>
    readonly flyerId: FieldRef<"FlyerVersion", 'String'>
    readonly versionNumber: FieldRef<"FlyerVersion", 'Int'>
    readonly snapshotData: FieldRef<"FlyerVersion", 'Json'>
    readonly createdBy: FieldRef<"FlyerVersion", 'String'>
    readonly changeDescription: FieldRef<"FlyerVersion", 'String'>
    readonly createdAt: FieldRef<"FlyerVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlyerVersion findUnique
   */
  export type FlyerVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * Filter, which FlyerVersion to fetch.
     */
    where: FlyerVersionWhereUniqueInput
  }

  /**
   * FlyerVersion findUniqueOrThrow
   */
  export type FlyerVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * Filter, which FlyerVersion to fetch.
     */
    where: FlyerVersionWhereUniqueInput
  }

  /**
   * FlyerVersion findFirst
   */
  export type FlyerVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * Filter, which FlyerVersion to fetch.
     */
    where?: FlyerVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerVersions to fetch.
     */
    orderBy?: FlyerVersionOrderByWithRelationInput | FlyerVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerVersions.
     */
    cursor?: FlyerVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerVersions.
     */
    distinct?: FlyerVersionScalarFieldEnum | FlyerVersionScalarFieldEnum[]
  }

  /**
   * FlyerVersion findFirstOrThrow
   */
  export type FlyerVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * Filter, which FlyerVersion to fetch.
     */
    where?: FlyerVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerVersions to fetch.
     */
    orderBy?: FlyerVersionOrderByWithRelationInput | FlyerVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerVersions.
     */
    cursor?: FlyerVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerVersions.
     */
    distinct?: FlyerVersionScalarFieldEnum | FlyerVersionScalarFieldEnum[]
  }

  /**
   * FlyerVersion findMany
   */
  export type FlyerVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * Filter, which FlyerVersions to fetch.
     */
    where?: FlyerVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerVersions to fetch.
     */
    orderBy?: FlyerVersionOrderByWithRelationInput | FlyerVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlyerVersions.
     */
    cursor?: FlyerVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerVersions.
     */
    skip?: number
    distinct?: FlyerVersionScalarFieldEnum | FlyerVersionScalarFieldEnum[]
  }

  /**
   * FlyerVersion create
   */
  export type FlyerVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a FlyerVersion.
     */
    data: XOR<FlyerVersionCreateInput, FlyerVersionUncheckedCreateInput>
  }

  /**
   * FlyerVersion createMany
   */
  export type FlyerVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlyerVersions.
     */
    data: FlyerVersionCreateManyInput | FlyerVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlyerVersion createManyAndReturn
   */
  export type FlyerVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlyerVersions.
     */
    data: FlyerVersionCreateManyInput | FlyerVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlyerVersion update
   */
  export type FlyerVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a FlyerVersion.
     */
    data: XOR<FlyerVersionUpdateInput, FlyerVersionUncheckedUpdateInput>
    /**
     * Choose, which FlyerVersion to update.
     */
    where: FlyerVersionWhereUniqueInput
  }

  /**
   * FlyerVersion updateMany
   */
  export type FlyerVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlyerVersions.
     */
    data: XOR<FlyerVersionUpdateManyMutationInput, FlyerVersionUncheckedUpdateManyInput>
    /**
     * Filter which FlyerVersions to update
     */
    where?: FlyerVersionWhereInput
  }

  /**
   * FlyerVersion upsert
   */
  export type FlyerVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the FlyerVersion to update in case it exists.
     */
    where: FlyerVersionWhereUniqueInput
    /**
     * In case the FlyerVersion found by the `where` argument doesn't exist, create a new FlyerVersion with this data.
     */
    create: XOR<FlyerVersionCreateInput, FlyerVersionUncheckedCreateInput>
    /**
     * In case the FlyerVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlyerVersionUpdateInput, FlyerVersionUncheckedUpdateInput>
  }

  /**
   * FlyerVersion delete
   */
  export type FlyerVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
    /**
     * Filter which FlyerVersion to delete.
     */
    where: FlyerVersionWhereUniqueInput
  }

  /**
   * FlyerVersion deleteMany
   */
  export type FlyerVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerVersions to delete
     */
    where?: FlyerVersionWhereInput
  }

  /**
   * FlyerVersion without action
   */
  export type FlyerVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerVersion
     */
    select?: FlyerVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerVersionInclude<ExtArgs> | null
  }


  /**
   * Model FlyerEditHistory
   */

  export type AggregateFlyerEditHistory = {
    _count: FlyerEditHistoryCountAggregateOutputType | null
    _min: FlyerEditHistoryMinAggregateOutputType | null
    _max: FlyerEditHistoryMaxAggregateOutputType | null
  }

  export type FlyerEditHistoryMinAggregateOutputType = {
    id: string | null
    flyerId: string | null
    userId: string | null
    actionType: $Enums.FlyerActionType | null
    createdAt: Date | null
  }

  export type FlyerEditHistoryMaxAggregateOutputType = {
    id: string | null
    flyerId: string | null
    userId: string | null
    actionType: $Enums.FlyerActionType | null
    createdAt: Date | null
  }

  export type FlyerEditHistoryCountAggregateOutputType = {
    id: number
    flyerId: number
    userId: number
    actionType: number
    details: number
    createdAt: number
    _all: number
  }


  export type FlyerEditHistoryMinAggregateInputType = {
    id?: true
    flyerId?: true
    userId?: true
    actionType?: true
    createdAt?: true
  }

  export type FlyerEditHistoryMaxAggregateInputType = {
    id?: true
    flyerId?: true
    userId?: true
    actionType?: true
    createdAt?: true
  }

  export type FlyerEditHistoryCountAggregateInputType = {
    id?: true
    flyerId?: true
    userId?: true
    actionType?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type FlyerEditHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerEditHistory to aggregate.
     */
    where?: FlyerEditHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerEditHistories to fetch.
     */
    orderBy?: FlyerEditHistoryOrderByWithRelationInput | FlyerEditHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlyerEditHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerEditHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerEditHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlyerEditHistories
    **/
    _count?: true | FlyerEditHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlyerEditHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlyerEditHistoryMaxAggregateInputType
  }

  export type GetFlyerEditHistoryAggregateType<T extends FlyerEditHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyerEditHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyerEditHistory[P]>
      : GetScalarType<T[P], AggregateFlyerEditHistory[P]>
  }




  export type FlyerEditHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlyerEditHistoryWhereInput
    orderBy?: FlyerEditHistoryOrderByWithAggregationInput | FlyerEditHistoryOrderByWithAggregationInput[]
    by: FlyerEditHistoryScalarFieldEnum[] | FlyerEditHistoryScalarFieldEnum
    having?: FlyerEditHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlyerEditHistoryCountAggregateInputType | true
    _min?: FlyerEditHistoryMinAggregateInputType
    _max?: FlyerEditHistoryMaxAggregateInputType
  }

  export type FlyerEditHistoryGroupByOutputType = {
    id: string
    flyerId: string
    userId: string
    actionType: $Enums.FlyerActionType
    details: JsonValue | null
    createdAt: Date
    _count: FlyerEditHistoryCountAggregateOutputType | null
    _min: FlyerEditHistoryMinAggregateOutputType | null
    _max: FlyerEditHistoryMaxAggregateOutputType | null
  }

  type GetFlyerEditHistoryGroupByPayload<T extends FlyerEditHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlyerEditHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlyerEditHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlyerEditHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], FlyerEditHistoryGroupByOutputType[P]>
        }
      >
    >


  export type FlyerEditHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    userId?: boolean
    actionType?: boolean
    details?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyerEditHistory"]>

  export type FlyerEditHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flyerId?: boolean
    userId?: boolean
    actionType?: boolean
    details?: boolean
    createdAt?: boolean
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flyerEditHistory"]>

  export type FlyerEditHistorySelectScalar = {
    id?: boolean
    flyerId?: boolean
    userId?: boolean
    actionType?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type FlyerEditHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }
  export type FlyerEditHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flyer?: boolean | FlyerDefaultArgs<ExtArgs>
  }

  export type $FlyerEditHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlyerEditHistory"
    objects: {
      flyer: Prisma.$FlyerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flyerId: string
      userId: string
      actionType: $Enums.FlyerActionType
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["flyerEditHistory"]>
    composites: {}
  }

  type FlyerEditHistoryGetPayload<S extends boolean | null | undefined | FlyerEditHistoryDefaultArgs> = $Result.GetResult<Prisma.$FlyerEditHistoryPayload, S>

  type FlyerEditHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlyerEditHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlyerEditHistoryCountAggregateInputType | true
    }

  export interface FlyerEditHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlyerEditHistory'], meta: { name: 'FlyerEditHistory' } }
    /**
     * Find zero or one FlyerEditHistory that matches the filter.
     * @param {FlyerEditHistoryFindUniqueArgs} args - Arguments to find a FlyerEditHistory
     * @example
     * // Get one FlyerEditHistory
     * const flyerEditHistory = await prisma.flyerEditHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlyerEditHistoryFindUniqueArgs>(args: SelectSubset<T, FlyerEditHistoryFindUniqueArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FlyerEditHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlyerEditHistoryFindUniqueOrThrowArgs} args - Arguments to find a FlyerEditHistory
     * @example
     * // Get one FlyerEditHistory
     * const flyerEditHistory = await prisma.flyerEditHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlyerEditHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FlyerEditHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FlyerEditHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryFindFirstArgs} args - Arguments to find a FlyerEditHistory
     * @example
     * // Get one FlyerEditHistory
     * const flyerEditHistory = await prisma.flyerEditHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlyerEditHistoryFindFirstArgs>(args?: SelectSubset<T, FlyerEditHistoryFindFirstArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FlyerEditHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryFindFirstOrThrowArgs} args - Arguments to find a FlyerEditHistory
     * @example
     * // Get one FlyerEditHistory
     * const flyerEditHistory = await prisma.flyerEditHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlyerEditHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FlyerEditHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FlyerEditHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlyerEditHistories
     * const flyerEditHistories = await prisma.flyerEditHistory.findMany()
     * 
     * // Get first 10 FlyerEditHistories
     * const flyerEditHistories = await prisma.flyerEditHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flyerEditHistoryWithIdOnly = await prisma.flyerEditHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlyerEditHistoryFindManyArgs>(args?: SelectSubset<T, FlyerEditHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FlyerEditHistory.
     * @param {FlyerEditHistoryCreateArgs} args - Arguments to create a FlyerEditHistory.
     * @example
     * // Create one FlyerEditHistory
     * const FlyerEditHistory = await prisma.flyerEditHistory.create({
     *   data: {
     *     // ... data to create a FlyerEditHistory
     *   }
     * })
     * 
     */
    create<T extends FlyerEditHistoryCreateArgs>(args: SelectSubset<T, FlyerEditHistoryCreateArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FlyerEditHistories.
     * @param {FlyerEditHistoryCreateManyArgs} args - Arguments to create many FlyerEditHistories.
     * @example
     * // Create many FlyerEditHistories
     * const flyerEditHistory = await prisma.flyerEditHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlyerEditHistoryCreateManyArgs>(args?: SelectSubset<T, FlyerEditHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlyerEditHistories and returns the data saved in the database.
     * @param {FlyerEditHistoryCreateManyAndReturnArgs} args - Arguments to create many FlyerEditHistories.
     * @example
     * // Create many FlyerEditHistories
     * const flyerEditHistory = await prisma.flyerEditHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlyerEditHistories and only return the `id`
     * const flyerEditHistoryWithIdOnly = await prisma.flyerEditHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlyerEditHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, FlyerEditHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FlyerEditHistory.
     * @param {FlyerEditHistoryDeleteArgs} args - Arguments to delete one FlyerEditHistory.
     * @example
     * // Delete one FlyerEditHistory
     * const FlyerEditHistory = await prisma.flyerEditHistory.delete({
     *   where: {
     *     // ... filter to delete one FlyerEditHistory
     *   }
     * })
     * 
     */
    delete<T extends FlyerEditHistoryDeleteArgs>(args: SelectSubset<T, FlyerEditHistoryDeleteArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FlyerEditHistory.
     * @param {FlyerEditHistoryUpdateArgs} args - Arguments to update one FlyerEditHistory.
     * @example
     * // Update one FlyerEditHistory
     * const flyerEditHistory = await prisma.flyerEditHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlyerEditHistoryUpdateArgs>(args: SelectSubset<T, FlyerEditHistoryUpdateArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FlyerEditHistories.
     * @param {FlyerEditHistoryDeleteManyArgs} args - Arguments to filter FlyerEditHistories to delete.
     * @example
     * // Delete a few FlyerEditHistories
     * const { count } = await prisma.flyerEditHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlyerEditHistoryDeleteManyArgs>(args?: SelectSubset<T, FlyerEditHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlyerEditHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlyerEditHistories
     * const flyerEditHistory = await prisma.flyerEditHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlyerEditHistoryUpdateManyArgs>(args: SelectSubset<T, FlyerEditHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FlyerEditHistory.
     * @param {FlyerEditHistoryUpsertArgs} args - Arguments to update or create a FlyerEditHistory.
     * @example
     * // Update or create a FlyerEditHistory
     * const flyerEditHistory = await prisma.flyerEditHistory.upsert({
     *   create: {
     *     // ... data to create a FlyerEditHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlyerEditHistory we want to update
     *   }
     * })
     */
    upsert<T extends FlyerEditHistoryUpsertArgs>(args: SelectSubset<T, FlyerEditHistoryUpsertArgs<ExtArgs>>): Prisma__FlyerEditHistoryClient<$Result.GetResult<Prisma.$FlyerEditHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FlyerEditHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryCountArgs} args - Arguments to filter FlyerEditHistories to count.
     * @example
     * // Count the number of FlyerEditHistories
     * const count = await prisma.flyerEditHistory.count({
     *   where: {
     *     // ... the filter for the FlyerEditHistories we want to count
     *   }
     * })
    **/
    count<T extends FlyerEditHistoryCountArgs>(
      args?: Subset<T, FlyerEditHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlyerEditHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlyerEditHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlyerEditHistoryAggregateArgs>(args: Subset<T, FlyerEditHistoryAggregateArgs>): Prisma.PrismaPromise<GetFlyerEditHistoryAggregateType<T>>

    /**
     * Group by FlyerEditHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlyerEditHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlyerEditHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlyerEditHistoryGroupByArgs['orderBy'] }
        : { orderBy?: FlyerEditHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlyerEditHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyerEditHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlyerEditHistory model
   */
  readonly fields: FlyerEditHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlyerEditHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlyerEditHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    flyer<T extends FlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FlyerDefaultArgs<ExtArgs>>): Prisma__FlyerClient<$Result.GetResult<Prisma.$FlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlyerEditHistory model
   */ 
  interface FlyerEditHistoryFieldRefs {
    readonly id: FieldRef<"FlyerEditHistory", 'String'>
    readonly flyerId: FieldRef<"FlyerEditHistory", 'String'>
    readonly userId: FieldRef<"FlyerEditHistory", 'String'>
    readonly actionType: FieldRef<"FlyerEditHistory", 'FlyerActionType'>
    readonly details: FieldRef<"FlyerEditHistory", 'Json'>
    readonly createdAt: FieldRef<"FlyerEditHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlyerEditHistory findUnique
   */
  export type FlyerEditHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FlyerEditHistory to fetch.
     */
    where: FlyerEditHistoryWhereUniqueInput
  }

  /**
   * FlyerEditHistory findUniqueOrThrow
   */
  export type FlyerEditHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FlyerEditHistory to fetch.
     */
    where: FlyerEditHistoryWhereUniqueInput
  }

  /**
   * FlyerEditHistory findFirst
   */
  export type FlyerEditHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FlyerEditHistory to fetch.
     */
    where?: FlyerEditHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerEditHistories to fetch.
     */
    orderBy?: FlyerEditHistoryOrderByWithRelationInput | FlyerEditHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerEditHistories.
     */
    cursor?: FlyerEditHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerEditHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerEditHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerEditHistories.
     */
    distinct?: FlyerEditHistoryScalarFieldEnum | FlyerEditHistoryScalarFieldEnum[]
  }

  /**
   * FlyerEditHistory findFirstOrThrow
   */
  export type FlyerEditHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FlyerEditHistory to fetch.
     */
    where?: FlyerEditHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerEditHistories to fetch.
     */
    orderBy?: FlyerEditHistoryOrderByWithRelationInput | FlyerEditHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlyerEditHistories.
     */
    cursor?: FlyerEditHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerEditHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerEditHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlyerEditHistories.
     */
    distinct?: FlyerEditHistoryScalarFieldEnum | FlyerEditHistoryScalarFieldEnum[]
  }

  /**
   * FlyerEditHistory findMany
   */
  export type FlyerEditHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * Filter, which FlyerEditHistories to fetch.
     */
    where?: FlyerEditHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlyerEditHistories to fetch.
     */
    orderBy?: FlyerEditHistoryOrderByWithRelationInput | FlyerEditHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlyerEditHistories.
     */
    cursor?: FlyerEditHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlyerEditHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlyerEditHistories.
     */
    skip?: number
    distinct?: FlyerEditHistoryScalarFieldEnum | FlyerEditHistoryScalarFieldEnum[]
  }

  /**
   * FlyerEditHistory create
   */
  export type FlyerEditHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FlyerEditHistory.
     */
    data: XOR<FlyerEditHistoryCreateInput, FlyerEditHistoryUncheckedCreateInput>
  }

  /**
   * FlyerEditHistory createMany
   */
  export type FlyerEditHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlyerEditHistories.
     */
    data: FlyerEditHistoryCreateManyInput | FlyerEditHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlyerEditHistory createManyAndReturn
   */
  export type FlyerEditHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FlyerEditHistories.
     */
    data: FlyerEditHistoryCreateManyInput | FlyerEditHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlyerEditHistory update
   */
  export type FlyerEditHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FlyerEditHistory.
     */
    data: XOR<FlyerEditHistoryUpdateInput, FlyerEditHistoryUncheckedUpdateInput>
    /**
     * Choose, which FlyerEditHistory to update.
     */
    where: FlyerEditHistoryWhereUniqueInput
  }

  /**
   * FlyerEditHistory updateMany
   */
  export type FlyerEditHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlyerEditHistories.
     */
    data: XOR<FlyerEditHistoryUpdateManyMutationInput, FlyerEditHistoryUncheckedUpdateManyInput>
    /**
     * Filter which FlyerEditHistories to update
     */
    where?: FlyerEditHistoryWhereInput
  }

  /**
   * FlyerEditHistory upsert
   */
  export type FlyerEditHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FlyerEditHistory to update in case it exists.
     */
    where: FlyerEditHistoryWhereUniqueInput
    /**
     * In case the FlyerEditHistory found by the `where` argument doesn't exist, create a new FlyerEditHistory with this data.
     */
    create: XOR<FlyerEditHistoryCreateInput, FlyerEditHistoryUncheckedCreateInput>
    /**
     * In case the FlyerEditHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlyerEditHistoryUpdateInput, FlyerEditHistoryUncheckedUpdateInput>
  }

  /**
   * FlyerEditHistory delete
   */
  export type FlyerEditHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
    /**
     * Filter which FlyerEditHistory to delete.
     */
    where: FlyerEditHistoryWhereUniqueInput
  }

  /**
   * FlyerEditHistory deleteMany
   */
  export type FlyerEditHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlyerEditHistories to delete
     */
    where?: FlyerEditHistoryWhereInput
  }

  /**
   * FlyerEditHistory without action
   */
  export type FlyerEditHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlyerEditHistory
     */
    select?: FlyerEditHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlyerEditHistoryInclude<ExtArgs> | null
  }


  /**
   * Model UserFlyer
   */

  export type AggregateUserFlyer = {
    _count: UserFlyerCountAggregateOutputType | null
    _avg: UserFlyerAvgAggregateOutputType | null
    _sum: UserFlyerSumAggregateOutputType | null
    _min: UserFlyerMinAggregateOutputType | null
    _max: UserFlyerMaxAggregateOutputType | null
  }

  export type UserFlyerAvgAggregateOutputType = {
    completionPercentage: number | null
  }

  export type UserFlyerSumAggregateOutputType = {
    completionPercentage: number | null
  }

  export type UserFlyerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    isDraft: boolean | null
    lastEditedAt: Date | null
    completionPercentage: number | null
    pdfData: Buffer | null
    pdfMimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFlyerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    isDraft: boolean | null
    lastEditedAt: Date | null
    completionPercentage: number | null
    pdfData: Buffer | null
    pdfMimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserFlyerCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    isDraft: number
    lastEditedAt: number
    completionPercentage: number
    pdfData: number
    pdfMimeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserFlyerAvgAggregateInputType = {
    completionPercentage?: true
  }

  export type UserFlyerSumAggregateInputType = {
    completionPercentage?: true
  }

  export type UserFlyerMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isDraft?: true
    lastEditedAt?: true
    completionPercentage?: true
    pdfData?: true
    pdfMimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFlyerMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isDraft?: true
    lastEditedAt?: true
    completionPercentage?: true
    pdfData?: true
    pdfMimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserFlyerCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    isDraft?: true
    lastEditedAt?: true
    completionPercentage?: true
    pdfData?: true
    pdfMimeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserFlyerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFlyer to aggregate.
     */
    where?: UserFlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyers to fetch.
     */
    orderBy?: UserFlyerOrderByWithRelationInput | UserFlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFlyers
    **/
    _count?: true | UserFlyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFlyerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFlyerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFlyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFlyerMaxAggregateInputType
  }

  export type GetUserFlyerAggregateType<T extends UserFlyerAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFlyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFlyer[P]>
      : GetScalarType<T[P], AggregateUserFlyer[P]>
  }




  export type UserFlyerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerWhereInput
    orderBy?: UserFlyerOrderByWithAggregationInput | UserFlyerOrderByWithAggregationInput[]
    by: UserFlyerScalarFieldEnum[] | UserFlyerScalarFieldEnum
    having?: UserFlyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFlyerCountAggregateInputType | true
    _avg?: UserFlyerAvgAggregateInputType
    _sum?: UserFlyerSumAggregateInputType
    _min?: UserFlyerMinAggregateInputType
    _max?: UserFlyerMaxAggregateInputType
  }

  export type UserFlyerGroupByOutputType = {
    id: string
    userId: string
    name: string
    isDraft: boolean
    lastEditedAt: Date
    completionPercentage: number
    pdfData: Buffer | null
    pdfMimeType: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserFlyerCountAggregateOutputType | null
    _avg: UserFlyerAvgAggregateOutputType | null
    _sum: UserFlyerSumAggregateOutputType | null
    _min: UserFlyerMinAggregateOutputType | null
    _max: UserFlyerMaxAggregateOutputType | null
  }

  type GetUserFlyerGroupByPayload<T extends UserFlyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFlyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFlyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFlyerGroupByOutputType[P]>
            : GetScalarType<T[P], UserFlyerGroupByOutputType[P]>
        }
      >
    >


  export type UserFlyerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isDraft?: boolean
    lastEditedAt?: boolean
    completionPercentage?: boolean
    pdfData?: boolean
    pdfMimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    pages?: boolean | UserFlyer$pagesArgs<ExtArgs>
    _count?: boolean | UserFlyerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFlyer"]>

  export type UserFlyerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    isDraft?: boolean
    lastEditedAt?: boolean
    completionPercentage?: boolean
    pdfData?: boolean
    pdfMimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFlyer"]>

  export type UserFlyerSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    isDraft?: boolean
    lastEditedAt?: boolean
    completionPercentage?: boolean
    pdfData?: boolean
    pdfMimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserFlyerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    pages?: boolean | UserFlyer$pagesArgs<ExtArgs>
    _count?: boolean | UserFlyerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserFlyerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserFlyerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFlyer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      pages: Prisma.$UserFlyerPagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      isDraft: boolean
      lastEditedAt: Date
      completionPercentage: number
      pdfData: Buffer | null
      pdfMimeType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userFlyer"]>
    composites: {}
  }

  type UserFlyerGetPayload<S extends boolean | null | undefined | UserFlyerDefaultArgs> = $Result.GetResult<Prisma.$UserFlyerPayload, S>

  type UserFlyerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFlyerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserFlyerCountAggregateInputType | true
    }

  export interface UserFlyerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFlyer'], meta: { name: 'UserFlyer' } }
    /**
     * Find zero or one UserFlyer that matches the filter.
     * @param {UserFlyerFindUniqueArgs} args - Arguments to find a UserFlyer
     * @example
     * // Get one UserFlyer
     * const userFlyer = await prisma.userFlyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFlyerFindUniqueArgs>(args: SelectSubset<T, UserFlyerFindUniqueArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserFlyer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFlyerFindUniqueOrThrowArgs} args - Arguments to find a UserFlyer
     * @example
     * // Get one UserFlyer
     * const userFlyer = await prisma.userFlyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFlyerFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFlyerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserFlyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerFindFirstArgs} args - Arguments to find a UserFlyer
     * @example
     * // Get one UserFlyer
     * const userFlyer = await prisma.userFlyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFlyerFindFirstArgs>(args?: SelectSubset<T, UserFlyerFindFirstArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserFlyer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerFindFirstOrThrowArgs} args - Arguments to find a UserFlyer
     * @example
     * // Get one UserFlyer
     * const userFlyer = await prisma.userFlyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFlyerFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFlyerFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserFlyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFlyers
     * const userFlyers = await prisma.userFlyer.findMany()
     * 
     * // Get first 10 UserFlyers
     * const userFlyers = await prisma.userFlyer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFlyerWithIdOnly = await prisma.userFlyer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFlyerFindManyArgs>(args?: SelectSubset<T, UserFlyerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserFlyer.
     * @param {UserFlyerCreateArgs} args - Arguments to create a UserFlyer.
     * @example
     * // Create one UserFlyer
     * const UserFlyer = await prisma.userFlyer.create({
     *   data: {
     *     // ... data to create a UserFlyer
     *   }
     * })
     * 
     */
    create<T extends UserFlyerCreateArgs>(args: SelectSubset<T, UserFlyerCreateArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserFlyers.
     * @param {UserFlyerCreateManyArgs} args - Arguments to create many UserFlyers.
     * @example
     * // Create many UserFlyers
     * const userFlyer = await prisma.userFlyer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFlyerCreateManyArgs>(args?: SelectSubset<T, UserFlyerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFlyers and returns the data saved in the database.
     * @param {UserFlyerCreateManyAndReturnArgs} args - Arguments to create many UserFlyers.
     * @example
     * // Create many UserFlyers
     * const userFlyer = await prisma.userFlyer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFlyers and only return the `id`
     * const userFlyerWithIdOnly = await prisma.userFlyer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFlyerCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFlyerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserFlyer.
     * @param {UserFlyerDeleteArgs} args - Arguments to delete one UserFlyer.
     * @example
     * // Delete one UserFlyer
     * const UserFlyer = await prisma.userFlyer.delete({
     *   where: {
     *     // ... filter to delete one UserFlyer
     *   }
     * })
     * 
     */
    delete<T extends UserFlyerDeleteArgs>(args: SelectSubset<T, UserFlyerDeleteArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserFlyer.
     * @param {UserFlyerUpdateArgs} args - Arguments to update one UserFlyer.
     * @example
     * // Update one UserFlyer
     * const userFlyer = await prisma.userFlyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFlyerUpdateArgs>(args: SelectSubset<T, UserFlyerUpdateArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserFlyers.
     * @param {UserFlyerDeleteManyArgs} args - Arguments to filter UserFlyers to delete.
     * @example
     * // Delete a few UserFlyers
     * const { count } = await prisma.userFlyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFlyerDeleteManyArgs>(args?: SelectSubset<T, UserFlyerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFlyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFlyers
     * const userFlyer = await prisma.userFlyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFlyerUpdateManyArgs>(args: SelectSubset<T, UserFlyerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFlyer.
     * @param {UserFlyerUpsertArgs} args - Arguments to update or create a UserFlyer.
     * @example
     * // Update or create a UserFlyer
     * const userFlyer = await prisma.userFlyer.upsert({
     *   create: {
     *     // ... data to create a UserFlyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFlyer we want to update
     *   }
     * })
     */
    upsert<T extends UserFlyerUpsertArgs>(args: SelectSubset<T, UserFlyerUpsertArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserFlyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerCountArgs} args - Arguments to filter UserFlyers to count.
     * @example
     * // Count the number of UserFlyers
     * const count = await prisma.userFlyer.count({
     *   where: {
     *     // ... the filter for the UserFlyers we want to count
     *   }
     * })
    **/
    count<T extends UserFlyerCountArgs>(
      args?: Subset<T, UserFlyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFlyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFlyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFlyerAggregateArgs>(args: Subset<T, UserFlyerAggregateArgs>): Prisma.PrismaPromise<GetUserFlyerAggregateType<T>>

    /**
     * Group by UserFlyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFlyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFlyerGroupByArgs['orderBy'] }
        : { orderBy?: UserFlyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFlyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFlyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFlyer model
   */
  readonly fields: UserFlyerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFlyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFlyerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pages<T extends UserFlyer$pagesArgs<ExtArgs> = {}>(args?: Subset<T, UserFlyer$pagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFlyer model
   */ 
  interface UserFlyerFieldRefs {
    readonly id: FieldRef<"UserFlyer", 'String'>
    readonly userId: FieldRef<"UserFlyer", 'String'>
    readonly name: FieldRef<"UserFlyer", 'String'>
    readonly isDraft: FieldRef<"UserFlyer", 'Boolean'>
    readonly lastEditedAt: FieldRef<"UserFlyer", 'DateTime'>
    readonly completionPercentage: FieldRef<"UserFlyer", 'Int'>
    readonly pdfData: FieldRef<"UserFlyer", 'Bytes'>
    readonly pdfMimeType: FieldRef<"UserFlyer", 'String'>
    readonly createdAt: FieldRef<"UserFlyer", 'DateTime'>
    readonly updatedAt: FieldRef<"UserFlyer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserFlyer findUnique
   */
  export type UserFlyerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyer to fetch.
     */
    where: UserFlyerWhereUniqueInput
  }

  /**
   * UserFlyer findUniqueOrThrow
   */
  export type UserFlyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyer to fetch.
     */
    where: UserFlyerWhereUniqueInput
  }

  /**
   * UserFlyer findFirst
   */
  export type UserFlyerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyer to fetch.
     */
    where?: UserFlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyers to fetch.
     */
    orderBy?: UserFlyerOrderByWithRelationInput | UserFlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFlyers.
     */
    cursor?: UserFlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFlyers.
     */
    distinct?: UserFlyerScalarFieldEnum | UserFlyerScalarFieldEnum[]
  }

  /**
   * UserFlyer findFirstOrThrow
   */
  export type UserFlyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyer to fetch.
     */
    where?: UserFlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyers to fetch.
     */
    orderBy?: UserFlyerOrderByWithRelationInput | UserFlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFlyers.
     */
    cursor?: UserFlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFlyers.
     */
    distinct?: UserFlyerScalarFieldEnum | UserFlyerScalarFieldEnum[]
  }

  /**
   * UserFlyer findMany
   */
  export type UserFlyerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyers to fetch.
     */
    where?: UserFlyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyers to fetch.
     */
    orderBy?: UserFlyerOrderByWithRelationInput | UserFlyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFlyers.
     */
    cursor?: UserFlyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyers.
     */
    skip?: number
    distinct?: UserFlyerScalarFieldEnum | UserFlyerScalarFieldEnum[]
  }

  /**
   * UserFlyer create
   */
  export type UserFlyerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFlyer.
     */
    data: XOR<UserFlyerCreateInput, UserFlyerUncheckedCreateInput>
  }

  /**
   * UserFlyer createMany
   */
  export type UserFlyerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFlyers.
     */
    data: UserFlyerCreateManyInput | UserFlyerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFlyer createManyAndReturn
   */
  export type UserFlyerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserFlyers.
     */
    data: UserFlyerCreateManyInput | UserFlyerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFlyer update
   */
  export type UserFlyerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFlyer.
     */
    data: XOR<UserFlyerUpdateInput, UserFlyerUncheckedUpdateInput>
    /**
     * Choose, which UserFlyer to update.
     */
    where: UserFlyerWhereUniqueInput
  }

  /**
   * UserFlyer updateMany
   */
  export type UserFlyerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFlyers.
     */
    data: XOR<UserFlyerUpdateManyMutationInput, UserFlyerUncheckedUpdateManyInput>
    /**
     * Filter which UserFlyers to update
     */
    where?: UserFlyerWhereInput
  }

  /**
   * UserFlyer upsert
   */
  export type UserFlyerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFlyer to update in case it exists.
     */
    where: UserFlyerWhereUniqueInput
    /**
     * In case the UserFlyer found by the `where` argument doesn't exist, create a new UserFlyer with this data.
     */
    create: XOR<UserFlyerCreateInput, UserFlyerUncheckedCreateInput>
    /**
     * In case the UserFlyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFlyerUpdateInput, UserFlyerUncheckedUpdateInput>
  }

  /**
   * UserFlyer delete
   */
  export type UserFlyerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
    /**
     * Filter which UserFlyer to delete.
     */
    where: UserFlyerWhereUniqueInput
  }

  /**
   * UserFlyer deleteMany
   */
  export type UserFlyerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFlyers to delete
     */
    where?: UserFlyerWhereInput
  }

  /**
   * UserFlyer.pages
   */
  export type UserFlyer$pagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    where?: UserFlyerPageWhereInput
    orderBy?: UserFlyerPageOrderByWithRelationInput | UserFlyerPageOrderByWithRelationInput[]
    cursor?: UserFlyerPageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFlyerPageScalarFieldEnum | UserFlyerPageScalarFieldEnum[]
  }

  /**
   * UserFlyer without action
   */
  export type UserFlyerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyer
     */
    select?: UserFlyerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerInclude<ExtArgs> | null
  }


  /**
   * Model UserFlyerPage
   */

  export type AggregateUserFlyerPage = {
    _count: UserFlyerPageCountAggregateOutputType | null
    _avg: UserFlyerPageAvgAggregateOutputType | null
    _sum: UserFlyerPageSumAggregateOutputType | null
    _min: UserFlyerPageMinAggregateOutputType | null
    _max: UserFlyerPageMaxAggregateOutputType | null
  }

  export type UserFlyerPageAvgAggregateOutputType = {
    pageNumber: number | null
  }

  export type UserFlyerPageSumAggregateOutputType = {
    pageNumber: number | null
  }

  export type UserFlyerPageMinAggregateOutputType = {
    id: string | null
    userFlyerId: string | null
    pageNumber: number | null
  }

  export type UserFlyerPageMaxAggregateOutputType = {
    id: string | null
    userFlyerId: string | null
    pageNumber: number | null
  }

  export type UserFlyerPageCountAggregateOutputType = {
    id: number
    userFlyerId: number
    pageNumber: number
    _all: number
  }


  export type UserFlyerPageAvgAggregateInputType = {
    pageNumber?: true
  }

  export type UserFlyerPageSumAggregateInputType = {
    pageNumber?: true
  }

  export type UserFlyerPageMinAggregateInputType = {
    id?: true
    userFlyerId?: true
    pageNumber?: true
  }

  export type UserFlyerPageMaxAggregateInputType = {
    id?: true
    userFlyerId?: true
    pageNumber?: true
  }

  export type UserFlyerPageCountAggregateInputType = {
    id?: true
    userFlyerId?: true
    pageNumber?: true
    _all?: true
  }

  export type UserFlyerPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFlyerPage to aggregate.
     */
    where?: UserFlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPages to fetch.
     */
    orderBy?: UserFlyerPageOrderByWithRelationInput | UserFlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFlyerPages
    **/
    _count?: true | UserFlyerPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFlyerPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFlyerPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFlyerPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFlyerPageMaxAggregateInputType
  }

  export type GetUserFlyerPageAggregateType<T extends UserFlyerPageAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFlyerPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFlyerPage[P]>
      : GetScalarType<T[P], AggregateUserFlyerPage[P]>
  }




  export type UserFlyerPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerPageWhereInput
    orderBy?: UserFlyerPageOrderByWithAggregationInput | UserFlyerPageOrderByWithAggregationInput[]
    by: UserFlyerPageScalarFieldEnum[] | UserFlyerPageScalarFieldEnum
    having?: UserFlyerPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFlyerPageCountAggregateInputType | true
    _avg?: UserFlyerPageAvgAggregateInputType
    _sum?: UserFlyerPageSumAggregateInputType
    _min?: UserFlyerPageMinAggregateInputType
    _max?: UserFlyerPageMaxAggregateInputType
  }

  export type UserFlyerPageGroupByOutputType = {
    id: string
    userFlyerId: string
    pageNumber: number
    _count: UserFlyerPageCountAggregateOutputType | null
    _avg: UserFlyerPageAvgAggregateOutputType | null
    _sum: UserFlyerPageSumAggregateOutputType | null
    _min: UserFlyerPageMinAggregateOutputType | null
    _max: UserFlyerPageMaxAggregateOutputType | null
  }

  type GetUserFlyerPageGroupByPayload<T extends UserFlyerPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFlyerPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFlyerPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFlyerPageGroupByOutputType[P]>
            : GetScalarType<T[P], UserFlyerPageGroupByOutputType[P]>
        }
      >
    >


  export type UserFlyerPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userFlyerId?: boolean
    pageNumber?: boolean
    userFlyer?: boolean | UserFlyerDefaultArgs<ExtArgs>
    products?: boolean | UserFlyerPage$productsArgs<ExtArgs>
    _count?: boolean | UserFlyerPageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFlyerPage"]>

  export type UserFlyerPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userFlyerId?: boolean
    pageNumber?: boolean
    userFlyer?: boolean | UserFlyerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFlyerPage"]>

  export type UserFlyerPageSelectScalar = {
    id?: boolean
    userFlyerId?: boolean
    pageNumber?: boolean
  }

  export type UserFlyerPageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFlyer?: boolean | UserFlyerDefaultArgs<ExtArgs>
    products?: boolean | UserFlyerPage$productsArgs<ExtArgs>
    _count?: boolean | UserFlyerPageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserFlyerPageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userFlyer?: boolean | UserFlyerDefaultArgs<ExtArgs>
  }

  export type $UserFlyerPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFlyerPage"
    objects: {
      userFlyer: Prisma.$UserFlyerPayload<ExtArgs>
      products: Prisma.$UserFlyerPageProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userFlyerId: string
      pageNumber: number
    }, ExtArgs["result"]["userFlyerPage"]>
    composites: {}
  }

  type UserFlyerPageGetPayload<S extends boolean | null | undefined | UserFlyerPageDefaultArgs> = $Result.GetResult<Prisma.$UserFlyerPagePayload, S>

  type UserFlyerPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFlyerPageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserFlyerPageCountAggregateInputType | true
    }

  export interface UserFlyerPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFlyerPage'], meta: { name: 'UserFlyerPage' } }
    /**
     * Find zero or one UserFlyerPage that matches the filter.
     * @param {UserFlyerPageFindUniqueArgs} args - Arguments to find a UserFlyerPage
     * @example
     * // Get one UserFlyerPage
     * const userFlyerPage = await prisma.userFlyerPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFlyerPageFindUniqueArgs>(args: SelectSubset<T, UserFlyerPageFindUniqueArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserFlyerPage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFlyerPageFindUniqueOrThrowArgs} args - Arguments to find a UserFlyerPage
     * @example
     * // Get one UserFlyerPage
     * const userFlyerPage = await prisma.userFlyerPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFlyerPageFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFlyerPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserFlyerPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageFindFirstArgs} args - Arguments to find a UserFlyerPage
     * @example
     * // Get one UserFlyerPage
     * const userFlyerPage = await prisma.userFlyerPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFlyerPageFindFirstArgs>(args?: SelectSubset<T, UserFlyerPageFindFirstArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserFlyerPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageFindFirstOrThrowArgs} args - Arguments to find a UserFlyerPage
     * @example
     * // Get one UserFlyerPage
     * const userFlyerPage = await prisma.userFlyerPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFlyerPageFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFlyerPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserFlyerPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFlyerPages
     * const userFlyerPages = await prisma.userFlyerPage.findMany()
     * 
     * // Get first 10 UserFlyerPages
     * const userFlyerPages = await prisma.userFlyerPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFlyerPageWithIdOnly = await prisma.userFlyerPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFlyerPageFindManyArgs>(args?: SelectSubset<T, UserFlyerPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserFlyerPage.
     * @param {UserFlyerPageCreateArgs} args - Arguments to create a UserFlyerPage.
     * @example
     * // Create one UserFlyerPage
     * const UserFlyerPage = await prisma.userFlyerPage.create({
     *   data: {
     *     // ... data to create a UserFlyerPage
     *   }
     * })
     * 
     */
    create<T extends UserFlyerPageCreateArgs>(args: SelectSubset<T, UserFlyerPageCreateArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserFlyerPages.
     * @param {UserFlyerPageCreateManyArgs} args - Arguments to create many UserFlyerPages.
     * @example
     * // Create many UserFlyerPages
     * const userFlyerPage = await prisma.userFlyerPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFlyerPageCreateManyArgs>(args?: SelectSubset<T, UserFlyerPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFlyerPages and returns the data saved in the database.
     * @param {UserFlyerPageCreateManyAndReturnArgs} args - Arguments to create many UserFlyerPages.
     * @example
     * // Create many UserFlyerPages
     * const userFlyerPage = await prisma.userFlyerPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFlyerPages and only return the `id`
     * const userFlyerPageWithIdOnly = await prisma.userFlyerPage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFlyerPageCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFlyerPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserFlyerPage.
     * @param {UserFlyerPageDeleteArgs} args - Arguments to delete one UserFlyerPage.
     * @example
     * // Delete one UserFlyerPage
     * const UserFlyerPage = await prisma.userFlyerPage.delete({
     *   where: {
     *     // ... filter to delete one UserFlyerPage
     *   }
     * })
     * 
     */
    delete<T extends UserFlyerPageDeleteArgs>(args: SelectSubset<T, UserFlyerPageDeleteArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserFlyerPage.
     * @param {UserFlyerPageUpdateArgs} args - Arguments to update one UserFlyerPage.
     * @example
     * // Update one UserFlyerPage
     * const userFlyerPage = await prisma.userFlyerPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFlyerPageUpdateArgs>(args: SelectSubset<T, UserFlyerPageUpdateArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserFlyerPages.
     * @param {UserFlyerPageDeleteManyArgs} args - Arguments to filter UserFlyerPages to delete.
     * @example
     * // Delete a few UserFlyerPages
     * const { count } = await prisma.userFlyerPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFlyerPageDeleteManyArgs>(args?: SelectSubset<T, UserFlyerPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFlyerPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFlyerPages
     * const userFlyerPage = await prisma.userFlyerPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFlyerPageUpdateManyArgs>(args: SelectSubset<T, UserFlyerPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFlyerPage.
     * @param {UserFlyerPageUpsertArgs} args - Arguments to update or create a UserFlyerPage.
     * @example
     * // Update or create a UserFlyerPage
     * const userFlyerPage = await prisma.userFlyerPage.upsert({
     *   create: {
     *     // ... data to create a UserFlyerPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFlyerPage we want to update
     *   }
     * })
     */
    upsert<T extends UserFlyerPageUpsertArgs>(args: SelectSubset<T, UserFlyerPageUpsertArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserFlyerPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageCountArgs} args - Arguments to filter UserFlyerPages to count.
     * @example
     * // Count the number of UserFlyerPages
     * const count = await prisma.userFlyerPage.count({
     *   where: {
     *     // ... the filter for the UserFlyerPages we want to count
     *   }
     * })
    **/
    count<T extends UserFlyerPageCountArgs>(
      args?: Subset<T, UserFlyerPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFlyerPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFlyerPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFlyerPageAggregateArgs>(args: Subset<T, UserFlyerPageAggregateArgs>): Prisma.PrismaPromise<GetUserFlyerPageAggregateType<T>>

    /**
     * Group by UserFlyerPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFlyerPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFlyerPageGroupByArgs['orderBy'] }
        : { orderBy?: UserFlyerPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFlyerPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFlyerPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFlyerPage model
   */
  readonly fields: UserFlyerPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFlyerPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFlyerPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userFlyer<T extends UserFlyerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFlyerDefaultArgs<ExtArgs>>): Prisma__UserFlyerClient<$Result.GetResult<Prisma.$UserFlyerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    products<T extends UserFlyerPage$productsArgs<ExtArgs> = {}>(args?: Subset<T, UserFlyerPage$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFlyerPage model
   */ 
  interface UserFlyerPageFieldRefs {
    readonly id: FieldRef<"UserFlyerPage", 'String'>
    readonly userFlyerId: FieldRef<"UserFlyerPage", 'String'>
    readonly pageNumber: FieldRef<"UserFlyerPage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserFlyerPage findUnique
   */
  export type UserFlyerPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPage to fetch.
     */
    where: UserFlyerPageWhereUniqueInput
  }

  /**
   * UserFlyerPage findUniqueOrThrow
   */
  export type UserFlyerPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPage to fetch.
     */
    where: UserFlyerPageWhereUniqueInput
  }

  /**
   * UserFlyerPage findFirst
   */
  export type UserFlyerPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPage to fetch.
     */
    where?: UserFlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPages to fetch.
     */
    orderBy?: UserFlyerPageOrderByWithRelationInput | UserFlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFlyerPages.
     */
    cursor?: UserFlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFlyerPages.
     */
    distinct?: UserFlyerPageScalarFieldEnum | UserFlyerPageScalarFieldEnum[]
  }

  /**
   * UserFlyerPage findFirstOrThrow
   */
  export type UserFlyerPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPage to fetch.
     */
    where?: UserFlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPages to fetch.
     */
    orderBy?: UserFlyerPageOrderByWithRelationInput | UserFlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFlyerPages.
     */
    cursor?: UserFlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFlyerPages.
     */
    distinct?: UserFlyerPageScalarFieldEnum | UserFlyerPageScalarFieldEnum[]
  }

  /**
   * UserFlyerPage findMany
   */
  export type UserFlyerPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPages to fetch.
     */
    where?: UserFlyerPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPages to fetch.
     */
    orderBy?: UserFlyerPageOrderByWithRelationInput | UserFlyerPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFlyerPages.
     */
    cursor?: UserFlyerPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPages.
     */
    skip?: number
    distinct?: UserFlyerPageScalarFieldEnum | UserFlyerPageScalarFieldEnum[]
  }

  /**
   * UserFlyerPage create
   */
  export type UserFlyerPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFlyerPage.
     */
    data: XOR<UserFlyerPageCreateInput, UserFlyerPageUncheckedCreateInput>
  }

  /**
   * UserFlyerPage createMany
   */
  export type UserFlyerPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFlyerPages.
     */
    data: UserFlyerPageCreateManyInput | UserFlyerPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFlyerPage createManyAndReturn
   */
  export type UserFlyerPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserFlyerPages.
     */
    data: UserFlyerPageCreateManyInput | UserFlyerPageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFlyerPage update
   */
  export type UserFlyerPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFlyerPage.
     */
    data: XOR<UserFlyerPageUpdateInput, UserFlyerPageUncheckedUpdateInput>
    /**
     * Choose, which UserFlyerPage to update.
     */
    where: UserFlyerPageWhereUniqueInput
  }

  /**
   * UserFlyerPage updateMany
   */
  export type UserFlyerPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFlyerPages.
     */
    data: XOR<UserFlyerPageUpdateManyMutationInput, UserFlyerPageUncheckedUpdateManyInput>
    /**
     * Filter which UserFlyerPages to update
     */
    where?: UserFlyerPageWhereInput
  }

  /**
   * UserFlyerPage upsert
   */
  export type UserFlyerPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFlyerPage to update in case it exists.
     */
    where: UserFlyerPageWhereUniqueInput
    /**
     * In case the UserFlyerPage found by the `where` argument doesn't exist, create a new UserFlyerPage with this data.
     */
    create: XOR<UserFlyerPageCreateInput, UserFlyerPageUncheckedCreateInput>
    /**
     * In case the UserFlyerPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFlyerPageUpdateInput, UserFlyerPageUncheckedUpdateInput>
  }

  /**
   * UserFlyerPage delete
   */
  export type UserFlyerPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
    /**
     * Filter which UserFlyerPage to delete.
     */
    where: UserFlyerPageWhereUniqueInput
  }

  /**
   * UserFlyerPage deleteMany
   */
  export type UserFlyerPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFlyerPages to delete
     */
    where?: UserFlyerPageWhereInput
  }

  /**
   * UserFlyerPage.products
   */
  export type UserFlyerPage$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    where?: UserFlyerPageProductWhereInput
    orderBy?: UserFlyerPageProductOrderByWithRelationInput | UserFlyerPageProductOrderByWithRelationInput[]
    cursor?: UserFlyerPageProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserFlyerPageProductScalarFieldEnum | UserFlyerPageProductScalarFieldEnum[]
  }

  /**
   * UserFlyerPage without action
   */
  export type UserFlyerPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPage
     */
    select?: UserFlyerPageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageInclude<ExtArgs> | null
  }


  /**
   * Model UserFlyerPageProduct
   */

  export type AggregateUserFlyerPageProduct = {
    _count: UserFlyerPageProductCountAggregateOutputType | null
    _avg: UserFlyerPageProductAvgAggregateOutputType | null
    _sum: UserFlyerPageProductSumAggregateOutputType | null
    _min: UserFlyerPageProductMinAggregateOutputType | null
    _max: UserFlyerPageProductMaxAggregateOutputType | null
  }

  export type UserFlyerPageProductAvgAggregateOutputType = {
    position: number | null
  }

  export type UserFlyerPageProductSumAggregateOutputType = {
    position: number | null
  }

  export type UserFlyerPageProductMinAggregateOutputType = {
    id: string | null
    pageId: string | null
    productId: string | null
    position: number | null
  }

  export type UserFlyerPageProductMaxAggregateOutputType = {
    id: string | null
    pageId: string | null
    productId: string | null
    position: number | null
  }

  export type UserFlyerPageProductCountAggregateOutputType = {
    id: number
    pageId: number
    productId: number
    position: number
    _all: number
  }


  export type UserFlyerPageProductAvgAggregateInputType = {
    position?: true
  }

  export type UserFlyerPageProductSumAggregateInputType = {
    position?: true
  }

  export type UserFlyerPageProductMinAggregateInputType = {
    id?: true
    pageId?: true
    productId?: true
    position?: true
  }

  export type UserFlyerPageProductMaxAggregateInputType = {
    id?: true
    pageId?: true
    productId?: true
    position?: true
  }

  export type UserFlyerPageProductCountAggregateInputType = {
    id?: true
    pageId?: true
    productId?: true
    position?: true
    _all?: true
  }

  export type UserFlyerPageProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFlyerPageProduct to aggregate.
     */
    where?: UserFlyerPageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPageProducts to fetch.
     */
    orderBy?: UserFlyerPageProductOrderByWithRelationInput | UserFlyerPageProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserFlyerPageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPageProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPageProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserFlyerPageProducts
    **/
    _count?: true | UserFlyerPageProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserFlyerPageProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserFlyerPageProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserFlyerPageProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserFlyerPageProductMaxAggregateInputType
  }

  export type GetUserFlyerPageProductAggregateType<T extends UserFlyerPageProductAggregateArgs> = {
        [P in keyof T & keyof AggregateUserFlyerPageProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserFlyerPageProduct[P]>
      : GetScalarType<T[P], AggregateUserFlyerPageProduct[P]>
  }




  export type UserFlyerPageProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserFlyerPageProductWhereInput
    orderBy?: UserFlyerPageProductOrderByWithAggregationInput | UserFlyerPageProductOrderByWithAggregationInput[]
    by: UserFlyerPageProductScalarFieldEnum[] | UserFlyerPageProductScalarFieldEnum
    having?: UserFlyerPageProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserFlyerPageProductCountAggregateInputType | true
    _avg?: UserFlyerPageProductAvgAggregateInputType
    _sum?: UserFlyerPageProductSumAggregateInputType
    _min?: UserFlyerPageProductMinAggregateInputType
    _max?: UserFlyerPageProductMaxAggregateInputType
  }

  export type UserFlyerPageProductGroupByOutputType = {
    id: string
    pageId: string
    productId: string
    position: number
    _count: UserFlyerPageProductCountAggregateOutputType | null
    _avg: UserFlyerPageProductAvgAggregateOutputType | null
    _sum: UserFlyerPageProductSumAggregateOutputType | null
    _min: UserFlyerPageProductMinAggregateOutputType | null
    _max: UserFlyerPageProductMaxAggregateOutputType | null
  }

  type GetUserFlyerPageProductGroupByPayload<T extends UserFlyerPageProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserFlyerPageProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserFlyerPageProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserFlyerPageProductGroupByOutputType[P]>
            : GetScalarType<T[P], UserFlyerPageProductGroupByOutputType[P]>
        }
      >
    >


  export type UserFlyerPageProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    productId?: boolean
    position?: boolean
    page?: boolean | UserFlyerPageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFlyerPageProduct"]>

  export type UserFlyerPageProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pageId?: boolean
    productId?: boolean
    position?: boolean
    page?: boolean | UserFlyerPageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userFlyerPageProduct"]>

  export type UserFlyerPageProductSelectScalar = {
    id?: boolean
    pageId?: boolean
    productId?: boolean
    position?: boolean
  }

  export type UserFlyerPageProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | UserFlyerPageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type UserFlyerPageProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    page?: boolean | UserFlyerPageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $UserFlyerPageProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserFlyerPageProduct"
    objects: {
      page: Prisma.$UserFlyerPagePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pageId: string
      productId: string
      position: number
    }, ExtArgs["result"]["userFlyerPageProduct"]>
    composites: {}
  }

  type UserFlyerPageProductGetPayload<S extends boolean | null | undefined | UserFlyerPageProductDefaultArgs> = $Result.GetResult<Prisma.$UserFlyerPageProductPayload, S>

  type UserFlyerPageProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFlyerPageProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserFlyerPageProductCountAggregateInputType | true
    }

  export interface UserFlyerPageProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserFlyerPageProduct'], meta: { name: 'UserFlyerPageProduct' } }
    /**
     * Find zero or one UserFlyerPageProduct that matches the filter.
     * @param {UserFlyerPageProductFindUniqueArgs} args - Arguments to find a UserFlyerPageProduct
     * @example
     * // Get one UserFlyerPageProduct
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFlyerPageProductFindUniqueArgs>(args: SelectSubset<T, UserFlyerPageProductFindUniqueArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserFlyerPageProduct that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFlyerPageProductFindUniqueOrThrowArgs} args - Arguments to find a UserFlyerPageProduct
     * @example
     * // Get one UserFlyerPageProduct
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFlyerPageProductFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFlyerPageProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserFlyerPageProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductFindFirstArgs} args - Arguments to find a UserFlyerPageProduct
     * @example
     * // Get one UserFlyerPageProduct
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFlyerPageProductFindFirstArgs>(args?: SelectSubset<T, UserFlyerPageProductFindFirstArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserFlyerPageProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductFindFirstOrThrowArgs} args - Arguments to find a UserFlyerPageProduct
     * @example
     * // Get one UserFlyerPageProduct
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFlyerPageProductFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFlyerPageProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserFlyerPageProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserFlyerPageProducts
     * const userFlyerPageProducts = await prisma.userFlyerPageProduct.findMany()
     * 
     * // Get first 10 UserFlyerPageProducts
     * const userFlyerPageProducts = await prisma.userFlyerPageProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userFlyerPageProductWithIdOnly = await prisma.userFlyerPageProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFlyerPageProductFindManyArgs>(args?: SelectSubset<T, UserFlyerPageProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserFlyerPageProduct.
     * @param {UserFlyerPageProductCreateArgs} args - Arguments to create a UserFlyerPageProduct.
     * @example
     * // Create one UserFlyerPageProduct
     * const UserFlyerPageProduct = await prisma.userFlyerPageProduct.create({
     *   data: {
     *     // ... data to create a UserFlyerPageProduct
     *   }
     * })
     * 
     */
    create<T extends UserFlyerPageProductCreateArgs>(args: SelectSubset<T, UserFlyerPageProductCreateArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserFlyerPageProducts.
     * @param {UserFlyerPageProductCreateManyArgs} args - Arguments to create many UserFlyerPageProducts.
     * @example
     * // Create many UserFlyerPageProducts
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserFlyerPageProductCreateManyArgs>(args?: SelectSubset<T, UserFlyerPageProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserFlyerPageProducts and returns the data saved in the database.
     * @param {UserFlyerPageProductCreateManyAndReturnArgs} args - Arguments to create many UserFlyerPageProducts.
     * @example
     * // Create many UserFlyerPageProducts
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserFlyerPageProducts and only return the `id`
     * const userFlyerPageProductWithIdOnly = await prisma.userFlyerPageProduct.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserFlyerPageProductCreateManyAndReturnArgs>(args?: SelectSubset<T, UserFlyerPageProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserFlyerPageProduct.
     * @param {UserFlyerPageProductDeleteArgs} args - Arguments to delete one UserFlyerPageProduct.
     * @example
     * // Delete one UserFlyerPageProduct
     * const UserFlyerPageProduct = await prisma.userFlyerPageProduct.delete({
     *   where: {
     *     // ... filter to delete one UserFlyerPageProduct
     *   }
     * })
     * 
     */
    delete<T extends UserFlyerPageProductDeleteArgs>(args: SelectSubset<T, UserFlyerPageProductDeleteArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserFlyerPageProduct.
     * @param {UserFlyerPageProductUpdateArgs} args - Arguments to update one UserFlyerPageProduct.
     * @example
     * // Update one UserFlyerPageProduct
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserFlyerPageProductUpdateArgs>(args: SelectSubset<T, UserFlyerPageProductUpdateArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserFlyerPageProducts.
     * @param {UserFlyerPageProductDeleteManyArgs} args - Arguments to filter UserFlyerPageProducts to delete.
     * @example
     * // Delete a few UserFlyerPageProducts
     * const { count } = await prisma.userFlyerPageProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserFlyerPageProductDeleteManyArgs>(args?: SelectSubset<T, UserFlyerPageProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserFlyerPageProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserFlyerPageProducts
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserFlyerPageProductUpdateManyArgs>(args: SelectSubset<T, UserFlyerPageProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserFlyerPageProduct.
     * @param {UserFlyerPageProductUpsertArgs} args - Arguments to update or create a UserFlyerPageProduct.
     * @example
     * // Update or create a UserFlyerPageProduct
     * const userFlyerPageProduct = await prisma.userFlyerPageProduct.upsert({
     *   create: {
     *     // ... data to create a UserFlyerPageProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserFlyerPageProduct we want to update
     *   }
     * })
     */
    upsert<T extends UserFlyerPageProductUpsertArgs>(args: SelectSubset<T, UserFlyerPageProductUpsertArgs<ExtArgs>>): Prisma__UserFlyerPageProductClient<$Result.GetResult<Prisma.$UserFlyerPageProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserFlyerPageProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductCountArgs} args - Arguments to filter UserFlyerPageProducts to count.
     * @example
     * // Count the number of UserFlyerPageProducts
     * const count = await prisma.userFlyerPageProduct.count({
     *   where: {
     *     // ... the filter for the UserFlyerPageProducts we want to count
     *   }
     * })
    **/
    count<T extends UserFlyerPageProductCountArgs>(
      args?: Subset<T, UserFlyerPageProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserFlyerPageProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserFlyerPageProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserFlyerPageProductAggregateArgs>(args: Subset<T, UserFlyerPageProductAggregateArgs>): Prisma.PrismaPromise<GetUserFlyerPageProductAggregateType<T>>

    /**
     * Group by UserFlyerPageProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFlyerPageProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserFlyerPageProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserFlyerPageProductGroupByArgs['orderBy'] }
        : { orderBy?: UserFlyerPageProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserFlyerPageProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserFlyerPageProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserFlyerPageProduct model
   */
  readonly fields: UserFlyerPageProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserFlyerPageProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserFlyerPageProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    page<T extends UserFlyerPageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserFlyerPageDefaultArgs<ExtArgs>>): Prisma__UserFlyerPageClient<$Result.GetResult<Prisma.$UserFlyerPagePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserFlyerPageProduct model
   */ 
  interface UserFlyerPageProductFieldRefs {
    readonly id: FieldRef<"UserFlyerPageProduct", 'String'>
    readonly pageId: FieldRef<"UserFlyerPageProduct", 'String'>
    readonly productId: FieldRef<"UserFlyerPageProduct", 'String'>
    readonly position: FieldRef<"UserFlyerPageProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserFlyerPageProduct findUnique
   */
  export type UserFlyerPageProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPageProduct to fetch.
     */
    where: UserFlyerPageProductWhereUniqueInput
  }

  /**
   * UserFlyerPageProduct findUniqueOrThrow
   */
  export type UserFlyerPageProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPageProduct to fetch.
     */
    where: UserFlyerPageProductWhereUniqueInput
  }

  /**
   * UserFlyerPageProduct findFirst
   */
  export type UserFlyerPageProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPageProduct to fetch.
     */
    where?: UserFlyerPageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPageProducts to fetch.
     */
    orderBy?: UserFlyerPageProductOrderByWithRelationInput | UserFlyerPageProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFlyerPageProducts.
     */
    cursor?: UserFlyerPageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPageProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPageProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFlyerPageProducts.
     */
    distinct?: UserFlyerPageProductScalarFieldEnum | UserFlyerPageProductScalarFieldEnum[]
  }

  /**
   * UserFlyerPageProduct findFirstOrThrow
   */
  export type UserFlyerPageProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPageProduct to fetch.
     */
    where?: UserFlyerPageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPageProducts to fetch.
     */
    orderBy?: UserFlyerPageProductOrderByWithRelationInput | UserFlyerPageProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserFlyerPageProducts.
     */
    cursor?: UserFlyerPageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPageProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPageProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserFlyerPageProducts.
     */
    distinct?: UserFlyerPageProductScalarFieldEnum | UserFlyerPageProductScalarFieldEnum[]
  }

  /**
   * UserFlyerPageProduct findMany
   */
  export type UserFlyerPageProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * Filter, which UserFlyerPageProducts to fetch.
     */
    where?: UserFlyerPageProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserFlyerPageProducts to fetch.
     */
    orderBy?: UserFlyerPageProductOrderByWithRelationInput | UserFlyerPageProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserFlyerPageProducts.
     */
    cursor?: UserFlyerPageProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserFlyerPageProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserFlyerPageProducts.
     */
    skip?: number
    distinct?: UserFlyerPageProductScalarFieldEnum | UserFlyerPageProductScalarFieldEnum[]
  }

  /**
   * UserFlyerPageProduct create
   */
  export type UserFlyerPageProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * The data needed to create a UserFlyerPageProduct.
     */
    data: XOR<UserFlyerPageProductCreateInput, UserFlyerPageProductUncheckedCreateInput>
  }

  /**
   * UserFlyerPageProduct createMany
   */
  export type UserFlyerPageProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserFlyerPageProducts.
     */
    data: UserFlyerPageProductCreateManyInput | UserFlyerPageProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserFlyerPageProduct createManyAndReturn
   */
  export type UserFlyerPageProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserFlyerPageProducts.
     */
    data: UserFlyerPageProductCreateManyInput | UserFlyerPageProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserFlyerPageProduct update
   */
  export type UserFlyerPageProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * The data needed to update a UserFlyerPageProduct.
     */
    data: XOR<UserFlyerPageProductUpdateInput, UserFlyerPageProductUncheckedUpdateInput>
    /**
     * Choose, which UserFlyerPageProduct to update.
     */
    where: UserFlyerPageProductWhereUniqueInput
  }

  /**
   * UserFlyerPageProduct updateMany
   */
  export type UserFlyerPageProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserFlyerPageProducts.
     */
    data: XOR<UserFlyerPageProductUpdateManyMutationInput, UserFlyerPageProductUncheckedUpdateManyInput>
    /**
     * Filter which UserFlyerPageProducts to update
     */
    where?: UserFlyerPageProductWhereInput
  }

  /**
   * UserFlyerPageProduct upsert
   */
  export type UserFlyerPageProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * The filter to search for the UserFlyerPageProduct to update in case it exists.
     */
    where: UserFlyerPageProductWhereUniqueInput
    /**
     * In case the UserFlyerPageProduct found by the `where` argument doesn't exist, create a new UserFlyerPageProduct with this data.
     */
    create: XOR<UserFlyerPageProductCreateInput, UserFlyerPageProductUncheckedCreateInput>
    /**
     * In case the UserFlyerPageProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserFlyerPageProductUpdateInput, UserFlyerPageProductUncheckedUpdateInput>
  }

  /**
   * UserFlyerPageProduct delete
   */
  export type UserFlyerPageProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
    /**
     * Filter which UserFlyerPageProduct to delete.
     */
    where: UserFlyerPageProductWhereUniqueInput
  }

  /**
   * UserFlyerPageProduct deleteMany
   */
  export type UserFlyerPageProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserFlyerPageProducts to delete
     */
    where?: UserFlyerPageProductWhereInput
  }

  /**
   * UserFlyerPageProduct without action
   */
  export type UserFlyerPageProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserFlyerPageProduct
     */
    select?: UserFlyerPageProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserFlyerPageProductInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    ipAddress: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserBrandScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    brandId: 'brandId',
    createdAt: 'createdAt'
  };

  export type UserBrandScalarFieldEnum = (typeof UserBrandScalarFieldEnum)[keyof typeof UserBrandScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    logoData: 'logoData',
    logoMimeType: 'logoMimeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    brandId: 'brandId',
    eanCode: 'eanCode',
    name: 'name',
    description: 'description',
    imageData: 'imageData',
    imageMimeType: 'imageMimeType',
    price: 'price',
    originalPrice: 'originalPrice',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const IconScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageData: 'imageData',
    imageMimeType: 'imageMimeType',
    isEnergyClass: 'isEnergyClass',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IconScalarFieldEnum = (typeof IconScalarFieldEnum)[keyof typeof IconScalarFieldEnum]


  export const ProductIconScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    iconId: 'iconId',
    position: 'position'
  };

  export type ProductIconScalarFieldEnum = (typeof ProductIconScalarFieldEnum)[keyof typeof ProductIconScalarFieldEnum]


  export const PromoImageScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    brandId: 'brandId',
    name: 'name',
    imageData: 'imageData',
    imageMimeType: 'imageMimeType',
    defaultSize: 'defaultSize',
    createdAt: 'createdAt'
  };

  export type PromoImageScalarFieldEnum = (typeof PromoImageScalarFieldEnum)[keyof typeof PromoImageScalarFieldEnum]


  export const FlyerScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    name: 'name',
    validFrom: 'validFrom',
    validTo: 'validTo',
    status: 'status',
    isDraft: 'isDraft',
    rejectionReason: 'rejectionReason',
    pdfData: 'pdfData',
    pdfMimeType: 'pdfMimeType',
    lastEditedAt: 'lastEditedAt',
    autoSaveVersion: 'autoSaveVersion',
    completionPercentage: 'completionPercentage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt'
  };

  export type FlyerScalarFieldEnum = (typeof FlyerScalarFieldEnum)[keyof typeof FlyerScalarFieldEnum]


  export const FlyerPageScalarFieldEnum: {
    id: 'id',
    flyerId: 'flyerId',
    pageNumber: 'pageNumber',
    footerPromoImageId: 'footerPromoImageId'
  };

  export type FlyerPageScalarFieldEnum = (typeof FlyerPageScalarFieldEnum)[keyof typeof FlyerPageScalarFieldEnum]


  export const FlyerPageSlotScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    slotPosition: 'slotPosition',
    slotType: 'slotType',
    productId: 'productId',
    promoImageId: 'promoImageId',
    promoSize: 'promoSize',
    isPromoAnchor: 'isPromoAnchor',
    promoAnchorId: 'promoAnchorId'
  };

  export type FlyerPageSlotScalarFieldEnum = (typeof FlyerPageSlotScalarFieldEnum)[keyof typeof FlyerPageSlotScalarFieldEnum]


  export const VerificationLogScalarFieldEnum: {
    id: 'id',
    flyerId: 'flyerId',
    verificationDate: 'verificationDate',
    status: 'status',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type VerificationLogScalarFieldEnum = (typeof VerificationLogScalarFieldEnum)[keyof typeof VerificationLogScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    id: 'id',
    flyerId: 'flyerId',
    approverId: 'approverId',
    status: 'status',
    comment: 'comment',
    decidedAt: 'decidedAt',
    createdAt: 'createdAt'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const ApprovalWorkflowScalarFieldEnum: {
    id: 'id',
    flyerId: 'flyerId',
    requiredApprovers: 'requiredApprovers',
    currentApprovals: 'currentApprovals',
    isComplete: 'isComplete',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalWorkflowScalarFieldEnum = (typeof ApprovalWorkflowScalarFieldEnum)[keyof typeof ApprovalWorkflowScalarFieldEnum]


  export const FlyerVersionScalarFieldEnum: {
    id: 'id',
    flyerId: 'flyerId',
    versionNumber: 'versionNumber',
    snapshotData: 'snapshotData',
    createdBy: 'createdBy',
    changeDescription: 'changeDescription',
    createdAt: 'createdAt'
  };

  export type FlyerVersionScalarFieldEnum = (typeof FlyerVersionScalarFieldEnum)[keyof typeof FlyerVersionScalarFieldEnum]


  export const FlyerEditHistoryScalarFieldEnum: {
    id: 'id',
    flyerId: 'flyerId',
    userId: 'userId',
    actionType: 'actionType',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type FlyerEditHistoryScalarFieldEnum = (typeof FlyerEditHistoryScalarFieldEnum)[keyof typeof FlyerEditHistoryScalarFieldEnum]


  export const UserFlyerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    isDraft: 'isDraft',
    lastEditedAt: 'lastEditedAt',
    completionPercentage: 'completionPercentage',
    pdfData: 'pdfData',
    pdfMimeType: 'pdfMimeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserFlyerScalarFieldEnum = (typeof UserFlyerScalarFieldEnum)[keyof typeof UserFlyerScalarFieldEnum]


  export const UserFlyerPageScalarFieldEnum: {
    id: 'id',
    userFlyerId: 'userFlyerId',
    pageNumber: 'pageNumber'
  };

  export type UserFlyerPageScalarFieldEnum = (typeof UserFlyerPageScalarFieldEnum)[keyof typeof UserFlyerPageScalarFieldEnum]


  export const UserFlyerPageProductScalarFieldEnum: {
    id: 'id',
    pageId: 'pageId',
    productId: 'productId',
    position: 'position'
  };

  export type UserFlyerPageProductScalarFieldEnum = (typeof UserFlyerPageProductScalarFieldEnum)[keyof typeof UserFlyerPageProductScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PromoSlotSize'
   */
  export type EnumPromoSlotSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromoSlotSize'>
    


  /**
   * Reference to a field of type 'PromoSlotSize[]'
   */
  export type ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromoSlotSize[]'>
    


  /**
   * Reference to a field of type 'FlyerStatus'
   */
  export type EnumFlyerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlyerStatus'>
    


  /**
   * Reference to a field of type 'FlyerStatus[]'
   */
  export type ListEnumFlyerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlyerStatus[]'>
    


  /**
   * Reference to a field of type 'SlotType'
   */
  export type EnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType'>
    


  /**
   * Reference to a field of type 'SlotType[]'
   */
  export type ListEnumSlotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SlotType[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'FlyerActionType'
   */
  export type EnumFlyerActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlyerActionType'>
    


  /**
   * Reference to a field of type 'FlyerActionType[]'
   */
  export type ListEnumFlyerActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlyerActionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    brands?: UserBrandListRelationFilter
    products?: ProductListRelationFilter
    flyers?: FlyerListRelationFilter
    approvals?: ApprovalListRelationFilter
    userFlyers?: UserFlyerListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    brands?: UserBrandOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    flyers?: FlyerOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
    userFlyers?: UserFlyerOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    brands?: UserBrandListRelationFilter
    products?: ProductListRelationFilter
    flyers?: FlyerListRelationFilter
    approvals?: ApprovalListRelationFilter
    userFlyers?: UserFlyerListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserBrandWhereInput = {
    AND?: UserBrandWhereInput | UserBrandWhereInput[]
    OR?: UserBrandWhereInput[]
    NOT?: UserBrandWhereInput | UserBrandWhereInput[]
    id?: StringFilter<"UserBrand"> | string
    userId?: StringFilter<"UserBrand"> | string
    brandId?: StringFilter<"UserBrand"> | string
    createdAt?: DateTimeFilter<"UserBrand"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    brand?: XOR<BrandRelationFilter, BrandWhereInput>
  }

  export type UserBrandOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
  }

  export type UserBrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBrandWhereInput | UserBrandWhereInput[]
    OR?: UserBrandWhereInput[]
    NOT?: UserBrandWhereInput | UserBrandWhereInput[]
    userId?: StringFilter<"UserBrand"> | string
    brandId?: StringFilter<"UserBrand"> | string
    createdAt?: DateTimeFilter<"UserBrand"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    brand?: XOR<BrandRelationFilter, BrandWhereInput>
  }, "id">

  export type UserBrandOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
    _count?: UserBrandCountOrderByAggregateInput
    _max?: UserBrandMaxOrderByAggregateInput
    _min?: UserBrandMinOrderByAggregateInput
  }

  export type UserBrandScalarWhereWithAggregatesInput = {
    AND?: UserBrandScalarWhereWithAggregatesInput | UserBrandScalarWhereWithAggregatesInput[]
    OR?: UserBrandScalarWhereWithAggregatesInput[]
    NOT?: UserBrandScalarWhereWithAggregatesInput | UserBrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBrand"> | string
    userId?: StringWithAggregatesFilter<"UserBrand"> | string
    brandId?: StringWithAggregatesFilter<"UserBrand"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBrand"> | Date | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    logoData?: BytesNullableFilter<"Brand"> | Buffer | null
    logoMimeType?: StringNullableFilter<"Brand"> | string | null
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    users?: UserBrandListRelationFilter
    products?: ProductListRelationFilter
    promoImages?: PromoImageListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    logoData?: SortOrderInput | SortOrder
    logoMimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserBrandOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    promoImages?: PromoImageOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringFilter<"Brand"> | string
    logoData?: BytesNullableFilter<"Brand"> | Buffer | null
    logoMimeType?: StringNullableFilter<"Brand"> | string | null
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    users?: UserBrandListRelationFilter
    products?: ProductListRelationFilter
    promoImages?: PromoImageListRelationFilter
  }, "id">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    logoData?: SortOrderInput | SortOrder
    logoMimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    logoData?: BytesNullableWithAggregatesFilter<"Brand"> | Buffer | null
    logoMimeType?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    supplierId?: StringFilter<"Product"> | string
    brandId?: StringFilter<"Product"> | string
    eanCode?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    imageData?: BytesFilter<"Product"> | Buffer
    imageMimeType?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    supplier?: XOR<UserRelationFilter, UserWhereInput>
    brand?: XOR<BrandRelationFilter, BrandWhereInput>
    icons?: ProductIconListRelationFilter
    flyerPageSlots?: FlyerPageSlotListRelationFilter
    userFlyerPageProducts?: UserFlyerPageProductListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    eanCode?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: UserOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    icons?: ProductIconOrderByRelationAggregateInput
    flyerPageSlots?: FlyerPageSlotOrderByRelationAggregateInput
    userFlyerPageProducts?: UserFlyerPageProductOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eanCode?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    supplierId?: StringFilter<"Product"> | string
    brandId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    imageData?: BytesFilter<"Product"> | Buffer
    imageMimeType?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    supplier?: XOR<UserRelationFilter, UserWhereInput>
    brand?: XOR<BrandRelationFilter, BrandWhereInput>
    icons?: ProductIconListRelationFilter
    flyerPageSlots?: FlyerPageSlotListRelationFilter
    userFlyerPageProducts?: UserFlyerPageProductListRelationFilter
  }, "id" | "eanCode">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    eanCode?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    supplierId?: StringWithAggregatesFilter<"Product"> | string
    brandId?: StringWithAggregatesFilter<"Product"> | string
    eanCode?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageData?: BytesWithAggregatesFilter<"Product"> | Buffer
    imageMimeType?: StringWithAggregatesFilter<"Product"> | string
    price?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type IconWhereInput = {
    AND?: IconWhereInput | IconWhereInput[]
    OR?: IconWhereInput[]
    NOT?: IconWhereInput | IconWhereInput[]
    id?: StringFilter<"Icon"> | string
    name?: StringFilter<"Icon"> | string
    imageData?: BytesFilter<"Icon"> | Buffer
    imageMimeType?: StringFilter<"Icon"> | string
    isEnergyClass?: BoolFilter<"Icon"> | boolean
    createdAt?: DateTimeFilter<"Icon"> | Date | string
    updatedAt?: DateTimeFilter<"Icon"> | Date | string
    productIcons?: ProductIconListRelationFilter
  }

  export type IconOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    isEnergyClass?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    productIcons?: ProductIconOrderByRelationAggregateInput
  }

  export type IconWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IconWhereInput | IconWhereInput[]
    OR?: IconWhereInput[]
    NOT?: IconWhereInput | IconWhereInput[]
    name?: StringFilter<"Icon"> | string
    imageData?: BytesFilter<"Icon"> | Buffer
    imageMimeType?: StringFilter<"Icon"> | string
    isEnergyClass?: BoolFilter<"Icon"> | boolean
    createdAt?: DateTimeFilter<"Icon"> | Date | string
    updatedAt?: DateTimeFilter<"Icon"> | Date | string
    productIcons?: ProductIconListRelationFilter
  }, "id">

  export type IconOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    isEnergyClass?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IconCountOrderByAggregateInput
    _max?: IconMaxOrderByAggregateInput
    _min?: IconMinOrderByAggregateInput
  }

  export type IconScalarWhereWithAggregatesInput = {
    AND?: IconScalarWhereWithAggregatesInput | IconScalarWhereWithAggregatesInput[]
    OR?: IconScalarWhereWithAggregatesInput[]
    NOT?: IconScalarWhereWithAggregatesInput | IconScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Icon"> | string
    name?: StringWithAggregatesFilter<"Icon"> | string
    imageData?: BytesWithAggregatesFilter<"Icon"> | Buffer
    imageMimeType?: StringWithAggregatesFilter<"Icon"> | string
    isEnergyClass?: BoolWithAggregatesFilter<"Icon"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Icon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Icon"> | Date | string
  }

  export type ProductIconWhereInput = {
    AND?: ProductIconWhereInput | ProductIconWhereInput[]
    OR?: ProductIconWhereInput[]
    NOT?: ProductIconWhereInput | ProductIconWhereInput[]
    id?: StringFilter<"ProductIcon"> | string
    productId?: StringFilter<"ProductIcon"> | string
    iconId?: StringFilter<"ProductIcon"> | string
    position?: IntFilter<"ProductIcon"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    icon?: XOR<IconRelationFilter, IconWhereInput>
  }

  export type ProductIconOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    iconId?: SortOrder
    position?: SortOrder
    product?: ProductOrderByWithRelationInput
    icon?: IconOrderByWithRelationInput
  }

  export type ProductIconWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_position?: ProductIconProductIdPositionCompoundUniqueInput
    AND?: ProductIconWhereInput | ProductIconWhereInput[]
    OR?: ProductIconWhereInput[]
    NOT?: ProductIconWhereInput | ProductIconWhereInput[]
    productId?: StringFilter<"ProductIcon"> | string
    iconId?: StringFilter<"ProductIcon"> | string
    position?: IntFilter<"ProductIcon"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    icon?: XOR<IconRelationFilter, IconWhereInput>
  }, "id" | "productId_position">

  export type ProductIconOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    iconId?: SortOrder
    position?: SortOrder
    _count?: ProductIconCountOrderByAggregateInput
    _avg?: ProductIconAvgOrderByAggregateInput
    _max?: ProductIconMaxOrderByAggregateInput
    _min?: ProductIconMinOrderByAggregateInput
    _sum?: ProductIconSumOrderByAggregateInput
  }

  export type ProductIconScalarWhereWithAggregatesInput = {
    AND?: ProductIconScalarWhereWithAggregatesInput | ProductIconScalarWhereWithAggregatesInput[]
    OR?: ProductIconScalarWhereWithAggregatesInput[]
    NOT?: ProductIconScalarWhereWithAggregatesInput | ProductIconScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductIcon"> | string
    productId?: StringWithAggregatesFilter<"ProductIcon"> | string
    iconId?: StringWithAggregatesFilter<"ProductIcon"> | string
    position?: IntWithAggregatesFilter<"ProductIcon"> | number
  }

  export type PromoImageWhereInput = {
    AND?: PromoImageWhereInput | PromoImageWhereInput[]
    OR?: PromoImageWhereInput[]
    NOT?: PromoImageWhereInput | PromoImageWhereInput[]
    id?: StringFilter<"PromoImage"> | string
    supplierId?: StringFilter<"PromoImage"> | string
    brandId?: StringNullableFilter<"PromoImage"> | string | null
    name?: StringFilter<"PromoImage"> | string
    imageData?: BytesFilter<"PromoImage"> | Buffer
    imageMimeType?: StringFilter<"PromoImage"> | string
    defaultSize?: EnumPromoSlotSizeFilter<"PromoImage"> | $Enums.PromoSlotSize
    createdAt?: DateTimeFilter<"PromoImage"> | Date | string
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    flyerPageSlots?: FlyerPageSlotListRelationFilter
    footerPages?: FlyerPageListRelationFilter
  }

  export type PromoImageOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrderInput | SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    defaultSize?: SortOrder
    createdAt?: SortOrder
    brand?: BrandOrderByWithRelationInput
    flyerPageSlots?: FlyerPageSlotOrderByRelationAggregateInput
    footerPages?: FlyerPageOrderByRelationAggregateInput
  }

  export type PromoImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PromoImageWhereInput | PromoImageWhereInput[]
    OR?: PromoImageWhereInput[]
    NOT?: PromoImageWhereInput | PromoImageWhereInput[]
    supplierId?: StringFilter<"PromoImage"> | string
    brandId?: StringNullableFilter<"PromoImage"> | string | null
    name?: StringFilter<"PromoImage"> | string
    imageData?: BytesFilter<"PromoImage"> | Buffer
    imageMimeType?: StringFilter<"PromoImage"> | string
    defaultSize?: EnumPromoSlotSizeFilter<"PromoImage"> | $Enums.PromoSlotSize
    createdAt?: DateTimeFilter<"PromoImage"> | Date | string
    brand?: XOR<BrandNullableRelationFilter, BrandWhereInput> | null
    flyerPageSlots?: FlyerPageSlotListRelationFilter
    footerPages?: FlyerPageListRelationFilter
  }, "id">

  export type PromoImageOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrderInput | SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    defaultSize?: SortOrder
    createdAt?: SortOrder
    _count?: PromoImageCountOrderByAggregateInput
    _max?: PromoImageMaxOrderByAggregateInput
    _min?: PromoImageMinOrderByAggregateInput
  }

  export type PromoImageScalarWhereWithAggregatesInput = {
    AND?: PromoImageScalarWhereWithAggregatesInput | PromoImageScalarWhereWithAggregatesInput[]
    OR?: PromoImageScalarWhereWithAggregatesInput[]
    NOT?: PromoImageScalarWhereWithAggregatesInput | PromoImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PromoImage"> | string
    supplierId?: StringWithAggregatesFilter<"PromoImage"> | string
    brandId?: StringNullableWithAggregatesFilter<"PromoImage"> | string | null
    name?: StringWithAggregatesFilter<"PromoImage"> | string
    imageData?: BytesWithAggregatesFilter<"PromoImage"> | Buffer
    imageMimeType?: StringWithAggregatesFilter<"PromoImage"> | string
    defaultSize?: EnumPromoSlotSizeWithAggregatesFilter<"PromoImage"> | $Enums.PromoSlotSize
    createdAt?: DateTimeWithAggregatesFilter<"PromoImage"> | Date | string
  }

  export type FlyerWhereInput = {
    AND?: FlyerWhereInput | FlyerWhereInput[]
    OR?: FlyerWhereInput[]
    NOT?: FlyerWhereInput | FlyerWhereInput[]
    id?: StringFilter<"Flyer"> | string
    supplierId?: StringFilter<"Flyer"> | string
    name?: StringFilter<"Flyer"> | string
    validFrom?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    validTo?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    status?: EnumFlyerStatusFilter<"Flyer"> | $Enums.FlyerStatus
    isDraft?: BoolFilter<"Flyer"> | boolean
    rejectionReason?: StringNullableFilter<"Flyer"> | string | null
    pdfData?: BytesNullableFilter<"Flyer"> | Buffer | null
    pdfMimeType?: StringNullableFilter<"Flyer"> | string | null
    lastEditedAt?: DateTimeFilter<"Flyer"> | Date | string
    autoSaveVersion?: IntFilter<"Flyer"> | number
    completionPercentage?: IntFilter<"Flyer"> | number
    createdAt?: DateTimeFilter<"Flyer"> | Date | string
    updatedAt?: DateTimeFilter<"Flyer"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    supplier?: XOR<UserRelationFilter, UserWhereInput>
    pages?: FlyerPageListRelationFilter
    verificationLogs?: VerificationLogListRelationFilter
    approvals?: ApprovalListRelationFilter
    approvalWorkflow?: XOR<ApprovalWorkflowNullableRelationFilter, ApprovalWorkflowWhereInput> | null
    versions?: FlyerVersionListRelationFilter
    editHistory?: FlyerEditHistoryListRelationFilter
  }

  export type FlyerOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    name?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validTo?: SortOrderInput | SortOrder
    status?: SortOrder
    isDraft?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    pdfData?: SortOrderInput | SortOrder
    pdfMimeType?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrder
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    supplier?: UserOrderByWithRelationInput
    pages?: FlyerPageOrderByRelationAggregateInput
    verificationLogs?: VerificationLogOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
    approvalWorkflow?: ApprovalWorkflowOrderByWithRelationInput
    versions?: FlyerVersionOrderByRelationAggregateInput
    editHistory?: FlyerEditHistoryOrderByRelationAggregateInput
  }

  export type FlyerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlyerWhereInput | FlyerWhereInput[]
    OR?: FlyerWhereInput[]
    NOT?: FlyerWhereInput | FlyerWhereInput[]
    supplierId?: StringFilter<"Flyer"> | string
    name?: StringFilter<"Flyer"> | string
    validFrom?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    validTo?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    status?: EnumFlyerStatusFilter<"Flyer"> | $Enums.FlyerStatus
    isDraft?: BoolFilter<"Flyer"> | boolean
    rejectionReason?: StringNullableFilter<"Flyer"> | string | null
    pdfData?: BytesNullableFilter<"Flyer"> | Buffer | null
    pdfMimeType?: StringNullableFilter<"Flyer"> | string | null
    lastEditedAt?: DateTimeFilter<"Flyer"> | Date | string
    autoSaveVersion?: IntFilter<"Flyer"> | number
    completionPercentage?: IntFilter<"Flyer"> | number
    createdAt?: DateTimeFilter<"Flyer"> | Date | string
    updatedAt?: DateTimeFilter<"Flyer"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    supplier?: XOR<UserRelationFilter, UserWhereInput>
    pages?: FlyerPageListRelationFilter
    verificationLogs?: VerificationLogListRelationFilter
    approvals?: ApprovalListRelationFilter
    approvalWorkflow?: XOR<ApprovalWorkflowNullableRelationFilter, ApprovalWorkflowWhereInput> | null
    versions?: FlyerVersionListRelationFilter
    editHistory?: FlyerEditHistoryListRelationFilter
  }, "id">

  export type FlyerOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    name?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validTo?: SortOrderInput | SortOrder
    status?: SortOrder
    isDraft?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    pdfData?: SortOrderInput | SortOrder
    pdfMimeType?: SortOrderInput | SortOrder
    lastEditedAt?: SortOrder
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    _count?: FlyerCountOrderByAggregateInput
    _avg?: FlyerAvgOrderByAggregateInput
    _max?: FlyerMaxOrderByAggregateInput
    _min?: FlyerMinOrderByAggregateInput
    _sum?: FlyerSumOrderByAggregateInput
  }

  export type FlyerScalarWhereWithAggregatesInput = {
    AND?: FlyerScalarWhereWithAggregatesInput | FlyerScalarWhereWithAggregatesInput[]
    OR?: FlyerScalarWhereWithAggregatesInput[]
    NOT?: FlyerScalarWhereWithAggregatesInput | FlyerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flyer"> | string
    supplierId?: StringWithAggregatesFilter<"Flyer"> | string
    name?: StringWithAggregatesFilter<"Flyer"> | string
    validFrom?: DateTimeNullableWithAggregatesFilter<"Flyer"> | Date | string | null
    validTo?: DateTimeNullableWithAggregatesFilter<"Flyer"> | Date | string | null
    status?: EnumFlyerStatusWithAggregatesFilter<"Flyer"> | $Enums.FlyerStatus
    isDraft?: BoolWithAggregatesFilter<"Flyer"> | boolean
    rejectionReason?: StringNullableWithAggregatesFilter<"Flyer"> | string | null
    pdfData?: BytesNullableWithAggregatesFilter<"Flyer"> | Buffer | null
    pdfMimeType?: StringNullableWithAggregatesFilter<"Flyer"> | string | null
    lastEditedAt?: DateTimeWithAggregatesFilter<"Flyer"> | Date | string
    autoSaveVersion?: IntWithAggregatesFilter<"Flyer"> | number
    completionPercentage?: IntWithAggregatesFilter<"Flyer"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Flyer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flyer"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Flyer"> | Date | string | null
  }

  export type FlyerPageWhereInput = {
    AND?: FlyerPageWhereInput | FlyerPageWhereInput[]
    OR?: FlyerPageWhereInput[]
    NOT?: FlyerPageWhereInput | FlyerPageWhereInput[]
    id?: StringFilter<"FlyerPage"> | string
    flyerId?: StringFilter<"FlyerPage"> | string
    pageNumber?: IntFilter<"FlyerPage"> | number
    footerPromoImageId?: StringNullableFilter<"FlyerPage"> | string | null
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
    slots?: FlyerPageSlotListRelationFilter
    footerPromoImage?: XOR<PromoImageNullableRelationFilter, PromoImageWhereInput> | null
  }

  export type FlyerPageOrderByWithRelationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    pageNumber?: SortOrder
    footerPromoImageId?: SortOrderInput | SortOrder
    flyer?: FlyerOrderByWithRelationInput
    slots?: FlyerPageSlotOrderByRelationAggregateInput
    footerPromoImage?: PromoImageOrderByWithRelationInput
  }

  export type FlyerPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flyerId_pageNumber?: FlyerPageFlyerIdPageNumberCompoundUniqueInput
    AND?: FlyerPageWhereInput | FlyerPageWhereInput[]
    OR?: FlyerPageWhereInput[]
    NOT?: FlyerPageWhereInput | FlyerPageWhereInput[]
    flyerId?: StringFilter<"FlyerPage"> | string
    pageNumber?: IntFilter<"FlyerPage"> | number
    footerPromoImageId?: StringNullableFilter<"FlyerPage"> | string | null
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
    slots?: FlyerPageSlotListRelationFilter
    footerPromoImage?: XOR<PromoImageNullableRelationFilter, PromoImageWhereInput> | null
  }, "id" | "flyerId_pageNumber">

  export type FlyerPageOrderByWithAggregationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    pageNumber?: SortOrder
    footerPromoImageId?: SortOrderInput | SortOrder
    _count?: FlyerPageCountOrderByAggregateInput
    _avg?: FlyerPageAvgOrderByAggregateInput
    _max?: FlyerPageMaxOrderByAggregateInput
    _min?: FlyerPageMinOrderByAggregateInput
    _sum?: FlyerPageSumOrderByAggregateInput
  }

  export type FlyerPageScalarWhereWithAggregatesInput = {
    AND?: FlyerPageScalarWhereWithAggregatesInput | FlyerPageScalarWhereWithAggregatesInput[]
    OR?: FlyerPageScalarWhereWithAggregatesInput[]
    NOT?: FlyerPageScalarWhereWithAggregatesInput | FlyerPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlyerPage"> | string
    flyerId?: StringWithAggregatesFilter<"FlyerPage"> | string
    pageNumber?: IntWithAggregatesFilter<"FlyerPage"> | number
    footerPromoImageId?: StringNullableWithAggregatesFilter<"FlyerPage"> | string | null
  }

  export type FlyerPageSlotWhereInput = {
    AND?: FlyerPageSlotWhereInput | FlyerPageSlotWhereInput[]
    OR?: FlyerPageSlotWhereInput[]
    NOT?: FlyerPageSlotWhereInput | FlyerPageSlotWhereInput[]
    id?: StringFilter<"FlyerPageSlot"> | string
    pageId?: StringFilter<"FlyerPageSlot"> | string
    slotPosition?: IntFilter<"FlyerPageSlot"> | number
    slotType?: EnumSlotTypeFilter<"FlyerPageSlot"> | $Enums.SlotType
    productId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    promoImageId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    promoSize?: EnumPromoSlotSizeNullableFilter<"FlyerPageSlot"> | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFilter<"FlyerPageSlot"> | boolean
    promoAnchorId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    page?: XOR<FlyerPageRelationFilter, FlyerPageWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    promoImage?: XOR<PromoImageNullableRelationFilter, PromoImageWhereInput> | null
    promoAnchor?: XOR<FlyerPageSlotNullableRelationFilter, FlyerPageSlotWhereInput> | null
    promoSpannedSlots?: FlyerPageSlotListRelationFilter
  }

  export type FlyerPageSlotOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    slotPosition?: SortOrder
    slotType?: SortOrder
    productId?: SortOrderInput | SortOrder
    promoImageId?: SortOrderInput | SortOrder
    promoSize?: SortOrderInput | SortOrder
    isPromoAnchor?: SortOrder
    promoAnchorId?: SortOrderInput | SortOrder
    page?: FlyerPageOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    promoImage?: PromoImageOrderByWithRelationInput
    promoAnchor?: FlyerPageSlotOrderByWithRelationInput
    promoSpannedSlots?: FlyerPageSlotOrderByRelationAggregateInput
  }

  export type FlyerPageSlotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageId_slotPosition?: FlyerPageSlotPageIdSlotPositionCompoundUniqueInput
    AND?: FlyerPageSlotWhereInput | FlyerPageSlotWhereInput[]
    OR?: FlyerPageSlotWhereInput[]
    NOT?: FlyerPageSlotWhereInput | FlyerPageSlotWhereInput[]
    pageId?: StringFilter<"FlyerPageSlot"> | string
    slotPosition?: IntFilter<"FlyerPageSlot"> | number
    slotType?: EnumSlotTypeFilter<"FlyerPageSlot"> | $Enums.SlotType
    productId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    promoImageId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    promoSize?: EnumPromoSlotSizeNullableFilter<"FlyerPageSlot"> | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFilter<"FlyerPageSlot"> | boolean
    promoAnchorId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    page?: XOR<FlyerPageRelationFilter, FlyerPageWhereInput>
    product?: XOR<ProductNullableRelationFilter, ProductWhereInput> | null
    promoImage?: XOR<PromoImageNullableRelationFilter, PromoImageWhereInput> | null
    promoAnchor?: XOR<FlyerPageSlotNullableRelationFilter, FlyerPageSlotWhereInput> | null
    promoSpannedSlots?: FlyerPageSlotListRelationFilter
  }, "id" | "pageId_slotPosition">

  export type FlyerPageSlotOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    slotPosition?: SortOrder
    slotType?: SortOrder
    productId?: SortOrderInput | SortOrder
    promoImageId?: SortOrderInput | SortOrder
    promoSize?: SortOrderInput | SortOrder
    isPromoAnchor?: SortOrder
    promoAnchorId?: SortOrderInput | SortOrder
    _count?: FlyerPageSlotCountOrderByAggregateInput
    _avg?: FlyerPageSlotAvgOrderByAggregateInput
    _max?: FlyerPageSlotMaxOrderByAggregateInput
    _min?: FlyerPageSlotMinOrderByAggregateInput
    _sum?: FlyerPageSlotSumOrderByAggregateInput
  }

  export type FlyerPageSlotScalarWhereWithAggregatesInput = {
    AND?: FlyerPageSlotScalarWhereWithAggregatesInput | FlyerPageSlotScalarWhereWithAggregatesInput[]
    OR?: FlyerPageSlotScalarWhereWithAggregatesInput[]
    NOT?: FlyerPageSlotScalarWhereWithAggregatesInput | FlyerPageSlotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlyerPageSlot"> | string
    pageId?: StringWithAggregatesFilter<"FlyerPageSlot"> | string
    slotPosition?: IntWithAggregatesFilter<"FlyerPageSlot"> | number
    slotType?: EnumSlotTypeWithAggregatesFilter<"FlyerPageSlot"> | $Enums.SlotType
    productId?: StringNullableWithAggregatesFilter<"FlyerPageSlot"> | string | null
    promoImageId?: StringNullableWithAggregatesFilter<"FlyerPageSlot"> | string | null
    promoSize?: EnumPromoSlotSizeNullableWithAggregatesFilter<"FlyerPageSlot"> | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolWithAggregatesFilter<"FlyerPageSlot"> | boolean
    promoAnchorId?: StringNullableWithAggregatesFilter<"FlyerPageSlot"> | string | null
  }

  export type VerificationLogWhereInput = {
    AND?: VerificationLogWhereInput | VerificationLogWhereInput[]
    OR?: VerificationLogWhereInput[]
    NOT?: VerificationLogWhereInput | VerificationLogWhereInput[]
    id?: StringFilter<"VerificationLog"> | string
    flyerId?: StringFilter<"VerificationLog"> | string
    verificationDate?: DateTimeFilter<"VerificationLog"> | Date | string
    status?: EnumVerificationStatusFilter<"VerificationLog"> | $Enums.VerificationStatus
    details?: JsonFilter<"VerificationLog">
    createdAt?: DateTimeFilter<"VerificationLog"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }

  export type VerificationLogOrderByWithRelationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    verificationDate?: SortOrder
    status?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    flyer?: FlyerOrderByWithRelationInput
  }

  export type VerificationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationLogWhereInput | VerificationLogWhereInput[]
    OR?: VerificationLogWhereInput[]
    NOT?: VerificationLogWhereInput | VerificationLogWhereInput[]
    flyerId?: StringFilter<"VerificationLog"> | string
    verificationDate?: DateTimeFilter<"VerificationLog"> | Date | string
    status?: EnumVerificationStatusFilter<"VerificationLog"> | $Enums.VerificationStatus
    details?: JsonFilter<"VerificationLog">
    createdAt?: DateTimeFilter<"VerificationLog"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }, "id">

  export type VerificationLogOrderByWithAggregationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    verificationDate?: SortOrder
    status?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    _count?: VerificationLogCountOrderByAggregateInput
    _max?: VerificationLogMaxOrderByAggregateInput
    _min?: VerificationLogMinOrderByAggregateInput
  }

  export type VerificationLogScalarWhereWithAggregatesInput = {
    AND?: VerificationLogScalarWhereWithAggregatesInput | VerificationLogScalarWhereWithAggregatesInput[]
    OR?: VerificationLogScalarWhereWithAggregatesInput[]
    NOT?: VerificationLogScalarWhereWithAggregatesInput | VerificationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationLog"> | string
    flyerId?: StringWithAggregatesFilter<"VerificationLog"> | string
    verificationDate?: DateTimeWithAggregatesFilter<"VerificationLog"> | Date | string
    status?: EnumVerificationStatusWithAggregatesFilter<"VerificationLog"> | $Enums.VerificationStatus
    details?: JsonWithAggregatesFilter<"VerificationLog">
    createdAt?: DateTimeWithAggregatesFilter<"VerificationLog"> | Date | string
  }

  export type ApprovalWhereInput = {
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    id?: StringFilter<"Approval"> | string
    flyerId?: StringFilter<"Approval"> | string
    approverId?: StringFilter<"Approval"> | string
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"Approval"> | string | null
    decidedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ApprovalOrderByWithRelationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    decidedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    flyer?: FlyerOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type ApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flyerId_approverId?: ApprovalFlyerIdApproverIdCompoundUniqueInput
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    flyerId?: StringFilter<"Approval"> | string
    approverId?: StringFilter<"Approval"> | string
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"Approval"> | string | null
    decidedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
    approver?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "flyerId_approverId">

  export type ApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrderInput | SortOrder
    decidedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    OR?: ApprovalScalarWhereWithAggregatesInput[]
    NOT?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Approval"> | string
    flyerId?: StringWithAggregatesFilter<"Approval"> | string
    approverId?: StringWithAggregatesFilter<"Approval"> | string
    status?: EnumApprovalStatusWithAggregatesFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    decidedAt?: DateTimeNullableWithAggregatesFilter<"Approval"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
  }

  export type ApprovalWorkflowWhereInput = {
    AND?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    OR?: ApprovalWorkflowWhereInput[]
    NOT?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    id?: StringFilter<"ApprovalWorkflow"> | string
    flyerId?: StringFilter<"ApprovalWorkflow"> | string
    requiredApprovers?: IntFilter<"ApprovalWorkflow"> | number
    currentApprovals?: IntFilter<"ApprovalWorkflow"> | number
    isComplete?: BoolFilter<"ApprovalWorkflow"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }

  export type ApprovalWorkflowOrderByWithRelationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    flyer?: FlyerOrderByWithRelationInput
  }

  export type ApprovalWorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flyerId?: string
    AND?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    OR?: ApprovalWorkflowWhereInput[]
    NOT?: ApprovalWorkflowWhereInput | ApprovalWorkflowWhereInput[]
    requiredApprovers?: IntFilter<"ApprovalWorkflow"> | number
    currentApprovals?: IntFilter<"ApprovalWorkflow"> | number
    isComplete?: BoolFilter<"ApprovalWorkflow"> | boolean
    createdAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalWorkflow"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }, "id" | "flyerId">

  export type ApprovalWorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalWorkflowCountOrderByAggregateInput
    _avg?: ApprovalWorkflowAvgOrderByAggregateInput
    _max?: ApprovalWorkflowMaxOrderByAggregateInput
    _min?: ApprovalWorkflowMinOrderByAggregateInput
    _sum?: ApprovalWorkflowSumOrderByAggregateInput
  }

  export type ApprovalWorkflowScalarWhereWithAggregatesInput = {
    AND?: ApprovalWorkflowScalarWhereWithAggregatesInput | ApprovalWorkflowScalarWhereWithAggregatesInput[]
    OR?: ApprovalWorkflowScalarWhereWithAggregatesInput[]
    NOT?: ApprovalWorkflowScalarWhereWithAggregatesInput | ApprovalWorkflowScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalWorkflow"> | string
    flyerId?: StringWithAggregatesFilter<"ApprovalWorkflow"> | string
    requiredApprovers?: IntWithAggregatesFilter<"ApprovalWorkflow"> | number
    currentApprovals?: IntWithAggregatesFilter<"ApprovalWorkflow"> | number
    isComplete?: BoolWithAggregatesFilter<"ApprovalWorkflow"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalWorkflow"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalWorkflow"> | Date | string
  }

  export type FlyerVersionWhereInput = {
    AND?: FlyerVersionWhereInput | FlyerVersionWhereInput[]
    OR?: FlyerVersionWhereInput[]
    NOT?: FlyerVersionWhereInput | FlyerVersionWhereInput[]
    id?: StringFilter<"FlyerVersion"> | string
    flyerId?: StringFilter<"FlyerVersion"> | string
    versionNumber?: IntFilter<"FlyerVersion"> | number
    snapshotData?: JsonFilter<"FlyerVersion">
    createdBy?: StringFilter<"FlyerVersion"> | string
    changeDescription?: StringNullableFilter<"FlyerVersion"> | string | null
    createdAt?: DateTimeFilter<"FlyerVersion"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }

  export type FlyerVersionOrderByWithRelationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    createdBy?: SortOrder
    changeDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    flyer?: FlyerOrderByWithRelationInput
  }

  export type FlyerVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    flyerId_versionNumber?: FlyerVersionFlyerIdVersionNumberCompoundUniqueInput
    AND?: FlyerVersionWhereInput | FlyerVersionWhereInput[]
    OR?: FlyerVersionWhereInput[]
    NOT?: FlyerVersionWhereInput | FlyerVersionWhereInput[]
    flyerId?: StringFilter<"FlyerVersion"> | string
    versionNumber?: IntFilter<"FlyerVersion"> | number
    snapshotData?: JsonFilter<"FlyerVersion">
    createdBy?: StringFilter<"FlyerVersion"> | string
    changeDescription?: StringNullableFilter<"FlyerVersion"> | string | null
    createdAt?: DateTimeFilter<"FlyerVersion"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }, "id" | "flyerId_versionNumber">

  export type FlyerVersionOrderByWithAggregationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    createdBy?: SortOrder
    changeDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FlyerVersionCountOrderByAggregateInput
    _avg?: FlyerVersionAvgOrderByAggregateInput
    _max?: FlyerVersionMaxOrderByAggregateInput
    _min?: FlyerVersionMinOrderByAggregateInput
    _sum?: FlyerVersionSumOrderByAggregateInput
  }

  export type FlyerVersionScalarWhereWithAggregatesInput = {
    AND?: FlyerVersionScalarWhereWithAggregatesInput | FlyerVersionScalarWhereWithAggregatesInput[]
    OR?: FlyerVersionScalarWhereWithAggregatesInput[]
    NOT?: FlyerVersionScalarWhereWithAggregatesInput | FlyerVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlyerVersion"> | string
    flyerId?: StringWithAggregatesFilter<"FlyerVersion"> | string
    versionNumber?: IntWithAggregatesFilter<"FlyerVersion"> | number
    snapshotData?: JsonWithAggregatesFilter<"FlyerVersion">
    createdBy?: StringWithAggregatesFilter<"FlyerVersion"> | string
    changeDescription?: StringNullableWithAggregatesFilter<"FlyerVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FlyerVersion"> | Date | string
  }

  export type FlyerEditHistoryWhereInput = {
    AND?: FlyerEditHistoryWhereInput | FlyerEditHistoryWhereInput[]
    OR?: FlyerEditHistoryWhereInput[]
    NOT?: FlyerEditHistoryWhereInput | FlyerEditHistoryWhereInput[]
    id?: StringFilter<"FlyerEditHistory"> | string
    flyerId?: StringFilter<"FlyerEditHistory"> | string
    userId?: StringFilter<"FlyerEditHistory"> | string
    actionType?: EnumFlyerActionTypeFilter<"FlyerEditHistory"> | $Enums.FlyerActionType
    details?: JsonNullableFilter<"FlyerEditHistory">
    createdAt?: DateTimeFilter<"FlyerEditHistory"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }

  export type FlyerEditHistoryOrderByWithRelationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    flyer?: FlyerOrderByWithRelationInput
  }

  export type FlyerEditHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlyerEditHistoryWhereInput | FlyerEditHistoryWhereInput[]
    OR?: FlyerEditHistoryWhereInput[]
    NOT?: FlyerEditHistoryWhereInput | FlyerEditHistoryWhereInput[]
    flyerId?: StringFilter<"FlyerEditHistory"> | string
    userId?: StringFilter<"FlyerEditHistory"> | string
    actionType?: EnumFlyerActionTypeFilter<"FlyerEditHistory"> | $Enums.FlyerActionType
    details?: JsonNullableFilter<"FlyerEditHistory">
    createdAt?: DateTimeFilter<"FlyerEditHistory"> | Date | string
    flyer?: XOR<FlyerRelationFilter, FlyerWhereInput>
  }, "id">

  export type FlyerEditHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    flyerId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FlyerEditHistoryCountOrderByAggregateInput
    _max?: FlyerEditHistoryMaxOrderByAggregateInput
    _min?: FlyerEditHistoryMinOrderByAggregateInput
  }

  export type FlyerEditHistoryScalarWhereWithAggregatesInput = {
    AND?: FlyerEditHistoryScalarWhereWithAggregatesInput | FlyerEditHistoryScalarWhereWithAggregatesInput[]
    OR?: FlyerEditHistoryScalarWhereWithAggregatesInput[]
    NOT?: FlyerEditHistoryScalarWhereWithAggregatesInput | FlyerEditHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlyerEditHistory"> | string
    flyerId?: StringWithAggregatesFilter<"FlyerEditHistory"> | string
    userId?: StringWithAggregatesFilter<"FlyerEditHistory"> | string
    actionType?: EnumFlyerActionTypeWithAggregatesFilter<"FlyerEditHistory"> | $Enums.FlyerActionType
    details?: JsonNullableWithAggregatesFilter<"FlyerEditHistory">
    createdAt?: DateTimeWithAggregatesFilter<"FlyerEditHistory"> | Date | string
  }

  export type UserFlyerWhereInput = {
    AND?: UserFlyerWhereInput | UserFlyerWhereInput[]
    OR?: UserFlyerWhereInput[]
    NOT?: UserFlyerWhereInput | UserFlyerWhereInput[]
    id?: StringFilter<"UserFlyer"> | string
    userId?: StringFilter<"UserFlyer"> | string
    name?: StringFilter<"UserFlyer"> | string
    isDraft?: BoolFilter<"UserFlyer"> | boolean
    lastEditedAt?: DateTimeFilter<"UserFlyer"> | Date | string
    completionPercentage?: IntFilter<"UserFlyer"> | number
    pdfData?: BytesNullableFilter<"UserFlyer"> | Buffer | null
    pdfMimeType?: StringNullableFilter<"UserFlyer"> | string | null
    createdAt?: DateTimeFilter<"UserFlyer"> | Date | string
    updatedAt?: DateTimeFilter<"UserFlyer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    pages?: UserFlyerPageListRelationFilter
  }

  export type UserFlyerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDraft?: SortOrder
    lastEditedAt?: SortOrder
    completionPercentage?: SortOrder
    pdfData?: SortOrderInput | SortOrder
    pdfMimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    pages?: UserFlyerPageOrderByRelationAggregateInput
  }

  export type UserFlyerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserFlyerWhereInput | UserFlyerWhereInput[]
    OR?: UserFlyerWhereInput[]
    NOT?: UserFlyerWhereInput | UserFlyerWhereInput[]
    userId?: StringFilter<"UserFlyer"> | string
    name?: StringFilter<"UserFlyer"> | string
    isDraft?: BoolFilter<"UserFlyer"> | boolean
    lastEditedAt?: DateTimeFilter<"UserFlyer"> | Date | string
    completionPercentage?: IntFilter<"UserFlyer"> | number
    pdfData?: BytesNullableFilter<"UserFlyer"> | Buffer | null
    pdfMimeType?: StringNullableFilter<"UserFlyer"> | string | null
    createdAt?: DateTimeFilter<"UserFlyer"> | Date | string
    updatedAt?: DateTimeFilter<"UserFlyer"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    pages?: UserFlyerPageListRelationFilter
  }, "id">

  export type UserFlyerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDraft?: SortOrder
    lastEditedAt?: SortOrder
    completionPercentage?: SortOrder
    pdfData?: SortOrderInput | SortOrder
    pdfMimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserFlyerCountOrderByAggregateInput
    _avg?: UserFlyerAvgOrderByAggregateInput
    _max?: UserFlyerMaxOrderByAggregateInput
    _min?: UserFlyerMinOrderByAggregateInput
    _sum?: UserFlyerSumOrderByAggregateInput
  }

  export type UserFlyerScalarWhereWithAggregatesInput = {
    AND?: UserFlyerScalarWhereWithAggregatesInput | UserFlyerScalarWhereWithAggregatesInput[]
    OR?: UserFlyerScalarWhereWithAggregatesInput[]
    NOT?: UserFlyerScalarWhereWithAggregatesInput | UserFlyerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFlyer"> | string
    userId?: StringWithAggregatesFilter<"UserFlyer"> | string
    name?: StringWithAggregatesFilter<"UserFlyer"> | string
    isDraft?: BoolWithAggregatesFilter<"UserFlyer"> | boolean
    lastEditedAt?: DateTimeWithAggregatesFilter<"UserFlyer"> | Date | string
    completionPercentage?: IntWithAggregatesFilter<"UserFlyer"> | number
    pdfData?: BytesNullableWithAggregatesFilter<"UserFlyer"> | Buffer | null
    pdfMimeType?: StringNullableWithAggregatesFilter<"UserFlyer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserFlyer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserFlyer"> | Date | string
  }

  export type UserFlyerPageWhereInput = {
    AND?: UserFlyerPageWhereInput | UserFlyerPageWhereInput[]
    OR?: UserFlyerPageWhereInput[]
    NOT?: UserFlyerPageWhereInput | UserFlyerPageWhereInput[]
    id?: StringFilter<"UserFlyerPage"> | string
    userFlyerId?: StringFilter<"UserFlyerPage"> | string
    pageNumber?: IntFilter<"UserFlyerPage"> | number
    userFlyer?: XOR<UserFlyerRelationFilter, UserFlyerWhereInput>
    products?: UserFlyerPageProductListRelationFilter
  }

  export type UserFlyerPageOrderByWithRelationInput = {
    id?: SortOrder
    userFlyerId?: SortOrder
    pageNumber?: SortOrder
    userFlyer?: UserFlyerOrderByWithRelationInput
    products?: UserFlyerPageProductOrderByRelationAggregateInput
  }

  export type UserFlyerPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userFlyerId_pageNumber?: UserFlyerPageUserFlyerIdPageNumberCompoundUniqueInput
    AND?: UserFlyerPageWhereInput | UserFlyerPageWhereInput[]
    OR?: UserFlyerPageWhereInput[]
    NOT?: UserFlyerPageWhereInput | UserFlyerPageWhereInput[]
    userFlyerId?: StringFilter<"UserFlyerPage"> | string
    pageNumber?: IntFilter<"UserFlyerPage"> | number
    userFlyer?: XOR<UserFlyerRelationFilter, UserFlyerWhereInput>
    products?: UserFlyerPageProductListRelationFilter
  }, "id" | "userFlyerId_pageNumber">

  export type UserFlyerPageOrderByWithAggregationInput = {
    id?: SortOrder
    userFlyerId?: SortOrder
    pageNumber?: SortOrder
    _count?: UserFlyerPageCountOrderByAggregateInput
    _avg?: UserFlyerPageAvgOrderByAggregateInput
    _max?: UserFlyerPageMaxOrderByAggregateInput
    _min?: UserFlyerPageMinOrderByAggregateInput
    _sum?: UserFlyerPageSumOrderByAggregateInput
  }

  export type UserFlyerPageScalarWhereWithAggregatesInput = {
    AND?: UserFlyerPageScalarWhereWithAggregatesInput | UserFlyerPageScalarWhereWithAggregatesInput[]
    OR?: UserFlyerPageScalarWhereWithAggregatesInput[]
    NOT?: UserFlyerPageScalarWhereWithAggregatesInput | UserFlyerPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFlyerPage"> | string
    userFlyerId?: StringWithAggregatesFilter<"UserFlyerPage"> | string
    pageNumber?: IntWithAggregatesFilter<"UserFlyerPage"> | number
  }

  export type UserFlyerPageProductWhereInput = {
    AND?: UserFlyerPageProductWhereInput | UserFlyerPageProductWhereInput[]
    OR?: UserFlyerPageProductWhereInput[]
    NOT?: UserFlyerPageProductWhereInput | UserFlyerPageProductWhereInput[]
    id?: StringFilter<"UserFlyerPageProduct"> | string
    pageId?: StringFilter<"UserFlyerPageProduct"> | string
    productId?: StringFilter<"UserFlyerPageProduct"> | string
    position?: IntFilter<"UserFlyerPageProduct"> | number
    page?: XOR<UserFlyerPageRelationFilter, UserFlyerPageWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type UserFlyerPageProductOrderByWithRelationInput = {
    id?: SortOrder
    pageId?: SortOrder
    productId?: SortOrder
    position?: SortOrder
    page?: UserFlyerPageOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type UserFlyerPageProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pageId_position?: UserFlyerPageProductPageIdPositionCompoundUniqueInput
    AND?: UserFlyerPageProductWhereInput | UserFlyerPageProductWhereInput[]
    OR?: UserFlyerPageProductWhereInput[]
    NOT?: UserFlyerPageProductWhereInput | UserFlyerPageProductWhereInput[]
    pageId?: StringFilter<"UserFlyerPageProduct"> | string
    productId?: StringFilter<"UserFlyerPageProduct"> | string
    position?: IntFilter<"UserFlyerPageProduct"> | number
    page?: XOR<UserFlyerPageRelationFilter, UserFlyerPageWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "pageId_position">

  export type UserFlyerPageProductOrderByWithAggregationInput = {
    id?: SortOrder
    pageId?: SortOrder
    productId?: SortOrder
    position?: SortOrder
    _count?: UserFlyerPageProductCountOrderByAggregateInput
    _avg?: UserFlyerPageProductAvgOrderByAggregateInput
    _max?: UserFlyerPageProductMaxOrderByAggregateInput
    _min?: UserFlyerPageProductMinOrderByAggregateInput
    _sum?: UserFlyerPageProductSumOrderByAggregateInput
  }

  export type UserFlyerPageProductScalarWhereWithAggregatesInput = {
    AND?: UserFlyerPageProductScalarWhereWithAggregatesInput | UserFlyerPageProductScalarWhereWithAggregatesInput[]
    OR?: UserFlyerPageProductScalarWhereWithAggregatesInput[]
    NOT?: UserFlyerPageProductScalarWhereWithAggregatesInput | UserFlyerPageProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserFlyerPageProduct"> | string
    pageId?: StringWithAggregatesFilter<"UserFlyerPageProduct"> | string
    productId?: StringWithAggregatesFilter<"UserFlyerPageProduct"> | string
    position?: IntWithAggregatesFilter<"UserFlyerPageProduct"> | number
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSupplierInput
    flyers?: FlyerCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    flyers?: FlyerUncheckedCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUncheckedUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserBrandCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBrandsInput
    brand: BrandCreateNestedOneWithoutUsersInput
  }

  export type UserBrandUncheckedCreateInput = {
    id?: string
    userId: string
    brandId: string
    createdAt?: Date | string
  }

  export type UserBrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBrandsNestedInput
    brand?: BrandUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBrandCreateManyInput = {
    id?: string
    userId: string
    brandId: string
    createdAt?: Date | string
  }

  export type UserBrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserBrandCreateNestedManyWithoutBrandInput
    products?: ProductCreateNestedManyWithoutBrandInput
    promoImages?: PromoImageCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserBrandUncheckedCreateNestedManyWithoutBrandInput
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
    promoImages?: PromoImageUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBrandUpdateManyWithoutBrandNestedInput
    products?: ProductUpdateManyWithoutBrandNestedInput
    promoImages?: PromoImageUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBrandUncheckedUpdateManyWithoutBrandNestedInput
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
    promoImages?: PromoImageUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: UserCreateNestedOneWithoutProductsInput
    brand: BrandCreateNestedOneWithoutProductsInput
    icons?: ProductIconCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    supplierId: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ProductIconUncheckedCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: UserUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    icons?: ProductIconUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ProductIconUncheckedUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    supplierId: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IconCreateInput = {
    id?: string
    name: string
    imageData: Buffer
    imageMimeType: string
    isEnergyClass?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productIcons?: ProductIconCreateNestedManyWithoutIconInput
  }

  export type IconUncheckedCreateInput = {
    id?: string
    name: string
    imageData: Buffer
    imageMimeType: string
    isEnergyClass?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    productIcons?: ProductIconUncheckedCreateNestedManyWithoutIconInput
  }

  export type IconUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    isEnergyClass?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productIcons?: ProductIconUpdateManyWithoutIconNestedInput
  }

  export type IconUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    isEnergyClass?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productIcons?: ProductIconUncheckedUpdateManyWithoutIconNestedInput
  }

  export type IconCreateManyInput = {
    id?: string
    name: string
    imageData: Buffer
    imageMimeType: string
    isEnergyClass?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IconUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    isEnergyClass?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IconUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    isEnergyClass?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIconCreateInput = {
    id?: string
    position: number
    product: ProductCreateNestedOneWithoutIconsInput
    icon: IconCreateNestedOneWithoutProductIconsInput
  }

  export type ProductIconUncheckedCreateInput = {
    id?: string
    productId: string
    iconId: string
    position: number
  }

  export type ProductIconUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutIconsNestedInput
    icon?: IconUpdateOneRequiredWithoutProductIconsNestedInput
  }

  export type ProductIconUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    iconId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProductIconCreateManyInput = {
    id?: string
    productId: string
    iconId: string
    position: number
  }

  export type ProductIconUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProductIconUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    iconId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type PromoImageCreateInput = {
    id?: string
    supplierId: string
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    brand?: BrandCreateNestedOneWithoutPromoImagesInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutPromoImageInput
    footerPages?: FlyerPageCreateNestedManyWithoutFooterPromoImageInput
  }

  export type PromoImageUncheckedCreateInput = {
    id?: string
    supplierId: string
    brandId?: string | null
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoImageInput
    footerPages?: FlyerPageUncheckedCreateNestedManyWithoutFooterPromoImageInput
  }

  export type PromoImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneWithoutPromoImagesNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutPromoImageNestedInput
    footerPages?: FlyerPageUpdateManyWithoutFooterPromoImageNestedInput
  }

  export type PromoImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoImageNestedInput
    footerPages?: FlyerPageUncheckedUpdateManyWithoutFooterPromoImageNestedInput
  }

  export type PromoImageCreateManyInput = {
    id?: string
    supplierId: string
    brandId?: string | null
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
  }

  export type PromoImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerCreateInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerCreateManyInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type FlyerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlyerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FlyerPageCreateInput = {
    id?: string
    pageNumber: number
    flyer: FlyerCreateNestedOneWithoutPagesInput
    slots?: FlyerPageSlotCreateNestedManyWithoutPageInput
    footerPromoImage?: PromoImageCreateNestedOneWithoutFooterPagesInput
  }

  export type FlyerPageUncheckedCreateInput = {
    id?: string
    flyerId: string
    pageNumber: number
    footerPromoImageId?: string | null
    slots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPageInput
  }

  export type FlyerPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    flyer?: FlyerUpdateOneRequiredWithoutPagesNestedInput
    slots?: FlyerPageSlotUpdateManyWithoutPageNestedInput
    footerPromoImage?: PromoImageUpdateOneWithoutFooterPagesNestedInput
  }

  export type FlyerPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    footerPromoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: FlyerPageSlotUncheckedUpdateManyWithoutPageNestedInput
  }

  export type FlyerPageCreateManyInput = {
    id?: string
    flyerId: string
    pageNumber: number
    footerPromoImageId?: string | null
  }

  export type FlyerPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
  }

  export type FlyerPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    footerPromoImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlyerPageSlotCreateInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    page: FlyerPageCreateNestedOneWithoutSlotsInput
    product?: ProductCreateNestedOneWithoutFlyerPageSlotsInput
    promoImage?: PromoImageCreateNestedOneWithoutFlyerPageSlotsInput
    promoAnchor?: FlyerPageSlotCreateNestedOneWithoutPromoSpannedSlotsInput
    promoSpannedSlots?: FlyerPageSlotCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotUncheckedCreateInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    page?: FlyerPageUpdateOneRequiredWithoutSlotsNestedInput
    product?: ProductUpdateOneWithoutFlyerPageSlotsNestedInput
    promoImage?: PromoImageUpdateOneWithoutFlyerPageSlotsNestedInput
    promoAnchor?: FlyerPageSlotUpdateOneWithoutPromoSpannedSlotsNestedInput
    promoSpannedSlots?: FlyerPageSlotUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotCreateManyInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
  }

  export type FlyerPageSlotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FlyerPageSlotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationLogCreateInput = {
    id?: string
    verificationDate: Date | string
    status: $Enums.VerificationStatus
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    flyer: FlyerCreateNestedOneWithoutVerificationLogsInput
  }

  export type VerificationLogUncheckedCreateInput = {
    id?: string
    flyerId: string
    verificationDate: Date | string
    status: $Enums.VerificationStatus
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VerificationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyer?: FlyerUpdateOneRequiredWithoutVerificationLogsNestedInput
  }

  export type VerificationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationLogCreateManyInput = {
    id?: string
    flyerId: string
    verificationDate: Date | string
    status: $Enums.VerificationStatus
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VerificationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalCreateInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
    flyer: FlyerCreateNestedOneWithoutApprovalsInput
    approver: UserCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateInput = {
    id?: string
    flyerId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyer?: FlyerUpdateOneRequiredWithoutApprovalsNestedInput
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalCreateManyInput = {
    id?: string
    flyerId: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowCreateInput = {
    id?: string
    requiredApprovers?: number
    currentApprovals?: number
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flyer: FlyerCreateNestedOneWithoutApprovalWorkflowInput
  }

  export type ApprovalWorkflowUncheckedCreateInput = {
    id?: string
    flyerId: string
    requiredApprovers?: number
    currentApprovals?: number
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requiredApprovers?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyer?: FlyerUpdateOneRequiredWithoutApprovalWorkflowNestedInput
  }

  export type ApprovalWorkflowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    requiredApprovers?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowCreateManyInput = {
    id?: string
    flyerId: string
    requiredApprovers?: number
    currentApprovals?: number
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requiredApprovers?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    requiredApprovers?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionCreateInput = {
    id?: string
    versionNumber: number
    snapshotData: JsonNullValueInput | InputJsonValue
    createdBy: string
    changeDescription?: string | null
    createdAt?: Date | string
    flyer: FlyerCreateNestedOneWithoutVersionsInput
  }

  export type FlyerVersionUncheckedCreateInput = {
    id?: string
    flyerId: string
    versionNumber: number
    snapshotData: JsonNullValueInput | InputJsonValue
    createdBy: string
    changeDescription?: string | null
    createdAt?: Date | string
  }

  export type FlyerVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyer?: FlyerUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type FlyerVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionCreateManyInput = {
    id?: string
    flyerId: string
    versionNumber: number
    snapshotData: JsonNullValueInput | InputJsonValue
    createdBy: string
    changeDescription?: string | null
    createdAt?: Date | string
  }

  export type FlyerVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerEditHistoryCreateInput = {
    id?: string
    userId: string
    actionType: $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    flyer: FlyerCreateNestedOneWithoutEditHistoryInput
  }

  export type FlyerEditHistoryUncheckedCreateInput = {
    id?: string
    flyerId: string
    userId: string
    actionType: $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlyerEditHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyer?: FlyerUpdateOneRequiredWithoutEditHistoryNestedInput
  }

  export type FlyerEditHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerEditHistoryCreateManyInput = {
    id?: string
    flyerId: string
    userId: string
    actionType: $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlyerEditHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerEditHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFlyerCreateInput = {
    id?: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserFlyersInput
    pages?: UserFlyerPageCreateNestedManyWithoutUserFlyerInput
  }

  export type UserFlyerUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: UserFlyerPageUncheckedCreateNestedManyWithoutUserFlyerInput
  }

  export type UserFlyerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserFlyersNestedInput
    pages?: UserFlyerPageUpdateManyWithoutUserFlyerNestedInput
  }

  export type UserFlyerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: UserFlyerPageUncheckedUpdateManyWithoutUserFlyerNestedInput
  }

  export type UserFlyerCreateManyInput = {
    id?: string
    userId: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFlyerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFlyerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFlyerPageCreateInput = {
    id?: string
    pageNumber: number
    userFlyer: UserFlyerCreateNestedOneWithoutPagesInput
    products?: UserFlyerPageProductCreateNestedManyWithoutPageInput
  }

  export type UserFlyerPageUncheckedCreateInput = {
    id?: string
    userFlyerId: string
    pageNumber: number
    products?: UserFlyerPageProductUncheckedCreateNestedManyWithoutPageInput
  }

  export type UserFlyerPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    userFlyer?: UserFlyerUpdateOneRequiredWithoutPagesNestedInput
    products?: UserFlyerPageProductUpdateManyWithoutPageNestedInput
  }

  export type UserFlyerPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userFlyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    products?: UserFlyerPageProductUncheckedUpdateManyWithoutPageNestedInput
  }

  export type UserFlyerPageCreateManyInput = {
    id?: string
    userFlyerId: string
    pageNumber: number
  }

  export type UserFlyerPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userFlyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageProductCreateInput = {
    id?: string
    position: number
    page: UserFlyerPageCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutUserFlyerPageProductsInput
  }

  export type UserFlyerPageProductUncheckedCreateInput = {
    id?: string
    pageId: string
    productId: string
    position: number
  }

  export type UserFlyerPageProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    page?: UserFlyerPageUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutUserFlyerPageProductsNestedInput
  }

  export type UserFlyerPageProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageProductCreateManyInput = {
    id?: string
    pageId: string
    productId: string
    position: number
  }

  export type UserFlyerPageProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserBrandListRelationFilter = {
    every?: UserBrandWhereInput
    some?: UserBrandWhereInput
    none?: UserBrandWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type FlyerListRelationFilter = {
    every?: FlyerWhereInput
    some?: FlyerWhereInput
    none?: FlyerWhereInput
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type UserFlyerListRelationFilter = {
    every?: UserFlyerWhereInput
    some?: UserFlyerWhereInput
    none?: UserFlyerWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserBrandOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlyerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFlyerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BrandRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type UserBrandCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBrandMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBrandMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    brandId?: SortOrder
    createdAt?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type PromoImageListRelationFilter = {
    every?: PromoImageWhereInput
    some?: PromoImageWhereInput
    none?: PromoImageWhereInput
  }

  export type PromoImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoData?: SortOrder
    logoMimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoData?: SortOrder
    logoMimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    logoData?: SortOrder
    logoMimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ProductIconListRelationFilter = {
    every?: ProductIconWhereInput
    some?: ProductIconWhereInput
    none?: ProductIconWhereInput
  }

  export type FlyerPageSlotListRelationFilter = {
    every?: FlyerPageSlotWhereInput
    some?: FlyerPageSlotWhereInput
    none?: FlyerPageSlotWhereInput
  }

  export type UserFlyerPageProductListRelationFilter = {
    every?: UserFlyerPageProductWhereInput
    some?: UserFlyerPageProductWhereInput
    none?: UserFlyerPageProductWhereInput
  }

  export type ProductIconOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlyerPageSlotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFlyerPageProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    eanCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    eanCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    eanCode?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    price?: SortOrder
    originalPrice?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    originalPrice?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type IconCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    isEnergyClass?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IconMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    isEnergyClass?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IconMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    isEnergyClass?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type IconRelationFilter = {
    is?: IconWhereInput
    isNot?: IconWhereInput
  }

  export type ProductIconProductIdPositionCompoundUniqueInput = {
    productId: string
    position: number
  }

  export type ProductIconCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    iconId?: SortOrder
    position?: SortOrder
  }

  export type ProductIconAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type ProductIconMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    iconId?: SortOrder
    position?: SortOrder
  }

  export type ProductIconMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    iconId?: SortOrder
    position?: SortOrder
  }

  export type ProductIconSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPromoSlotSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoSlotSizeFilter<$PrismaModel> | $Enums.PromoSlotSize
  }

  export type BrandNullableRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type FlyerPageListRelationFilter = {
    every?: FlyerPageWhereInput
    some?: FlyerPageWhereInput
    none?: FlyerPageWhereInput
  }

  export type FlyerPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PromoImageCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    defaultSize?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoImageMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    defaultSize?: SortOrder
    createdAt?: SortOrder
  }

  export type PromoImageMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    name?: SortOrder
    imageData?: SortOrder
    imageMimeType?: SortOrder
    defaultSize?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPromoSlotSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoSlotSizeWithAggregatesFilter<$PrismaModel> | $Enums.PromoSlotSize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromoSlotSizeFilter<$PrismaModel>
    _max?: NestedEnumPromoSlotSizeFilter<$PrismaModel>
  }

  export type EnumFlyerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerStatus | EnumFlyerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerStatusFilter<$PrismaModel> | $Enums.FlyerStatus
  }

  export type VerificationLogListRelationFilter = {
    every?: VerificationLogWhereInput
    some?: VerificationLogWhereInput
    none?: VerificationLogWhereInput
  }

  export type ApprovalWorkflowNullableRelationFilter = {
    is?: ApprovalWorkflowWhereInput | null
    isNot?: ApprovalWorkflowWhereInput | null
  }

  export type FlyerVersionListRelationFilter = {
    every?: FlyerVersionWhereInput
    some?: FlyerVersionWhereInput
    none?: FlyerVersionWhereInput
  }

  export type FlyerEditHistoryListRelationFilter = {
    every?: FlyerEditHistoryWhereInput
    some?: FlyerEditHistoryWhereInput
    none?: FlyerEditHistoryWhereInput
  }

  export type VerificationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlyerVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlyerEditHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlyerCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    name?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    status?: SortOrder
    isDraft?: SortOrder
    rejectionReason?: SortOrder
    pdfData?: SortOrder
    pdfMimeType?: SortOrder
    lastEditedAt?: SortOrder
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type FlyerAvgOrderByAggregateInput = {
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
  }

  export type FlyerMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    name?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    status?: SortOrder
    isDraft?: SortOrder
    rejectionReason?: SortOrder
    pdfData?: SortOrder
    pdfMimeType?: SortOrder
    lastEditedAt?: SortOrder
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type FlyerMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    name?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    status?: SortOrder
    isDraft?: SortOrder
    rejectionReason?: SortOrder
    pdfData?: SortOrder
    pdfMimeType?: SortOrder
    lastEditedAt?: SortOrder
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
  }

  export type FlyerSumOrderByAggregateInput = {
    autoSaveVersion?: SortOrder
    completionPercentage?: SortOrder
  }

  export type EnumFlyerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerStatus | EnumFlyerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlyerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlyerStatusFilter<$PrismaModel>
    _max?: NestedEnumFlyerStatusFilter<$PrismaModel>
  }

  export type FlyerRelationFilter = {
    is?: FlyerWhereInput
    isNot?: FlyerWhereInput
  }

  export type PromoImageNullableRelationFilter = {
    is?: PromoImageWhereInput | null
    isNot?: PromoImageWhereInput | null
  }

  export type FlyerPageFlyerIdPageNumberCompoundUniqueInput = {
    flyerId: string
    pageNumber: number
  }

  export type FlyerPageCountOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    pageNumber?: SortOrder
    footerPromoImageId?: SortOrder
  }

  export type FlyerPageAvgOrderByAggregateInput = {
    pageNumber?: SortOrder
  }

  export type FlyerPageMaxOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    pageNumber?: SortOrder
    footerPromoImageId?: SortOrder
  }

  export type FlyerPageMinOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    pageNumber?: SortOrder
    footerPromoImageId?: SortOrder
  }

  export type FlyerPageSumOrderByAggregateInput = {
    pageNumber?: SortOrder
  }

  export type EnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type EnumPromoSlotSizeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromoSlotSizeNullableFilter<$PrismaModel> | $Enums.PromoSlotSize | null
  }

  export type FlyerPageRelationFilter = {
    is?: FlyerPageWhereInput
    isNot?: FlyerPageWhereInput
  }

  export type ProductNullableRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type FlyerPageSlotNullableRelationFilter = {
    is?: FlyerPageSlotWhereInput | null
    isNot?: FlyerPageSlotWhereInput | null
  }

  export type FlyerPageSlotPageIdSlotPositionCompoundUniqueInput = {
    pageId: string
    slotPosition: number
  }

  export type FlyerPageSlotCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    slotPosition?: SortOrder
    slotType?: SortOrder
    productId?: SortOrder
    promoImageId?: SortOrder
    promoSize?: SortOrder
    isPromoAnchor?: SortOrder
    promoAnchorId?: SortOrder
  }

  export type FlyerPageSlotAvgOrderByAggregateInput = {
    slotPosition?: SortOrder
  }

  export type FlyerPageSlotMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    slotPosition?: SortOrder
    slotType?: SortOrder
    productId?: SortOrder
    promoImageId?: SortOrder
    promoSize?: SortOrder
    isPromoAnchor?: SortOrder
    promoAnchorId?: SortOrder
  }

  export type FlyerPageSlotMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    slotPosition?: SortOrder
    slotType?: SortOrder
    productId?: SortOrder
    promoImageId?: SortOrder
    promoSize?: SortOrder
    isPromoAnchor?: SortOrder
    promoAnchorId?: SortOrder
  }

  export type FlyerPageSlotSumOrderByAggregateInput = {
    slotPosition?: SortOrder
  }

  export type EnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type EnumPromoSlotSizeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromoSlotSizeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PromoSlotSize | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPromoSlotSizeNullableFilter<$PrismaModel>
    _max?: NestedEnumPromoSlotSizeNullableFilter<$PrismaModel>
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VerificationLogCountOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    verificationDate?: SortOrder
    status?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    verificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationLogMinOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    verificationDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type ApprovalFlyerIdApproverIdCompoundUniqueInput = {
    flyerId: string
    approverId: string
  }

  export type ApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    decidedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    decidedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    approverId?: SortOrder
    status?: SortOrder
    comment?: SortOrder
    decidedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type ApprovalWorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowAvgOrderByAggregateInput = {
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
  }

  export type ApprovalWorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
    isComplete?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalWorkflowSumOrderByAggregateInput = {
    requiredApprovers?: SortOrder
    currentApprovals?: SortOrder
  }

  export type FlyerVersionFlyerIdVersionNumberCompoundUniqueInput = {
    flyerId: string
    versionNumber: number
  }

  export type FlyerVersionCountOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    versionNumber?: SortOrder
    snapshotData?: SortOrder
    createdBy?: SortOrder
    changeDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type FlyerVersionAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type FlyerVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    versionNumber?: SortOrder
    createdBy?: SortOrder
    changeDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type FlyerVersionMinOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    versionNumber?: SortOrder
    createdBy?: SortOrder
    changeDescription?: SortOrder
    createdAt?: SortOrder
  }

  export type FlyerVersionSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumFlyerActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerActionType | EnumFlyerActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerActionTypeFilter<$PrismaModel> | $Enums.FlyerActionType
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FlyerEditHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type FlyerEditHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
  }

  export type FlyerEditHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    flyerId?: SortOrder
    userId?: SortOrder
    actionType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFlyerActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerActionType | EnumFlyerActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.FlyerActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlyerActionTypeFilter<$PrismaModel>
    _max?: NestedEnumFlyerActionTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserFlyerPageListRelationFilter = {
    every?: UserFlyerPageWhereInput
    some?: UserFlyerPageWhereInput
    none?: UserFlyerPageWhereInput
  }

  export type UserFlyerPageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFlyerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDraft?: SortOrder
    lastEditedAt?: SortOrder
    completionPercentage?: SortOrder
    pdfData?: SortOrder
    pdfMimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFlyerAvgOrderByAggregateInput = {
    completionPercentage?: SortOrder
  }

  export type UserFlyerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDraft?: SortOrder
    lastEditedAt?: SortOrder
    completionPercentage?: SortOrder
    pdfData?: SortOrder
    pdfMimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFlyerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    isDraft?: SortOrder
    lastEditedAt?: SortOrder
    completionPercentage?: SortOrder
    pdfData?: SortOrder
    pdfMimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserFlyerSumOrderByAggregateInput = {
    completionPercentage?: SortOrder
  }

  export type UserFlyerRelationFilter = {
    is?: UserFlyerWhereInput
    isNot?: UserFlyerWhereInput
  }

  export type UserFlyerPageUserFlyerIdPageNumberCompoundUniqueInput = {
    userFlyerId: string
    pageNumber: number
  }

  export type UserFlyerPageCountOrderByAggregateInput = {
    id?: SortOrder
    userFlyerId?: SortOrder
    pageNumber?: SortOrder
  }

  export type UserFlyerPageAvgOrderByAggregateInput = {
    pageNumber?: SortOrder
  }

  export type UserFlyerPageMaxOrderByAggregateInput = {
    id?: SortOrder
    userFlyerId?: SortOrder
    pageNumber?: SortOrder
  }

  export type UserFlyerPageMinOrderByAggregateInput = {
    id?: SortOrder
    userFlyerId?: SortOrder
    pageNumber?: SortOrder
  }

  export type UserFlyerPageSumOrderByAggregateInput = {
    pageNumber?: SortOrder
  }

  export type UserFlyerPageRelationFilter = {
    is?: UserFlyerPageWhereInput
    isNot?: UserFlyerPageWhereInput
  }

  export type UserFlyerPageProductPageIdPositionCompoundUniqueInput = {
    pageId: string
    position: number
  }

  export type UserFlyerPageProductCountOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    productId?: SortOrder
    position?: SortOrder
  }

  export type UserFlyerPageProductAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type UserFlyerPageProductMaxOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    productId?: SortOrder
    position?: SortOrder
  }

  export type UserFlyerPageProductMinOrderByAggregateInput = {
    id?: SortOrder
    pageId?: SortOrder
    productId?: SortOrder
    position?: SortOrder
  }

  export type UserFlyerPageProductSumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
  }

  export type UserBrandCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBrandCreateWithoutUserInput, UserBrandUncheckedCreateWithoutUserInput> | UserBrandCreateWithoutUserInput[] | UserBrandUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutUserInput | UserBrandCreateOrConnectWithoutUserInput[]
    createMany?: UserBrandCreateManyUserInputEnvelope
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FlyerCreateNestedManyWithoutSupplierInput = {
    create?: XOR<FlyerCreateWithoutSupplierInput, FlyerUncheckedCreateWithoutSupplierInput> | FlyerCreateWithoutSupplierInput[] | FlyerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FlyerCreateOrConnectWithoutSupplierInput | FlyerCreateOrConnectWithoutSupplierInput[]
    createMany?: FlyerCreateManySupplierInputEnvelope
    connect?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type UserFlyerCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFlyerCreateWithoutUserInput, UserFlyerUncheckedCreateWithoutUserInput> | UserFlyerCreateWithoutUserInput[] | UserFlyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFlyerCreateOrConnectWithoutUserInput | UserFlyerCreateOrConnectWithoutUserInput[]
    createMany?: UserFlyerCreateManyUserInputEnvelope
    connect?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserBrandUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBrandCreateWithoutUserInput, UserBrandUncheckedCreateWithoutUserInput> | UserBrandCreateWithoutUserInput[] | UserBrandUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutUserInput | UserBrandCreateOrConnectWithoutUserInput[]
    createMany?: UserBrandCreateManyUserInputEnvelope
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type FlyerUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<FlyerCreateWithoutSupplierInput, FlyerUncheckedCreateWithoutSupplierInput> | FlyerCreateWithoutSupplierInput[] | FlyerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FlyerCreateOrConnectWithoutSupplierInput | FlyerCreateOrConnectWithoutSupplierInput[]
    createMany?: FlyerCreateManySupplierInputEnvelope
    connect?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type UserFlyerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserFlyerCreateWithoutUserInput, UserFlyerUncheckedCreateWithoutUserInput> | UserFlyerCreateWithoutUserInput[] | UserFlyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFlyerCreateOrConnectWithoutUserInput | UserFlyerCreateOrConnectWithoutUserInput[]
    createMany?: UserFlyerCreateManyUserInputEnvelope
    connect?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserBrandUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBrandCreateWithoutUserInput, UserBrandUncheckedCreateWithoutUserInput> | UserBrandCreateWithoutUserInput[] | UserBrandUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutUserInput | UserBrandCreateOrConnectWithoutUserInput[]
    upsert?: UserBrandUpsertWithWhereUniqueWithoutUserInput | UserBrandUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBrandCreateManyUserInputEnvelope
    set?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    disconnect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    delete?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    update?: UserBrandUpdateWithWhereUniqueWithoutUserInput | UserBrandUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBrandUpdateManyWithWhereWithoutUserInput | UserBrandUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBrandScalarWhereInput | UserBrandScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type FlyerUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<FlyerCreateWithoutSupplierInput, FlyerUncheckedCreateWithoutSupplierInput> | FlyerCreateWithoutSupplierInput[] | FlyerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FlyerCreateOrConnectWithoutSupplierInput | FlyerCreateOrConnectWithoutSupplierInput[]
    upsert?: FlyerUpsertWithWhereUniqueWithoutSupplierInput | FlyerUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: FlyerCreateManySupplierInputEnvelope
    set?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    disconnect?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    delete?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    connect?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    update?: FlyerUpdateWithWhereUniqueWithoutSupplierInput | FlyerUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: FlyerUpdateManyWithWhereWithoutSupplierInput | FlyerUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: FlyerScalarWhereInput | FlyerScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutApproverInput | ApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutApproverInput | ApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutApproverInput | ApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type UserFlyerUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFlyerCreateWithoutUserInput, UserFlyerUncheckedCreateWithoutUserInput> | UserFlyerCreateWithoutUserInput[] | UserFlyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFlyerCreateOrConnectWithoutUserInput | UserFlyerCreateOrConnectWithoutUserInput[]
    upsert?: UserFlyerUpsertWithWhereUniqueWithoutUserInput | UserFlyerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFlyerCreateManyUserInputEnvelope
    set?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    disconnect?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    delete?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    connect?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    update?: UserFlyerUpdateWithWhereUniqueWithoutUserInput | UserFlyerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFlyerUpdateManyWithWhereWithoutUserInput | UserFlyerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFlyerScalarWhereInput | UserFlyerScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserBrandUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBrandCreateWithoutUserInput, UserBrandUncheckedCreateWithoutUserInput> | UserBrandCreateWithoutUserInput[] | UserBrandUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutUserInput | UserBrandCreateOrConnectWithoutUserInput[]
    upsert?: UserBrandUpsertWithWhereUniqueWithoutUserInput | UserBrandUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBrandCreateManyUserInputEnvelope
    set?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    disconnect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    delete?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    update?: UserBrandUpdateWithWhereUniqueWithoutUserInput | UserBrandUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBrandUpdateManyWithWhereWithoutUserInput | UserBrandUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBrandScalarWhereInput | UserBrandScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput> | ProductCreateWithoutSupplierInput[] | ProductUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSupplierInput | ProductCreateOrConnectWithoutSupplierInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSupplierInput | ProductUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ProductCreateManySupplierInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSupplierInput | ProductUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSupplierInput | ProductUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type FlyerUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<FlyerCreateWithoutSupplierInput, FlyerUncheckedCreateWithoutSupplierInput> | FlyerCreateWithoutSupplierInput[] | FlyerUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: FlyerCreateOrConnectWithoutSupplierInput | FlyerCreateOrConnectWithoutSupplierInput[]
    upsert?: FlyerUpsertWithWhereUniqueWithoutSupplierInput | FlyerUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: FlyerCreateManySupplierInputEnvelope
    set?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    disconnect?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    delete?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    connect?: FlyerWhereUniqueInput | FlyerWhereUniqueInput[]
    update?: FlyerUpdateWithWhereUniqueWithoutSupplierInput | FlyerUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: FlyerUpdateManyWithWhereWithoutSupplierInput | FlyerUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: FlyerScalarWhereInput | FlyerScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput> | ApprovalCreateWithoutApproverInput[] | ApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutApproverInput | ApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutApproverInput | ApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ApprovalCreateManyApproverInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutApproverInput | ApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutApproverInput | ApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type UserFlyerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserFlyerCreateWithoutUserInput, UserFlyerUncheckedCreateWithoutUserInput> | UserFlyerCreateWithoutUserInput[] | UserFlyerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserFlyerCreateOrConnectWithoutUserInput | UserFlyerCreateOrConnectWithoutUserInput[]
    upsert?: UserFlyerUpsertWithWhereUniqueWithoutUserInput | UserFlyerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserFlyerCreateManyUserInputEnvelope
    set?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    disconnect?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    delete?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    connect?: UserFlyerWhereUniqueInput | UserFlyerWhereUniqueInput[]
    update?: UserFlyerUpdateWithWhereUniqueWithoutUserInput | UserFlyerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserFlyerUpdateManyWithWhereWithoutUserInput | UserFlyerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserFlyerScalarWhereInput | UserFlyerScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBrandsInput = {
    create?: XOR<UserCreateWithoutBrandsInput, UserUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBrandsInput
    connect?: UserWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutUsersInput = {
    create?: XOR<BrandCreateWithoutUsersInput, BrandUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BrandCreateOrConnectWithoutUsersInput
    connect?: BrandWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBrandsNestedInput = {
    create?: XOR<UserCreateWithoutBrandsInput, UserUncheckedCreateWithoutBrandsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBrandsInput
    upsert?: UserUpsertWithoutBrandsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBrandsInput, UserUpdateWithoutBrandsInput>, UserUncheckedUpdateWithoutBrandsInput>
  }

  export type BrandUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<BrandCreateWithoutUsersInput, BrandUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BrandCreateOrConnectWithoutUsersInput
    upsert?: BrandUpsertWithoutUsersInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutUsersInput, BrandUpdateWithoutUsersInput>, BrandUncheckedUpdateWithoutUsersInput>
  }

  export type UserBrandCreateNestedManyWithoutBrandInput = {
    create?: XOR<UserBrandCreateWithoutBrandInput, UserBrandUncheckedCreateWithoutBrandInput> | UserBrandCreateWithoutBrandInput[] | UserBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutBrandInput | UserBrandCreateOrConnectWithoutBrandInput[]
    createMany?: UserBrandCreateManyBrandInputEnvelope
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PromoImageCreateNestedManyWithoutBrandInput = {
    create?: XOR<PromoImageCreateWithoutBrandInput, PromoImageUncheckedCreateWithoutBrandInput> | PromoImageCreateWithoutBrandInput[] | PromoImageUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PromoImageCreateOrConnectWithoutBrandInput | PromoImageCreateOrConnectWithoutBrandInput[]
    createMany?: PromoImageCreateManyBrandInputEnvelope
    connect?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
  }

  export type UserBrandUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<UserBrandCreateWithoutBrandInput, UserBrandUncheckedCreateWithoutBrandInput> | UserBrandCreateWithoutBrandInput[] | UserBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutBrandInput | UserBrandCreateOrConnectWithoutBrandInput[]
    createMany?: UserBrandCreateManyBrandInputEnvelope
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PromoImageUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<PromoImageCreateWithoutBrandInput, PromoImageUncheckedCreateWithoutBrandInput> | PromoImageCreateWithoutBrandInput[] | PromoImageUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PromoImageCreateOrConnectWithoutBrandInput | PromoImageCreateOrConnectWithoutBrandInput[]
    createMany?: PromoImageCreateManyBrandInputEnvelope
    connect?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type UserBrandUpdateManyWithoutBrandNestedInput = {
    create?: XOR<UserBrandCreateWithoutBrandInput, UserBrandUncheckedCreateWithoutBrandInput> | UserBrandCreateWithoutBrandInput[] | UserBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutBrandInput | UserBrandCreateOrConnectWithoutBrandInput[]
    upsert?: UserBrandUpsertWithWhereUniqueWithoutBrandInput | UserBrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: UserBrandCreateManyBrandInputEnvelope
    set?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    disconnect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    delete?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    update?: UserBrandUpdateWithWhereUniqueWithoutBrandInput | UserBrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: UserBrandUpdateManyWithWhereWithoutBrandInput | UserBrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: UserBrandScalarWhereInput | UserBrandScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PromoImageUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PromoImageCreateWithoutBrandInput, PromoImageUncheckedCreateWithoutBrandInput> | PromoImageCreateWithoutBrandInput[] | PromoImageUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PromoImageCreateOrConnectWithoutBrandInput | PromoImageCreateOrConnectWithoutBrandInput[]
    upsert?: PromoImageUpsertWithWhereUniqueWithoutBrandInput | PromoImageUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PromoImageCreateManyBrandInputEnvelope
    set?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    disconnect?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    delete?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    connect?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    update?: PromoImageUpdateWithWhereUniqueWithoutBrandInput | PromoImageUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PromoImageUpdateManyWithWhereWithoutBrandInput | PromoImageUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PromoImageScalarWhereInput | PromoImageScalarWhereInput[]
  }

  export type UserBrandUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<UserBrandCreateWithoutBrandInput, UserBrandUncheckedCreateWithoutBrandInput> | UserBrandCreateWithoutBrandInput[] | UserBrandUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: UserBrandCreateOrConnectWithoutBrandInput | UserBrandCreateOrConnectWithoutBrandInput[]
    upsert?: UserBrandUpsertWithWhereUniqueWithoutBrandInput | UserBrandUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: UserBrandCreateManyBrandInputEnvelope
    set?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    disconnect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    delete?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    connect?: UserBrandWhereUniqueInput | UserBrandWhereUniqueInput[]
    update?: UserBrandUpdateWithWhereUniqueWithoutBrandInput | UserBrandUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: UserBrandUpdateManyWithWhereWithoutBrandInput | UserBrandUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: UserBrandScalarWhereInput | UserBrandScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PromoImageUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<PromoImageCreateWithoutBrandInput, PromoImageUncheckedCreateWithoutBrandInput> | PromoImageCreateWithoutBrandInput[] | PromoImageUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: PromoImageCreateOrConnectWithoutBrandInput | PromoImageCreateOrConnectWithoutBrandInput[]
    upsert?: PromoImageUpsertWithWhereUniqueWithoutBrandInput | PromoImageUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: PromoImageCreateManyBrandInputEnvelope
    set?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    disconnect?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    delete?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    connect?: PromoImageWhereUniqueInput | PromoImageWhereUniqueInput[]
    update?: PromoImageUpdateWithWhereUniqueWithoutBrandInput | PromoImageUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: PromoImageUpdateManyWithWhereWithoutBrandInput | PromoImageUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: PromoImageScalarWhereInput | PromoImageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutProductsInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    connect?: BrandWhereUniqueInput
  }

  export type ProductIconCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductIconCreateWithoutProductInput, ProductIconUncheckedCreateWithoutProductInput> | ProductIconCreateWithoutProductInput[] | ProductIconUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutProductInput | ProductIconCreateOrConnectWithoutProductInput[]
    createMany?: ProductIconCreateManyProductInputEnvelope
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
  }

  export type FlyerPageSlotCreateNestedManyWithoutProductInput = {
    create?: XOR<FlyerPageSlotCreateWithoutProductInput, FlyerPageSlotUncheckedCreateWithoutProductInput> | FlyerPageSlotCreateWithoutProductInput[] | FlyerPageSlotUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutProductInput | FlyerPageSlotCreateOrConnectWithoutProductInput[]
    createMany?: FlyerPageSlotCreateManyProductInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type UserFlyerPageProductCreateNestedManyWithoutProductInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutProductInput, UserFlyerPageProductUncheckedCreateWithoutProductInput> | UserFlyerPageProductCreateWithoutProductInput[] | UserFlyerPageProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutProductInput | UserFlyerPageProductCreateOrConnectWithoutProductInput[]
    createMany?: UserFlyerPageProductCreateManyProductInputEnvelope
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
  }

  export type ProductIconUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductIconCreateWithoutProductInput, ProductIconUncheckedCreateWithoutProductInput> | ProductIconCreateWithoutProductInput[] | ProductIconUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutProductInput | ProductIconCreateOrConnectWithoutProductInput[]
    createMany?: ProductIconCreateManyProductInputEnvelope
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
  }

  export type FlyerPageSlotUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<FlyerPageSlotCreateWithoutProductInput, FlyerPageSlotUncheckedCreateWithoutProductInput> | FlyerPageSlotCreateWithoutProductInput[] | FlyerPageSlotUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutProductInput | FlyerPageSlotCreateOrConnectWithoutProductInput[]
    createMany?: FlyerPageSlotCreateManyProductInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type UserFlyerPageProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutProductInput, UserFlyerPageProductUncheckedCreateWithoutProductInput> | UserFlyerPageProductCreateWithoutProductInput[] | UserFlyerPageProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutProductInput | UserFlyerPageProductCreateOrConnectWithoutProductInput[]
    createMany?: UserFlyerPageProductCreateManyProductInputEnvelope
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>, UserUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    upsert?: BrandUpsertWithoutProductsInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductsInput, BrandUpdateWithoutProductsInput>, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type ProductIconUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductIconCreateWithoutProductInput, ProductIconUncheckedCreateWithoutProductInput> | ProductIconCreateWithoutProductInput[] | ProductIconUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutProductInput | ProductIconCreateOrConnectWithoutProductInput[]
    upsert?: ProductIconUpsertWithWhereUniqueWithoutProductInput | ProductIconUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductIconCreateManyProductInputEnvelope
    set?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    disconnect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    delete?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    update?: ProductIconUpdateWithWhereUniqueWithoutProductInput | ProductIconUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductIconUpdateManyWithWhereWithoutProductInput | ProductIconUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductIconScalarWhereInput | ProductIconScalarWhereInput[]
  }

  export type FlyerPageSlotUpdateManyWithoutProductNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutProductInput, FlyerPageSlotUncheckedCreateWithoutProductInput> | FlyerPageSlotCreateWithoutProductInput[] | FlyerPageSlotUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutProductInput | FlyerPageSlotCreateOrConnectWithoutProductInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutProductInput | FlyerPageSlotUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FlyerPageSlotCreateManyProductInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutProductInput | FlyerPageSlotUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutProductInput | FlyerPageSlotUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type UserFlyerPageProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutProductInput, UserFlyerPageProductUncheckedCreateWithoutProductInput> | UserFlyerPageProductCreateWithoutProductInput[] | UserFlyerPageProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutProductInput | UserFlyerPageProductCreateOrConnectWithoutProductInput[]
    upsert?: UserFlyerPageProductUpsertWithWhereUniqueWithoutProductInput | UserFlyerPageProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: UserFlyerPageProductCreateManyProductInputEnvelope
    set?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    disconnect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    delete?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    update?: UserFlyerPageProductUpdateWithWhereUniqueWithoutProductInput | UserFlyerPageProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: UserFlyerPageProductUpdateManyWithWhereWithoutProductInput | UserFlyerPageProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: UserFlyerPageProductScalarWhereInput | UserFlyerPageProductScalarWhereInput[]
  }

  export type ProductIconUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductIconCreateWithoutProductInput, ProductIconUncheckedCreateWithoutProductInput> | ProductIconCreateWithoutProductInput[] | ProductIconUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutProductInput | ProductIconCreateOrConnectWithoutProductInput[]
    upsert?: ProductIconUpsertWithWhereUniqueWithoutProductInput | ProductIconUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductIconCreateManyProductInputEnvelope
    set?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    disconnect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    delete?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    update?: ProductIconUpdateWithWhereUniqueWithoutProductInput | ProductIconUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductIconUpdateManyWithWhereWithoutProductInput | ProductIconUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductIconScalarWhereInput | ProductIconScalarWhereInput[]
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutProductInput, FlyerPageSlotUncheckedCreateWithoutProductInput> | FlyerPageSlotCreateWithoutProductInput[] | FlyerPageSlotUncheckedCreateWithoutProductInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutProductInput | FlyerPageSlotCreateOrConnectWithoutProductInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutProductInput | FlyerPageSlotUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: FlyerPageSlotCreateManyProductInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutProductInput | FlyerPageSlotUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutProductInput | FlyerPageSlotUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type UserFlyerPageProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutProductInput, UserFlyerPageProductUncheckedCreateWithoutProductInput> | UserFlyerPageProductCreateWithoutProductInput[] | UserFlyerPageProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutProductInput | UserFlyerPageProductCreateOrConnectWithoutProductInput[]
    upsert?: UserFlyerPageProductUpsertWithWhereUniqueWithoutProductInput | UserFlyerPageProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: UserFlyerPageProductCreateManyProductInputEnvelope
    set?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    disconnect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    delete?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    update?: UserFlyerPageProductUpdateWithWhereUniqueWithoutProductInput | UserFlyerPageProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: UserFlyerPageProductUpdateManyWithWhereWithoutProductInput | UserFlyerPageProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: UserFlyerPageProductScalarWhereInput | UserFlyerPageProductScalarWhereInput[]
  }

  export type ProductIconCreateNestedManyWithoutIconInput = {
    create?: XOR<ProductIconCreateWithoutIconInput, ProductIconUncheckedCreateWithoutIconInput> | ProductIconCreateWithoutIconInput[] | ProductIconUncheckedCreateWithoutIconInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutIconInput | ProductIconCreateOrConnectWithoutIconInput[]
    createMany?: ProductIconCreateManyIconInputEnvelope
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
  }

  export type ProductIconUncheckedCreateNestedManyWithoutIconInput = {
    create?: XOR<ProductIconCreateWithoutIconInput, ProductIconUncheckedCreateWithoutIconInput> | ProductIconCreateWithoutIconInput[] | ProductIconUncheckedCreateWithoutIconInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutIconInput | ProductIconCreateOrConnectWithoutIconInput[]
    createMany?: ProductIconCreateManyIconInputEnvelope
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
  }

  export type ProductIconUpdateManyWithoutIconNestedInput = {
    create?: XOR<ProductIconCreateWithoutIconInput, ProductIconUncheckedCreateWithoutIconInput> | ProductIconCreateWithoutIconInput[] | ProductIconUncheckedCreateWithoutIconInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutIconInput | ProductIconCreateOrConnectWithoutIconInput[]
    upsert?: ProductIconUpsertWithWhereUniqueWithoutIconInput | ProductIconUpsertWithWhereUniqueWithoutIconInput[]
    createMany?: ProductIconCreateManyIconInputEnvelope
    set?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    disconnect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    delete?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    update?: ProductIconUpdateWithWhereUniqueWithoutIconInput | ProductIconUpdateWithWhereUniqueWithoutIconInput[]
    updateMany?: ProductIconUpdateManyWithWhereWithoutIconInput | ProductIconUpdateManyWithWhereWithoutIconInput[]
    deleteMany?: ProductIconScalarWhereInput | ProductIconScalarWhereInput[]
  }

  export type ProductIconUncheckedUpdateManyWithoutIconNestedInput = {
    create?: XOR<ProductIconCreateWithoutIconInput, ProductIconUncheckedCreateWithoutIconInput> | ProductIconCreateWithoutIconInput[] | ProductIconUncheckedCreateWithoutIconInput[]
    connectOrCreate?: ProductIconCreateOrConnectWithoutIconInput | ProductIconCreateOrConnectWithoutIconInput[]
    upsert?: ProductIconUpsertWithWhereUniqueWithoutIconInput | ProductIconUpsertWithWhereUniqueWithoutIconInput[]
    createMany?: ProductIconCreateManyIconInputEnvelope
    set?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    disconnect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    delete?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    connect?: ProductIconWhereUniqueInput | ProductIconWhereUniqueInput[]
    update?: ProductIconUpdateWithWhereUniqueWithoutIconInput | ProductIconUpdateWithWhereUniqueWithoutIconInput[]
    updateMany?: ProductIconUpdateManyWithWhereWithoutIconInput | ProductIconUpdateManyWithWhereWithoutIconInput[]
    deleteMany?: ProductIconScalarWhereInput | ProductIconScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutIconsInput = {
    create?: XOR<ProductCreateWithoutIconsInput, ProductUncheckedCreateWithoutIconsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIconsInput
    connect?: ProductWhereUniqueInput
  }

  export type IconCreateNestedOneWithoutProductIconsInput = {
    create?: XOR<IconCreateWithoutProductIconsInput, IconUncheckedCreateWithoutProductIconsInput>
    connectOrCreate?: IconCreateOrConnectWithoutProductIconsInput
    connect?: IconWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutIconsNestedInput = {
    create?: XOR<ProductCreateWithoutIconsInput, ProductUncheckedCreateWithoutIconsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutIconsInput
    upsert?: ProductUpsertWithoutIconsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutIconsInput, ProductUpdateWithoutIconsInput>, ProductUncheckedUpdateWithoutIconsInput>
  }

  export type IconUpdateOneRequiredWithoutProductIconsNestedInput = {
    create?: XOR<IconCreateWithoutProductIconsInput, IconUncheckedCreateWithoutProductIconsInput>
    connectOrCreate?: IconCreateOrConnectWithoutProductIconsInput
    upsert?: IconUpsertWithoutProductIconsInput
    connect?: IconWhereUniqueInput
    update?: XOR<XOR<IconUpdateToOneWithWhereWithoutProductIconsInput, IconUpdateWithoutProductIconsInput>, IconUncheckedUpdateWithoutProductIconsInput>
  }

  export type BrandCreateNestedOneWithoutPromoImagesInput = {
    create?: XOR<BrandCreateWithoutPromoImagesInput, BrandUncheckedCreateWithoutPromoImagesInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPromoImagesInput
    connect?: BrandWhereUniqueInput
  }

  export type FlyerPageSlotCreateNestedManyWithoutPromoImageInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoImageInput, FlyerPageSlotUncheckedCreateWithoutPromoImageInput> | FlyerPageSlotCreateWithoutPromoImageInput[] | FlyerPageSlotUncheckedCreateWithoutPromoImageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoImageInput | FlyerPageSlotCreateOrConnectWithoutPromoImageInput[]
    createMany?: FlyerPageSlotCreateManyPromoImageInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type FlyerPageCreateNestedManyWithoutFooterPromoImageInput = {
    create?: XOR<FlyerPageCreateWithoutFooterPromoImageInput, FlyerPageUncheckedCreateWithoutFooterPromoImageInput> | FlyerPageCreateWithoutFooterPromoImageInput[] | FlyerPageUncheckedCreateWithoutFooterPromoImageInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFooterPromoImageInput | FlyerPageCreateOrConnectWithoutFooterPromoImageInput[]
    createMany?: FlyerPageCreateManyFooterPromoImageInputEnvelope
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
  }

  export type FlyerPageSlotUncheckedCreateNestedManyWithoutPromoImageInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoImageInput, FlyerPageSlotUncheckedCreateWithoutPromoImageInput> | FlyerPageSlotCreateWithoutPromoImageInput[] | FlyerPageSlotUncheckedCreateWithoutPromoImageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoImageInput | FlyerPageSlotCreateOrConnectWithoutPromoImageInput[]
    createMany?: FlyerPageSlotCreateManyPromoImageInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type FlyerPageUncheckedCreateNestedManyWithoutFooterPromoImageInput = {
    create?: XOR<FlyerPageCreateWithoutFooterPromoImageInput, FlyerPageUncheckedCreateWithoutFooterPromoImageInput> | FlyerPageCreateWithoutFooterPromoImageInput[] | FlyerPageUncheckedCreateWithoutFooterPromoImageInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFooterPromoImageInput | FlyerPageCreateOrConnectWithoutFooterPromoImageInput[]
    createMany?: FlyerPageCreateManyFooterPromoImageInputEnvelope
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
  }

  export type EnumPromoSlotSizeFieldUpdateOperationsInput = {
    set?: $Enums.PromoSlotSize
  }

  export type BrandUpdateOneWithoutPromoImagesNestedInput = {
    create?: XOR<BrandCreateWithoutPromoImagesInput, BrandUncheckedCreateWithoutPromoImagesInput>
    connectOrCreate?: BrandCreateOrConnectWithoutPromoImagesInput
    upsert?: BrandUpsertWithoutPromoImagesInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutPromoImagesInput, BrandUpdateWithoutPromoImagesInput>, BrandUncheckedUpdateWithoutPromoImagesInput>
  }

  export type FlyerPageSlotUpdateManyWithoutPromoImageNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoImageInput, FlyerPageSlotUncheckedCreateWithoutPromoImageInput> | FlyerPageSlotCreateWithoutPromoImageInput[] | FlyerPageSlotUncheckedCreateWithoutPromoImageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoImageInput | FlyerPageSlotCreateOrConnectWithoutPromoImageInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutPromoImageInput | FlyerPageSlotUpsertWithWhereUniqueWithoutPromoImageInput[]
    createMany?: FlyerPageSlotCreateManyPromoImageInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutPromoImageInput | FlyerPageSlotUpdateWithWhereUniqueWithoutPromoImageInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutPromoImageInput | FlyerPageSlotUpdateManyWithWhereWithoutPromoImageInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type FlyerPageUpdateManyWithoutFooterPromoImageNestedInput = {
    create?: XOR<FlyerPageCreateWithoutFooterPromoImageInput, FlyerPageUncheckedCreateWithoutFooterPromoImageInput> | FlyerPageCreateWithoutFooterPromoImageInput[] | FlyerPageUncheckedCreateWithoutFooterPromoImageInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFooterPromoImageInput | FlyerPageCreateOrConnectWithoutFooterPromoImageInput[]
    upsert?: FlyerPageUpsertWithWhereUniqueWithoutFooterPromoImageInput | FlyerPageUpsertWithWhereUniqueWithoutFooterPromoImageInput[]
    createMany?: FlyerPageCreateManyFooterPromoImageInputEnvelope
    set?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    disconnect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    delete?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    update?: FlyerPageUpdateWithWhereUniqueWithoutFooterPromoImageInput | FlyerPageUpdateWithWhereUniqueWithoutFooterPromoImageInput[]
    updateMany?: FlyerPageUpdateManyWithWhereWithoutFooterPromoImageInput | FlyerPageUpdateManyWithWhereWithoutFooterPromoImageInput[]
    deleteMany?: FlyerPageScalarWhereInput | FlyerPageScalarWhereInput[]
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutPromoImageNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoImageInput, FlyerPageSlotUncheckedCreateWithoutPromoImageInput> | FlyerPageSlotCreateWithoutPromoImageInput[] | FlyerPageSlotUncheckedCreateWithoutPromoImageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoImageInput | FlyerPageSlotCreateOrConnectWithoutPromoImageInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutPromoImageInput | FlyerPageSlotUpsertWithWhereUniqueWithoutPromoImageInput[]
    createMany?: FlyerPageSlotCreateManyPromoImageInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutPromoImageInput | FlyerPageSlotUpdateWithWhereUniqueWithoutPromoImageInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutPromoImageInput | FlyerPageSlotUpdateManyWithWhereWithoutPromoImageInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type FlyerPageUncheckedUpdateManyWithoutFooterPromoImageNestedInput = {
    create?: XOR<FlyerPageCreateWithoutFooterPromoImageInput, FlyerPageUncheckedCreateWithoutFooterPromoImageInput> | FlyerPageCreateWithoutFooterPromoImageInput[] | FlyerPageUncheckedCreateWithoutFooterPromoImageInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFooterPromoImageInput | FlyerPageCreateOrConnectWithoutFooterPromoImageInput[]
    upsert?: FlyerPageUpsertWithWhereUniqueWithoutFooterPromoImageInput | FlyerPageUpsertWithWhereUniqueWithoutFooterPromoImageInput[]
    createMany?: FlyerPageCreateManyFooterPromoImageInputEnvelope
    set?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    disconnect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    delete?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    update?: FlyerPageUpdateWithWhereUniqueWithoutFooterPromoImageInput | FlyerPageUpdateWithWhereUniqueWithoutFooterPromoImageInput[]
    updateMany?: FlyerPageUpdateManyWithWhereWithoutFooterPromoImageInput | FlyerPageUpdateManyWithWhereWithoutFooterPromoImageInput[]
    deleteMany?: FlyerPageScalarWhereInput | FlyerPageScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFlyersInput = {
    create?: XOR<UserCreateWithoutFlyersInput, UserUncheckedCreateWithoutFlyersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlyersInput
    connect?: UserWhereUniqueInput
  }

  export type FlyerPageCreateNestedManyWithoutFlyerInput = {
    create?: XOR<FlyerPageCreateWithoutFlyerInput, FlyerPageUncheckedCreateWithoutFlyerInput> | FlyerPageCreateWithoutFlyerInput[] | FlyerPageUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFlyerInput | FlyerPageCreateOrConnectWithoutFlyerInput[]
    createMany?: FlyerPageCreateManyFlyerInputEnvelope
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
  }

  export type VerificationLogCreateNestedManyWithoutFlyerInput = {
    create?: XOR<VerificationLogCreateWithoutFlyerInput, VerificationLogUncheckedCreateWithoutFlyerInput> | VerificationLogCreateWithoutFlyerInput[] | VerificationLogUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: VerificationLogCreateOrConnectWithoutFlyerInput | VerificationLogCreateOrConnectWithoutFlyerInput[]
    createMany?: VerificationLogCreateManyFlyerInputEnvelope
    connect?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutFlyerInput = {
    create?: XOR<ApprovalCreateWithoutFlyerInput, ApprovalUncheckedCreateWithoutFlyerInput> | ApprovalCreateWithoutFlyerInput[] | ApprovalUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutFlyerInput | ApprovalCreateOrConnectWithoutFlyerInput[]
    createMany?: ApprovalCreateManyFlyerInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ApprovalWorkflowCreateNestedOneWithoutFlyerInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutFlyerInput, ApprovalWorkflowUncheckedCreateWithoutFlyerInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutFlyerInput
    connect?: ApprovalWorkflowWhereUniqueInput
  }

  export type FlyerVersionCreateNestedManyWithoutFlyerInput = {
    create?: XOR<FlyerVersionCreateWithoutFlyerInput, FlyerVersionUncheckedCreateWithoutFlyerInput> | FlyerVersionCreateWithoutFlyerInput[] | FlyerVersionUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerVersionCreateOrConnectWithoutFlyerInput | FlyerVersionCreateOrConnectWithoutFlyerInput[]
    createMany?: FlyerVersionCreateManyFlyerInputEnvelope
    connect?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
  }

  export type FlyerEditHistoryCreateNestedManyWithoutFlyerInput = {
    create?: XOR<FlyerEditHistoryCreateWithoutFlyerInput, FlyerEditHistoryUncheckedCreateWithoutFlyerInput> | FlyerEditHistoryCreateWithoutFlyerInput[] | FlyerEditHistoryUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerEditHistoryCreateOrConnectWithoutFlyerInput | FlyerEditHistoryCreateOrConnectWithoutFlyerInput[]
    createMany?: FlyerEditHistoryCreateManyFlyerInputEnvelope
    connect?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
  }

  export type FlyerPageUncheckedCreateNestedManyWithoutFlyerInput = {
    create?: XOR<FlyerPageCreateWithoutFlyerInput, FlyerPageUncheckedCreateWithoutFlyerInput> | FlyerPageCreateWithoutFlyerInput[] | FlyerPageUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFlyerInput | FlyerPageCreateOrConnectWithoutFlyerInput[]
    createMany?: FlyerPageCreateManyFlyerInputEnvelope
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
  }

  export type VerificationLogUncheckedCreateNestedManyWithoutFlyerInput = {
    create?: XOR<VerificationLogCreateWithoutFlyerInput, VerificationLogUncheckedCreateWithoutFlyerInput> | VerificationLogCreateWithoutFlyerInput[] | VerificationLogUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: VerificationLogCreateOrConnectWithoutFlyerInput | VerificationLogCreateOrConnectWithoutFlyerInput[]
    createMany?: VerificationLogCreateManyFlyerInputEnvelope
    connect?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutFlyerInput = {
    create?: XOR<ApprovalCreateWithoutFlyerInput, ApprovalUncheckedCreateWithoutFlyerInput> | ApprovalCreateWithoutFlyerInput[] | ApprovalUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutFlyerInput | ApprovalCreateOrConnectWithoutFlyerInput[]
    createMany?: ApprovalCreateManyFlyerInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutFlyerInput, ApprovalWorkflowUncheckedCreateWithoutFlyerInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutFlyerInput
    connect?: ApprovalWorkflowWhereUniqueInput
  }

  export type FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput = {
    create?: XOR<FlyerVersionCreateWithoutFlyerInput, FlyerVersionUncheckedCreateWithoutFlyerInput> | FlyerVersionCreateWithoutFlyerInput[] | FlyerVersionUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerVersionCreateOrConnectWithoutFlyerInput | FlyerVersionCreateOrConnectWithoutFlyerInput[]
    createMany?: FlyerVersionCreateManyFlyerInputEnvelope
    connect?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
  }

  export type FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput = {
    create?: XOR<FlyerEditHistoryCreateWithoutFlyerInput, FlyerEditHistoryUncheckedCreateWithoutFlyerInput> | FlyerEditHistoryCreateWithoutFlyerInput[] | FlyerEditHistoryUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerEditHistoryCreateOrConnectWithoutFlyerInput | FlyerEditHistoryCreateOrConnectWithoutFlyerInput[]
    createMany?: FlyerEditHistoryCreateManyFlyerInputEnvelope
    connect?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
  }

  export type EnumFlyerStatusFieldUpdateOperationsInput = {
    set?: $Enums.FlyerStatus
  }

  export type UserUpdateOneRequiredWithoutFlyersNestedInput = {
    create?: XOR<UserCreateWithoutFlyersInput, UserUncheckedCreateWithoutFlyersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlyersInput
    upsert?: UserUpsertWithoutFlyersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlyersInput, UserUpdateWithoutFlyersInput>, UserUncheckedUpdateWithoutFlyersInput>
  }

  export type FlyerPageUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<FlyerPageCreateWithoutFlyerInput, FlyerPageUncheckedCreateWithoutFlyerInput> | FlyerPageCreateWithoutFlyerInput[] | FlyerPageUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFlyerInput | FlyerPageCreateOrConnectWithoutFlyerInput[]
    upsert?: FlyerPageUpsertWithWhereUniqueWithoutFlyerInput | FlyerPageUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: FlyerPageCreateManyFlyerInputEnvelope
    set?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    disconnect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    delete?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    update?: FlyerPageUpdateWithWhereUniqueWithoutFlyerInput | FlyerPageUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: FlyerPageUpdateManyWithWhereWithoutFlyerInput | FlyerPageUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: FlyerPageScalarWhereInput | FlyerPageScalarWhereInput[]
  }

  export type VerificationLogUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<VerificationLogCreateWithoutFlyerInput, VerificationLogUncheckedCreateWithoutFlyerInput> | VerificationLogCreateWithoutFlyerInput[] | VerificationLogUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: VerificationLogCreateOrConnectWithoutFlyerInput | VerificationLogCreateOrConnectWithoutFlyerInput[]
    upsert?: VerificationLogUpsertWithWhereUniqueWithoutFlyerInput | VerificationLogUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: VerificationLogCreateManyFlyerInputEnvelope
    set?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    disconnect?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    delete?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    connect?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    update?: VerificationLogUpdateWithWhereUniqueWithoutFlyerInput | VerificationLogUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: VerificationLogUpdateManyWithWhereWithoutFlyerInput | VerificationLogUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: VerificationLogScalarWhereInput | VerificationLogScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<ApprovalCreateWithoutFlyerInput, ApprovalUncheckedCreateWithoutFlyerInput> | ApprovalCreateWithoutFlyerInput[] | ApprovalUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutFlyerInput | ApprovalCreateOrConnectWithoutFlyerInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutFlyerInput | ApprovalUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: ApprovalCreateManyFlyerInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutFlyerInput | ApprovalUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutFlyerInput | ApprovalUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ApprovalWorkflowUpdateOneWithoutFlyerNestedInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutFlyerInput, ApprovalWorkflowUncheckedCreateWithoutFlyerInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutFlyerInput
    upsert?: ApprovalWorkflowUpsertWithoutFlyerInput
    disconnect?: ApprovalWorkflowWhereInput | boolean
    delete?: ApprovalWorkflowWhereInput | boolean
    connect?: ApprovalWorkflowWhereUniqueInput
    update?: XOR<XOR<ApprovalWorkflowUpdateToOneWithWhereWithoutFlyerInput, ApprovalWorkflowUpdateWithoutFlyerInput>, ApprovalWorkflowUncheckedUpdateWithoutFlyerInput>
  }

  export type FlyerVersionUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<FlyerVersionCreateWithoutFlyerInput, FlyerVersionUncheckedCreateWithoutFlyerInput> | FlyerVersionCreateWithoutFlyerInput[] | FlyerVersionUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerVersionCreateOrConnectWithoutFlyerInput | FlyerVersionCreateOrConnectWithoutFlyerInput[]
    upsert?: FlyerVersionUpsertWithWhereUniqueWithoutFlyerInput | FlyerVersionUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: FlyerVersionCreateManyFlyerInputEnvelope
    set?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    disconnect?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    delete?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    connect?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    update?: FlyerVersionUpdateWithWhereUniqueWithoutFlyerInput | FlyerVersionUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: FlyerVersionUpdateManyWithWhereWithoutFlyerInput | FlyerVersionUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: FlyerVersionScalarWhereInput | FlyerVersionScalarWhereInput[]
  }

  export type FlyerEditHistoryUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<FlyerEditHistoryCreateWithoutFlyerInput, FlyerEditHistoryUncheckedCreateWithoutFlyerInput> | FlyerEditHistoryCreateWithoutFlyerInput[] | FlyerEditHistoryUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerEditHistoryCreateOrConnectWithoutFlyerInput | FlyerEditHistoryCreateOrConnectWithoutFlyerInput[]
    upsert?: FlyerEditHistoryUpsertWithWhereUniqueWithoutFlyerInput | FlyerEditHistoryUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: FlyerEditHistoryCreateManyFlyerInputEnvelope
    set?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    disconnect?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    delete?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    connect?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    update?: FlyerEditHistoryUpdateWithWhereUniqueWithoutFlyerInput | FlyerEditHistoryUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: FlyerEditHistoryUpdateManyWithWhereWithoutFlyerInput | FlyerEditHistoryUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: FlyerEditHistoryScalarWhereInput | FlyerEditHistoryScalarWhereInput[]
  }

  export type FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<FlyerPageCreateWithoutFlyerInput, FlyerPageUncheckedCreateWithoutFlyerInput> | FlyerPageCreateWithoutFlyerInput[] | FlyerPageUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerPageCreateOrConnectWithoutFlyerInput | FlyerPageCreateOrConnectWithoutFlyerInput[]
    upsert?: FlyerPageUpsertWithWhereUniqueWithoutFlyerInput | FlyerPageUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: FlyerPageCreateManyFlyerInputEnvelope
    set?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    disconnect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    delete?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    connect?: FlyerPageWhereUniqueInput | FlyerPageWhereUniqueInput[]
    update?: FlyerPageUpdateWithWhereUniqueWithoutFlyerInput | FlyerPageUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: FlyerPageUpdateManyWithWhereWithoutFlyerInput | FlyerPageUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: FlyerPageScalarWhereInput | FlyerPageScalarWhereInput[]
  }

  export type VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<VerificationLogCreateWithoutFlyerInput, VerificationLogUncheckedCreateWithoutFlyerInput> | VerificationLogCreateWithoutFlyerInput[] | VerificationLogUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: VerificationLogCreateOrConnectWithoutFlyerInput | VerificationLogCreateOrConnectWithoutFlyerInput[]
    upsert?: VerificationLogUpsertWithWhereUniqueWithoutFlyerInput | VerificationLogUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: VerificationLogCreateManyFlyerInputEnvelope
    set?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    disconnect?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    delete?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    connect?: VerificationLogWhereUniqueInput | VerificationLogWhereUniqueInput[]
    update?: VerificationLogUpdateWithWhereUniqueWithoutFlyerInput | VerificationLogUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: VerificationLogUpdateManyWithWhereWithoutFlyerInput | VerificationLogUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: VerificationLogScalarWhereInput | VerificationLogScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<ApprovalCreateWithoutFlyerInput, ApprovalUncheckedCreateWithoutFlyerInput> | ApprovalCreateWithoutFlyerInput[] | ApprovalUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutFlyerInput | ApprovalCreateOrConnectWithoutFlyerInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutFlyerInput | ApprovalUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: ApprovalCreateManyFlyerInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutFlyerInput | ApprovalUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutFlyerInput | ApprovalUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput = {
    create?: XOR<ApprovalWorkflowCreateWithoutFlyerInput, ApprovalWorkflowUncheckedCreateWithoutFlyerInput>
    connectOrCreate?: ApprovalWorkflowCreateOrConnectWithoutFlyerInput
    upsert?: ApprovalWorkflowUpsertWithoutFlyerInput
    disconnect?: ApprovalWorkflowWhereInput | boolean
    delete?: ApprovalWorkflowWhereInput | boolean
    connect?: ApprovalWorkflowWhereUniqueInput
    update?: XOR<XOR<ApprovalWorkflowUpdateToOneWithWhereWithoutFlyerInput, ApprovalWorkflowUpdateWithoutFlyerInput>, ApprovalWorkflowUncheckedUpdateWithoutFlyerInput>
  }

  export type FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<FlyerVersionCreateWithoutFlyerInput, FlyerVersionUncheckedCreateWithoutFlyerInput> | FlyerVersionCreateWithoutFlyerInput[] | FlyerVersionUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerVersionCreateOrConnectWithoutFlyerInput | FlyerVersionCreateOrConnectWithoutFlyerInput[]
    upsert?: FlyerVersionUpsertWithWhereUniqueWithoutFlyerInput | FlyerVersionUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: FlyerVersionCreateManyFlyerInputEnvelope
    set?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    disconnect?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    delete?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    connect?: FlyerVersionWhereUniqueInput | FlyerVersionWhereUniqueInput[]
    update?: FlyerVersionUpdateWithWhereUniqueWithoutFlyerInput | FlyerVersionUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: FlyerVersionUpdateManyWithWhereWithoutFlyerInput | FlyerVersionUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: FlyerVersionScalarWhereInput | FlyerVersionScalarWhereInput[]
  }

  export type FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput = {
    create?: XOR<FlyerEditHistoryCreateWithoutFlyerInput, FlyerEditHistoryUncheckedCreateWithoutFlyerInput> | FlyerEditHistoryCreateWithoutFlyerInput[] | FlyerEditHistoryUncheckedCreateWithoutFlyerInput[]
    connectOrCreate?: FlyerEditHistoryCreateOrConnectWithoutFlyerInput | FlyerEditHistoryCreateOrConnectWithoutFlyerInput[]
    upsert?: FlyerEditHistoryUpsertWithWhereUniqueWithoutFlyerInput | FlyerEditHistoryUpsertWithWhereUniqueWithoutFlyerInput[]
    createMany?: FlyerEditHistoryCreateManyFlyerInputEnvelope
    set?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    disconnect?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    delete?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    connect?: FlyerEditHistoryWhereUniqueInput | FlyerEditHistoryWhereUniqueInput[]
    update?: FlyerEditHistoryUpdateWithWhereUniqueWithoutFlyerInput | FlyerEditHistoryUpdateWithWhereUniqueWithoutFlyerInput[]
    updateMany?: FlyerEditHistoryUpdateManyWithWhereWithoutFlyerInput | FlyerEditHistoryUpdateManyWithWhereWithoutFlyerInput[]
    deleteMany?: FlyerEditHistoryScalarWhereInput | FlyerEditHistoryScalarWhereInput[]
  }

  export type FlyerCreateNestedOneWithoutPagesInput = {
    create?: XOR<FlyerCreateWithoutPagesInput, FlyerUncheckedCreateWithoutPagesInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutPagesInput
    connect?: FlyerWhereUniqueInput
  }

  export type FlyerPageSlotCreateNestedManyWithoutPageInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPageInput, FlyerPageSlotUncheckedCreateWithoutPageInput> | FlyerPageSlotCreateWithoutPageInput[] | FlyerPageSlotUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPageInput | FlyerPageSlotCreateOrConnectWithoutPageInput[]
    createMany?: FlyerPageSlotCreateManyPageInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type PromoImageCreateNestedOneWithoutFooterPagesInput = {
    create?: XOR<PromoImageCreateWithoutFooterPagesInput, PromoImageUncheckedCreateWithoutFooterPagesInput>
    connectOrCreate?: PromoImageCreateOrConnectWithoutFooterPagesInput
    connect?: PromoImageWhereUniqueInput
  }

  export type FlyerPageSlotUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPageInput, FlyerPageSlotUncheckedCreateWithoutPageInput> | FlyerPageSlotCreateWithoutPageInput[] | FlyerPageSlotUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPageInput | FlyerPageSlotCreateOrConnectWithoutPageInput[]
    createMany?: FlyerPageSlotCreateManyPageInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type FlyerUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<FlyerCreateWithoutPagesInput, FlyerUncheckedCreateWithoutPagesInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutPagesInput
    upsert?: FlyerUpsertWithoutPagesInput
    connect?: FlyerWhereUniqueInput
    update?: XOR<XOR<FlyerUpdateToOneWithWhereWithoutPagesInput, FlyerUpdateWithoutPagesInput>, FlyerUncheckedUpdateWithoutPagesInput>
  }

  export type FlyerPageSlotUpdateManyWithoutPageNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPageInput, FlyerPageSlotUncheckedCreateWithoutPageInput> | FlyerPageSlotCreateWithoutPageInput[] | FlyerPageSlotUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPageInput | FlyerPageSlotCreateOrConnectWithoutPageInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutPageInput | FlyerPageSlotUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: FlyerPageSlotCreateManyPageInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutPageInput | FlyerPageSlotUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutPageInput | FlyerPageSlotUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type PromoImageUpdateOneWithoutFooterPagesNestedInput = {
    create?: XOR<PromoImageCreateWithoutFooterPagesInput, PromoImageUncheckedCreateWithoutFooterPagesInput>
    connectOrCreate?: PromoImageCreateOrConnectWithoutFooterPagesInput
    upsert?: PromoImageUpsertWithoutFooterPagesInput
    disconnect?: PromoImageWhereInput | boolean
    delete?: PromoImageWhereInput | boolean
    connect?: PromoImageWhereUniqueInput
    update?: XOR<XOR<PromoImageUpdateToOneWithWhereWithoutFooterPagesInput, PromoImageUpdateWithoutFooterPagesInput>, PromoImageUncheckedUpdateWithoutFooterPagesInput>
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPageInput, FlyerPageSlotUncheckedCreateWithoutPageInput> | FlyerPageSlotCreateWithoutPageInput[] | FlyerPageSlotUncheckedCreateWithoutPageInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPageInput | FlyerPageSlotCreateOrConnectWithoutPageInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutPageInput | FlyerPageSlotUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: FlyerPageSlotCreateManyPageInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutPageInput | FlyerPageSlotUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutPageInput | FlyerPageSlotUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type FlyerPageCreateNestedOneWithoutSlotsInput = {
    create?: XOR<FlyerPageCreateWithoutSlotsInput, FlyerPageUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: FlyerPageCreateOrConnectWithoutSlotsInput
    connect?: FlyerPageWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutFlyerPageSlotsInput = {
    create?: XOR<ProductCreateWithoutFlyerPageSlotsInput, ProductUncheckedCreateWithoutFlyerPageSlotsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFlyerPageSlotsInput
    connect?: ProductWhereUniqueInput
  }

  export type PromoImageCreateNestedOneWithoutFlyerPageSlotsInput = {
    create?: XOR<PromoImageCreateWithoutFlyerPageSlotsInput, PromoImageUncheckedCreateWithoutFlyerPageSlotsInput>
    connectOrCreate?: PromoImageCreateOrConnectWithoutFlyerPageSlotsInput
    connect?: PromoImageWhereUniqueInput
  }

  export type FlyerPageSlotCreateNestedOneWithoutPromoSpannedSlotsInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoSpannedSlotsInput, FlyerPageSlotUncheckedCreateWithoutPromoSpannedSlotsInput>
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoSpannedSlotsInput
    connect?: FlyerPageSlotWhereUniqueInput
  }

  export type FlyerPageSlotCreateNestedManyWithoutPromoAnchorInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoAnchorInput, FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput> | FlyerPageSlotCreateWithoutPromoAnchorInput[] | FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput | FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput[]
    createMany?: FlyerPageSlotCreateManyPromoAnchorInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type FlyerPageSlotUncheckedCreateNestedManyWithoutPromoAnchorInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoAnchorInput, FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput> | FlyerPageSlotCreateWithoutPromoAnchorInput[] | FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput | FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput[]
    createMany?: FlyerPageSlotCreateManyPromoAnchorInputEnvelope
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
  }

  export type EnumSlotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SlotType
  }

  export type NullableEnumPromoSlotSizeFieldUpdateOperationsInput = {
    set?: $Enums.PromoSlotSize | null
  }

  export type FlyerPageUpdateOneRequiredWithoutSlotsNestedInput = {
    create?: XOR<FlyerPageCreateWithoutSlotsInput, FlyerPageUncheckedCreateWithoutSlotsInput>
    connectOrCreate?: FlyerPageCreateOrConnectWithoutSlotsInput
    upsert?: FlyerPageUpsertWithoutSlotsInput
    connect?: FlyerPageWhereUniqueInput
    update?: XOR<XOR<FlyerPageUpdateToOneWithWhereWithoutSlotsInput, FlyerPageUpdateWithoutSlotsInput>, FlyerPageUncheckedUpdateWithoutSlotsInput>
  }

  export type ProductUpdateOneWithoutFlyerPageSlotsNestedInput = {
    create?: XOR<ProductCreateWithoutFlyerPageSlotsInput, ProductUncheckedCreateWithoutFlyerPageSlotsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutFlyerPageSlotsInput
    upsert?: ProductUpsertWithoutFlyerPageSlotsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutFlyerPageSlotsInput, ProductUpdateWithoutFlyerPageSlotsInput>, ProductUncheckedUpdateWithoutFlyerPageSlotsInput>
  }

  export type PromoImageUpdateOneWithoutFlyerPageSlotsNestedInput = {
    create?: XOR<PromoImageCreateWithoutFlyerPageSlotsInput, PromoImageUncheckedCreateWithoutFlyerPageSlotsInput>
    connectOrCreate?: PromoImageCreateOrConnectWithoutFlyerPageSlotsInput
    upsert?: PromoImageUpsertWithoutFlyerPageSlotsInput
    disconnect?: PromoImageWhereInput | boolean
    delete?: PromoImageWhereInput | boolean
    connect?: PromoImageWhereUniqueInput
    update?: XOR<XOR<PromoImageUpdateToOneWithWhereWithoutFlyerPageSlotsInput, PromoImageUpdateWithoutFlyerPageSlotsInput>, PromoImageUncheckedUpdateWithoutFlyerPageSlotsInput>
  }

  export type FlyerPageSlotUpdateOneWithoutPromoSpannedSlotsNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoSpannedSlotsInput, FlyerPageSlotUncheckedCreateWithoutPromoSpannedSlotsInput>
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoSpannedSlotsInput
    upsert?: FlyerPageSlotUpsertWithoutPromoSpannedSlotsInput
    disconnect?: FlyerPageSlotWhereInput | boolean
    delete?: FlyerPageSlotWhereInput | boolean
    connect?: FlyerPageSlotWhereUniqueInput
    update?: XOR<XOR<FlyerPageSlotUpdateToOneWithWhereWithoutPromoSpannedSlotsInput, FlyerPageSlotUpdateWithoutPromoSpannedSlotsInput>, FlyerPageSlotUncheckedUpdateWithoutPromoSpannedSlotsInput>
  }

  export type FlyerPageSlotUpdateManyWithoutPromoAnchorNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoAnchorInput, FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput> | FlyerPageSlotCreateWithoutPromoAnchorInput[] | FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput | FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutPromoAnchorInput | FlyerPageSlotUpsertWithWhereUniqueWithoutPromoAnchorInput[]
    createMany?: FlyerPageSlotCreateManyPromoAnchorInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutPromoAnchorInput | FlyerPageSlotUpdateWithWhereUniqueWithoutPromoAnchorInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutPromoAnchorInput | FlyerPageSlotUpdateManyWithWhereWithoutPromoAnchorInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorNestedInput = {
    create?: XOR<FlyerPageSlotCreateWithoutPromoAnchorInput, FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput> | FlyerPageSlotCreateWithoutPromoAnchorInput[] | FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput[]
    connectOrCreate?: FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput | FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput[]
    upsert?: FlyerPageSlotUpsertWithWhereUniqueWithoutPromoAnchorInput | FlyerPageSlotUpsertWithWhereUniqueWithoutPromoAnchorInput[]
    createMany?: FlyerPageSlotCreateManyPromoAnchorInputEnvelope
    set?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    disconnect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    delete?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    connect?: FlyerPageSlotWhereUniqueInput | FlyerPageSlotWhereUniqueInput[]
    update?: FlyerPageSlotUpdateWithWhereUniqueWithoutPromoAnchorInput | FlyerPageSlotUpdateWithWhereUniqueWithoutPromoAnchorInput[]
    updateMany?: FlyerPageSlotUpdateManyWithWhereWithoutPromoAnchorInput | FlyerPageSlotUpdateManyWithWhereWithoutPromoAnchorInput[]
    deleteMany?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
  }

  export type FlyerCreateNestedOneWithoutVerificationLogsInput = {
    create?: XOR<FlyerCreateWithoutVerificationLogsInput, FlyerUncheckedCreateWithoutVerificationLogsInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutVerificationLogsInput
    connect?: FlyerWhereUniqueInput
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type FlyerUpdateOneRequiredWithoutVerificationLogsNestedInput = {
    create?: XOR<FlyerCreateWithoutVerificationLogsInput, FlyerUncheckedCreateWithoutVerificationLogsInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutVerificationLogsInput
    upsert?: FlyerUpsertWithoutVerificationLogsInput
    connect?: FlyerWhereUniqueInput
    update?: XOR<XOR<FlyerUpdateToOneWithWhereWithoutVerificationLogsInput, FlyerUpdateWithoutVerificationLogsInput>, FlyerUncheckedUpdateWithoutVerificationLogsInput>
  }

  export type FlyerCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<FlyerCreateWithoutApprovalsInput, FlyerUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutApprovalsInput
    connect?: FlyerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type FlyerUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<FlyerCreateWithoutApprovalsInput, FlyerUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutApprovalsInput
    upsert?: FlyerUpsertWithoutApprovalsInput
    connect?: FlyerWhereUniqueInput
    update?: XOR<XOR<FlyerUpdateToOneWithWhereWithoutApprovalsInput, FlyerUpdateWithoutApprovalsInput>, FlyerUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput
    upsert?: UserUpsertWithoutApprovalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalsInput, UserUpdateWithoutApprovalsInput>, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type FlyerCreateNestedOneWithoutApprovalWorkflowInput = {
    create?: XOR<FlyerCreateWithoutApprovalWorkflowInput, FlyerUncheckedCreateWithoutApprovalWorkflowInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutApprovalWorkflowInput
    connect?: FlyerWhereUniqueInput
  }

  export type FlyerUpdateOneRequiredWithoutApprovalWorkflowNestedInput = {
    create?: XOR<FlyerCreateWithoutApprovalWorkflowInput, FlyerUncheckedCreateWithoutApprovalWorkflowInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutApprovalWorkflowInput
    upsert?: FlyerUpsertWithoutApprovalWorkflowInput
    connect?: FlyerWhereUniqueInput
    update?: XOR<XOR<FlyerUpdateToOneWithWhereWithoutApprovalWorkflowInput, FlyerUpdateWithoutApprovalWorkflowInput>, FlyerUncheckedUpdateWithoutApprovalWorkflowInput>
  }

  export type FlyerCreateNestedOneWithoutVersionsInput = {
    create?: XOR<FlyerCreateWithoutVersionsInput, FlyerUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutVersionsInput
    connect?: FlyerWhereUniqueInput
  }

  export type FlyerUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<FlyerCreateWithoutVersionsInput, FlyerUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutVersionsInput
    upsert?: FlyerUpsertWithoutVersionsInput
    connect?: FlyerWhereUniqueInput
    update?: XOR<XOR<FlyerUpdateToOneWithWhereWithoutVersionsInput, FlyerUpdateWithoutVersionsInput>, FlyerUncheckedUpdateWithoutVersionsInput>
  }

  export type FlyerCreateNestedOneWithoutEditHistoryInput = {
    create?: XOR<FlyerCreateWithoutEditHistoryInput, FlyerUncheckedCreateWithoutEditHistoryInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutEditHistoryInput
    connect?: FlyerWhereUniqueInput
  }

  export type EnumFlyerActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.FlyerActionType
  }

  export type FlyerUpdateOneRequiredWithoutEditHistoryNestedInput = {
    create?: XOR<FlyerCreateWithoutEditHistoryInput, FlyerUncheckedCreateWithoutEditHistoryInput>
    connectOrCreate?: FlyerCreateOrConnectWithoutEditHistoryInput
    upsert?: FlyerUpsertWithoutEditHistoryInput
    connect?: FlyerWhereUniqueInput
    update?: XOR<XOR<FlyerUpdateToOneWithWhereWithoutEditHistoryInput, FlyerUpdateWithoutEditHistoryInput>, FlyerUncheckedUpdateWithoutEditHistoryInput>
  }

  export type UserCreateNestedOneWithoutUserFlyersInput = {
    create?: XOR<UserCreateWithoutUserFlyersInput, UserUncheckedCreateWithoutUserFlyersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFlyersInput
    connect?: UserWhereUniqueInput
  }

  export type UserFlyerPageCreateNestedManyWithoutUserFlyerInput = {
    create?: XOR<UserFlyerPageCreateWithoutUserFlyerInput, UserFlyerPageUncheckedCreateWithoutUserFlyerInput> | UserFlyerPageCreateWithoutUserFlyerInput[] | UserFlyerPageUncheckedCreateWithoutUserFlyerInput[]
    connectOrCreate?: UserFlyerPageCreateOrConnectWithoutUserFlyerInput | UserFlyerPageCreateOrConnectWithoutUserFlyerInput[]
    createMany?: UserFlyerPageCreateManyUserFlyerInputEnvelope
    connect?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
  }

  export type UserFlyerPageUncheckedCreateNestedManyWithoutUserFlyerInput = {
    create?: XOR<UserFlyerPageCreateWithoutUserFlyerInput, UserFlyerPageUncheckedCreateWithoutUserFlyerInput> | UserFlyerPageCreateWithoutUserFlyerInput[] | UserFlyerPageUncheckedCreateWithoutUserFlyerInput[]
    connectOrCreate?: UserFlyerPageCreateOrConnectWithoutUserFlyerInput | UserFlyerPageCreateOrConnectWithoutUserFlyerInput[]
    createMany?: UserFlyerPageCreateManyUserFlyerInputEnvelope
    connect?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutUserFlyersNestedInput = {
    create?: XOR<UserCreateWithoutUserFlyersInput, UserUncheckedCreateWithoutUserFlyersInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserFlyersInput
    upsert?: UserUpsertWithoutUserFlyersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserFlyersInput, UserUpdateWithoutUserFlyersInput>, UserUncheckedUpdateWithoutUserFlyersInput>
  }

  export type UserFlyerPageUpdateManyWithoutUserFlyerNestedInput = {
    create?: XOR<UserFlyerPageCreateWithoutUserFlyerInput, UserFlyerPageUncheckedCreateWithoutUserFlyerInput> | UserFlyerPageCreateWithoutUserFlyerInput[] | UserFlyerPageUncheckedCreateWithoutUserFlyerInput[]
    connectOrCreate?: UserFlyerPageCreateOrConnectWithoutUserFlyerInput | UserFlyerPageCreateOrConnectWithoutUserFlyerInput[]
    upsert?: UserFlyerPageUpsertWithWhereUniqueWithoutUserFlyerInput | UserFlyerPageUpsertWithWhereUniqueWithoutUserFlyerInput[]
    createMany?: UserFlyerPageCreateManyUserFlyerInputEnvelope
    set?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    disconnect?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    delete?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    connect?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    update?: UserFlyerPageUpdateWithWhereUniqueWithoutUserFlyerInput | UserFlyerPageUpdateWithWhereUniqueWithoutUserFlyerInput[]
    updateMany?: UserFlyerPageUpdateManyWithWhereWithoutUserFlyerInput | UserFlyerPageUpdateManyWithWhereWithoutUserFlyerInput[]
    deleteMany?: UserFlyerPageScalarWhereInput | UserFlyerPageScalarWhereInput[]
  }

  export type UserFlyerPageUncheckedUpdateManyWithoutUserFlyerNestedInput = {
    create?: XOR<UserFlyerPageCreateWithoutUserFlyerInput, UserFlyerPageUncheckedCreateWithoutUserFlyerInput> | UserFlyerPageCreateWithoutUserFlyerInput[] | UserFlyerPageUncheckedCreateWithoutUserFlyerInput[]
    connectOrCreate?: UserFlyerPageCreateOrConnectWithoutUserFlyerInput | UserFlyerPageCreateOrConnectWithoutUserFlyerInput[]
    upsert?: UserFlyerPageUpsertWithWhereUniqueWithoutUserFlyerInput | UserFlyerPageUpsertWithWhereUniqueWithoutUserFlyerInput[]
    createMany?: UserFlyerPageCreateManyUserFlyerInputEnvelope
    set?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    disconnect?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    delete?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    connect?: UserFlyerPageWhereUniqueInput | UserFlyerPageWhereUniqueInput[]
    update?: UserFlyerPageUpdateWithWhereUniqueWithoutUserFlyerInput | UserFlyerPageUpdateWithWhereUniqueWithoutUserFlyerInput[]
    updateMany?: UserFlyerPageUpdateManyWithWhereWithoutUserFlyerInput | UserFlyerPageUpdateManyWithWhereWithoutUserFlyerInput[]
    deleteMany?: UserFlyerPageScalarWhereInput | UserFlyerPageScalarWhereInput[]
  }

  export type UserFlyerCreateNestedOneWithoutPagesInput = {
    create?: XOR<UserFlyerCreateWithoutPagesInput, UserFlyerUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserFlyerCreateOrConnectWithoutPagesInput
    connect?: UserFlyerWhereUniqueInput
  }

  export type UserFlyerPageProductCreateNestedManyWithoutPageInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutPageInput, UserFlyerPageProductUncheckedCreateWithoutPageInput> | UserFlyerPageProductCreateWithoutPageInput[] | UserFlyerPageProductUncheckedCreateWithoutPageInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutPageInput | UserFlyerPageProductCreateOrConnectWithoutPageInput[]
    createMany?: UserFlyerPageProductCreateManyPageInputEnvelope
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
  }

  export type UserFlyerPageProductUncheckedCreateNestedManyWithoutPageInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutPageInput, UserFlyerPageProductUncheckedCreateWithoutPageInput> | UserFlyerPageProductCreateWithoutPageInput[] | UserFlyerPageProductUncheckedCreateWithoutPageInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutPageInput | UserFlyerPageProductCreateOrConnectWithoutPageInput[]
    createMany?: UserFlyerPageProductCreateManyPageInputEnvelope
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
  }

  export type UserFlyerUpdateOneRequiredWithoutPagesNestedInput = {
    create?: XOR<UserFlyerCreateWithoutPagesInput, UserFlyerUncheckedCreateWithoutPagesInput>
    connectOrCreate?: UserFlyerCreateOrConnectWithoutPagesInput
    upsert?: UserFlyerUpsertWithoutPagesInput
    connect?: UserFlyerWhereUniqueInput
    update?: XOR<XOR<UserFlyerUpdateToOneWithWhereWithoutPagesInput, UserFlyerUpdateWithoutPagesInput>, UserFlyerUncheckedUpdateWithoutPagesInput>
  }

  export type UserFlyerPageProductUpdateManyWithoutPageNestedInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutPageInput, UserFlyerPageProductUncheckedCreateWithoutPageInput> | UserFlyerPageProductCreateWithoutPageInput[] | UserFlyerPageProductUncheckedCreateWithoutPageInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutPageInput | UserFlyerPageProductCreateOrConnectWithoutPageInput[]
    upsert?: UserFlyerPageProductUpsertWithWhereUniqueWithoutPageInput | UserFlyerPageProductUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: UserFlyerPageProductCreateManyPageInputEnvelope
    set?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    disconnect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    delete?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    update?: UserFlyerPageProductUpdateWithWhereUniqueWithoutPageInput | UserFlyerPageProductUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: UserFlyerPageProductUpdateManyWithWhereWithoutPageInput | UserFlyerPageProductUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: UserFlyerPageProductScalarWhereInput | UserFlyerPageProductScalarWhereInput[]
  }

  export type UserFlyerPageProductUncheckedUpdateManyWithoutPageNestedInput = {
    create?: XOR<UserFlyerPageProductCreateWithoutPageInput, UserFlyerPageProductUncheckedCreateWithoutPageInput> | UserFlyerPageProductCreateWithoutPageInput[] | UserFlyerPageProductUncheckedCreateWithoutPageInput[]
    connectOrCreate?: UserFlyerPageProductCreateOrConnectWithoutPageInput | UserFlyerPageProductCreateOrConnectWithoutPageInput[]
    upsert?: UserFlyerPageProductUpsertWithWhereUniqueWithoutPageInput | UserFlyerPageProductUpsertWithWhereUniqueWithoutPageInput[]
    createMany?: UserFlyerPageProductCreateManyPageInputEnvelope
    set?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    disconnect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    delete?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    connect?: UserFlyerPageProductWhereUniqueInput | UserFlyerPageProductWhereUniqueInput[]
    update?: UserFlyerPageProductUpdateWithWhereUniqueWithoutPageInput | UserFlyerPageProductUpdateWithWhereUniqueWithoutPageInput[]
    updateMany?: UserFlyerPageProductUpdateManyWithWhereWithoutPageInput | UserFlyerPageProductUpdateManyWithWhereWithoutPageInput[]
    deleteMany?: UserFlyerPageProductScalarWhereInput | UserFlyerPageProductScalarWhereInput[]
  }

  export type UserFlyerPageCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserFlyerPageCreateWithoutProductsInput, UserFlyerPageUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserFlyerPageCreateOrConnectWithoutProductsInput
    connect?: UserFlyerPageWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutUserFlyerPageProductsInput = {
    create?: XOR<ProductCreateWithoutUserFlyerPageProductsInput, ProductUncheckedCreateWithoutUserFlyerPageProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutUserFlyerPageProductsInput
    connect?: ProductWhereUniqueInput
  }

  export type UserFlyerPageUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserFlyerPageCreateWithoutProductsInput, UserFlyerPageUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserFlyerPageCreateOrConnectWithoutProductsInput
    upsert?: UserFlyerPageUpsertWithoutProductsInput
    connect?: UserFlyerPageWhereUniqueInput
    update?: XOR<XOR<UserFlyerPageUpdateToOneWithWhereWithoutProductsInput, UserFlyerPageUpdateWithoutProductsInput>, UserFlyerPageUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutUserFlyerPageProductsNestedInput = {
    create?: XOR<ProductCreateWithoutUserFlyerPageProductsInput, ProductUncheckedCreateWithoutUserFlyerPageProductsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutUserFlyerPageProductsInput
    upsert?: ProductUpsertWithoutUserFlyerPageProductsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutUserFlyerPageProductsInput, ProductUpdateWithoutUserFlyerPageProductsInput>, ProductUncheckedUpdateWithoutUserFlyerPageProductsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Buffer
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel>
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Buffer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPromoSlotSizeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoSlotSizeFilter<$PrismaModel> | $Enums.PromoSlotSize
  }

  export type NestedEnumPromoSlotSizeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel>
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromoSlotSizeWithAggregatesFilter<$PrismaModel> | $Enums.PromoSlotSize
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromoSlotSizeFilter<$PrismaModel>
    _max?: NestedEnumPromoSlotSizeFilter<$PrismaModel>
  }

  export type NestedEnumFlyerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerStatus | EnumFlyerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerStatusFilter<$PrismaModel> | $Enums.FlyerStatus
  }

  export type NestedEnumFlyerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerStatus | EnumFlyerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerStatus[] | ListEnumFlyerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlyerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlyerStatusFilter<$PrismaModel>
    _max?: NestedEnumFlyerStatusFilter<$PrismaModel>
  }

  export type NestedEnumSlotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeFilter<$PrismaModel> | $Enums.SlotType
  }

  export type NestedEnumPromoSlotSizeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromoSlotSizeNullableFilter<$PrismaModel> | $Enums.PromoSlotSize | null
  }

  export type NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SlotType | EnumSlotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SlotType[] | ListEnumSlotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSlotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SlotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSlotTypeFilter<$PrismaModel>
    _max?: NestedEnumSlotTypeFilter<$PrismaModel>
  }

  export type NestedEnumPromoSlotSizeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromoSlotSize | EnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PromoSlotSize[] | ListEnumPromoSlotSizeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPromoSlotSizeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PromoSlotSize | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPromoSlotSizeNullableFilter<$PrismaModel>
    _max?: NestedEnumPromoSlotSizeNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumFlyerActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerActionType | EnumFlyerActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerActionTypeFilter<$PrismaModel> | $Enums.FlyerActionType
  }

  export type NestedEnumFlyerActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlyerActionType | EnumFlyerActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlyerActionType[] | ListEnumFlyerActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlyerActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.FlyerActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlyerActionTypeFilter<$PrismaModel>
    _max?: NestedEnumFlyerActionTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserBrandCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    brand: BrandCreateNestedOneWithoutUsersInput
  }

  export type UserBrandUncheckedCreateWithoutUserInput = {
    id?: string
    brandId: string
    createdAt?: Date | string
  }

  export type UserBrandCreateOrConnectWithoutUserInput = {
    where: UserBrandWhereUniqueInput
    create: XOR<UserBrandCreateWithoutUserInput, UserBrandUncheckedCreateWithoutUserInput>
  }

  export type UserBrandCreateManyUserInputEnvelope = {
    data: UserBrandCreateManyUserInput | UserBrandCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSupplierInput = {
    id?: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    icons?: ProductIconCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSupplierInput = {
    id?: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ProductIconUncheckedCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductCreateManySupplierInputEnvelope = {
    data: ProductCreateManySupplierInput | ProductCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type FlyerCreateWithoutSupplierInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutSupplierInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutSupplierInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutSupplierInput, FlyerUncheckedCreateWithoutSupplierInput>
  }

  export type FlyerCreateManySupplierInputEnvelope = {
    data: FlyerCreateManySupplierInput | FlyerCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutApproverInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
    flyer: FlyerCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    flyerId: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApprovalCreateOrConnectWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalCreateManyApproverInputEnvelope = {
    data: ApprovalCreateManyApproverInput | ApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type UserFlyerCreateWithoutUserInput = {
    id?: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: UserFlyerPageCreateNestedManyWithoutUserFlyerInput
  }

  export type UserFlyerUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pages?: UserFlyerPageUncheckedCreateNestedManyWithoutUserFlyerInput
  }

  export type UserFlyerCreateOrConnectWithoutUserInput = {
    where: UserFlyerWhereUniqueInput
    create: XOR<UserFlyerCreateWithoutUserInput, UserFlyerUncheckedCreateWithoutUserInput>
  }

  export type UserFlyerCreateManyUserInputEnvelope = {
    data: UserFlyerCreateManyUserInput | UserFlyerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBrandUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBrandWhereUniqueInput
    update: XOR<UserBrandUpdateWithoutUserInput, UserBrandUncheckedUpdateWithoutUserInput>
    create: XOR<UserBrandCreateWithoutUserInput, UserBrandUncheckedCreateWithoutUserInput>
  }

  export type UserBrandUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBrandWhereUniqueInput
    data: XOR<UserBrandUpdateWithoutUserInput, UserBrandUncheckedUpdateWithoutUserInput>
  }

  export type UserBrandUpdateManyWithWhereWithoutUserInput = {
    where: UserBrandScalarWhereInput
    data: XOR<UserBrandUpdateManyMutationInput, UserBrandUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBrandScalarWhereInput = {
    AND?: UserBrandScalarWhereInput | UserBrandScalarWhereInput[]
    OR?: UserBrandScalarWhereInput[]
    NOT?: UserBrandScalarWhereInput | UserBrandScalarWhereInput[]
    id?: StringFilter<"UserBrand"> | string
    userId?: StringFilter<"UserBrand"> | string
    brandId?: StringFilter<"UserBrand"> | string
    createdAt?: DateTimeFilter<"UserBrand"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
    create: XOR<ProductCreateWithoutSupplierInput, ProductUncheckedCreateWithoutSupplierInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSupplierInput, ProductUncheckedUpdateWithoutSupplierInput>
  }

  export type ProductUpdateManyWithWhereWithoutSupplierInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    supplierId?: StringFilter<"Product"> | string
    brandId?: StringFilter<"Product"> | string
    eanCode?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    imageData?: BytesFilter<"Product"> | Buffer
    imageMimeType?: StringFilter<"Product"> | string
    price?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    originalPrice?: DecimalNullableFilter<"Product"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type FlyerUpsertWithWhereUniqueWithoutSupplierInput = {
    where: FlyerWhereUniqueInput
    update: XOR<FlyerUpdateWithoutSupplierInput, FlyerUncheckedUpdateWithoutSupplierInput>
    create: XOR<FlyerCreateWithoutSupplierInput, FlyerUncheckedCreateWithoutSupplierInput>
  }

  export type FlyerUpdateWithWhereUniqueWithoutSupplierInput = {
    where: FlyerWhereUniqueInput
    data: XOR<FlyerUpdateWithoutSupplierInput, FlyerUncheckedUpdateWithoutSupplierInput>
  }

  export type FlyerUpdateManyWithWhereWithoutSupplierInput = {
    where: FlyerScalarWhereInput
    data: XOR<FlyerUpdateManyMutationInput, FlyerUncheckedUpdateManyWithoutSupplierInput>
  }

  export type FlyerScalarWhereInput = {
    AND?: FlyerScalarWhereInput | FlyerScalarWhereInput[]
    OR?: FlyerScalarWhereInput[]
    NOT?: FlyerScalarWhereInput | FlyerScalarWhereInput[]
    id?: StringFilter<"Flyer"> | string
    supplierId?: StringFilter<"Flyer"> | string
    name?: StringFilter<"Flyer"> | string
    validFrom?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    validTo?: DateTimeNullableFilter<"Flyer"> | Date | string | null
    status?: EnumFlyerStatusFilter<"Flyer"> | $Enums.FlyerStatus
    isDraft?: BoolFilter<"Flyer"> | boolean
    rejectionReason?: StringNullableFilter<"Flyer"> | string | null
    pdfData?: BytesNullableFilter<"Flyer"> | Buffer | null
    pdfMimeType?: StringNullableFilter<"Flyer"> | string | null
    lastEditedAt?: DateTimeFilter<"Flyer"> | Date | string
    autoSaveVersion?: IntFilter<"Flyer"> | number
    completionPercentage?: IntFilter<"Flyer"> | number
    createdAt?: DateTimeFilter<"Flyer"> | Date | string
    updatedAt?: DateTimeFilter<"Flyer"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Flyer"> | Date | string | null
  }

  export type ApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutApproverInput, ApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<ApprovalCreateWithoutApproverInput, ApprovalUncheckedCreateWithoutApproverInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutApproverInput, ApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    OR?: ApprovalScalarWhereInput[]
    NOT?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    id?: StringFilter<"Approval"> | string
    flyerId?: StringFilter<"Approval"> | string
    approverId?: StringFilter<"Approval"> | string
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    comment?: StringNullableFilter<"Approval"> | string | null
    decidedAt?: DateTimeNullableFilter<"Approval"> | Date | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
  }

  export type UserFlyerUpsertWithWhereUniqueWithoutUserInput = {
    where: UserFlyerWhereUniqueInput
    update: XOR<UserFlyerUpdateWithoutUserInput, UserFlyerUncheckedUpdateWithoutUserInput>
    create: XOR<UserFlyerCreateWithoutUserInput, UserFlyerUncheckedCreateWithoutUserInput>
  }

  export type UserFlyerUpdateWithWhereUniqueWithoutUserInput = {
    where: UserFlyerWhereUniqueInput
    data: XOR<UserFlyerUpdateWithoutUserInput, UserFlyerUncheckedUpdateWithoutUserInput>
  }

  export type UserFlyerUpdateManyWithWhereWithoutUserInput = {
    where: UserFlyerScalarWhereInput
    data: XOR<UserFlyerUpdateManyMutationInput, UserFlyerUncheckedUpdateManyWithoutUserInput>
  }

  export type UserFlyerScalarWhereInput = {
    AND?: UserFlyerScalarWhereInput | UserFlyerScalarWhereInput[]
    OR?: UserFlyerScalarWhereInput[]
    NOT?: UserFlyerScalarWhereInput | UserFlyerScalarWhereInput[]
    id?: StringFilter<"UserFlyer"> | string
    userId?: StringFilter<"UserFlyer"> | string
    name?: StringFilter<"UserFlyer"> | string
    isDraft?: BoolFilter<"UserFlyer"> | boolean
    lastEditedAt?: DateTimeFilter<"UserFlyer"> | Date | string
    completionPercentage?: IntFilter<"UserFlyer"> | number
    pdfData?: BytesNullableFilter<"UserFlyer"> | Buffer | null
    pdfMimeType?: StringNullableFilter<"UserFlyer"> | string | null
    createdAt?: DateTimeFilter<"UserFlyer"> | Date | string
    updatedAt?: DateTimeFilter<"UserFlyer"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutBrandsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    products?: ProductCreateNestedManyWithoutSupplierInput
    flyers?: FlyerCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBrandsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    flyers?: FlyerUncheckedCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBrandsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBrandsInput, UserUncheckedCreateWithoutBrandsInput>
  }

  export type BrandCreateWithoutUsersInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutBrandInput
    promoImages?: PromoImageCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
    promoImages?: PromoImageUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutUsersInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutUsersInput, BrandUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutBrandsInput = {
    update: XOR<UserUpdateWithoutBrandsInput, UserUncheckedUpdateWithoutBrandsInput>
    create: XOR<UserCreateWithoutBrandsInput, UserUncheckedCreateWithoutBrandsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBrandsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBrandsInput, UserUncheckedUpdateWithoutBrandsInput>
  }

  export type UserUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBrandsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUncheckedUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BrandUpsertWithoutUsersInput = {
    update: XOR<BrandUpdateWithoutUsersInput, BrandUncheckedUpdateWithoutUsersInput>
    create: XOR<BrandCreateWithoutUsersInput, BrandUncheckedCreateWithoutUsersInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutUsersInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutUsersInput, BrandUncheckedUpdateWithoutUsersInput>
  }

  export type BrandUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutBrandNestedInput
    promoImages?: PromoImageUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
    promoImages?: PromoImageUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type UserBrandCreateWithoutBrandInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutBrandsInput
  }

  export type UserBrandUncheckedCreateWithoutBrandInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type UserBrandCreateOrConnectWithoutBrandInput = {
    where: UserBrandWhereUniqueInput
    create: XOR<UserBrandCreateWithoutBrandInput, UserBrandUncheckedCreateWithoutBrandInput>
  }

  export type UserBrandCreateManyBrandInputEnvelope = {
    data: UserBrandCreateManyBrandInput | UserBrandCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutBrandInput = {
    id?: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: UserCreateNestedOneWithoutProductsInput
    icons?: ProductIconCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id?: string
    supplierId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ProductIconUncheckedCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type PromoImageCreateWithoutBrandInput = {
    id?: string
    supplierId: string
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutPromoImageInput
    footerPages?: FlyerPageCreateNestedManyWithoutFooterPromoImageInput
  }

  export type PromoImageUncheckedCreateWithoutBrandInput = {
    id?: string
    supplierId: string
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoImageInput
    footerPages?: FlyerPageUncheckedCreateNestedManyWithoutFooterPromoImageInput
  }

  export type PromoImageCreateOrConnectWithoutBrandInput = {
    where: PromoImageWhereUniqueInput
    create: XOR<PromoImageCreateWithoutBrandInput, PromoImageUncheckedCreateWithoutBrandInput>
  }

  export type PromoImageCreateManyBrandInputEnvelope = {
    data: PromoImageCreateManyBrandInput | PromoImageCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type UserBrandUpsertWithWhereUniqueWithoutBrandInput = {
    where: UserBrandWhereUniqueInput
    update: XOR<UserBrandUpdateWithoutBrandInput, UserBrandUncheckedUpdateWithoutBrandInput>
    create: XOR<UserBrandCreateWithoutBrandInput, UserBrandUncheckedCreateWithoutBrandInput>
  }

  export type UserBrandUpdateWithWhereUniqueWithoutBrandInput = {
    where: UserBrandWhereUniqueInput
    data: XOR<UserBrandUpdateWithoutBrandInput, UserBrandUncheckedUpdateWithoutBrandInput>
  }

  export type UserBrandUpdateManyWithWhereWithoutBrandInput = {
    where: UserBrandScalarWhereInput
    data: XOR<UserBrandUpdateManyMutationInput, UserBrandUncheckedUpdateManyWithoutBrandInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type PromoImageUpsertWithWhereUniqueWithoutBrandInput = {
    where: PromoImageWhereUniqueInput
    update: XOR<PromoImageUpdateWithoutBrandInput, PromoImageUncheckedUpdateWithoutBrandInput>
    create: XOR<PromoImageCreateWithoutBrandInput, PromoImageUncheckedCreateWithoutBrandInput>
  }

  export type PromoImageUpdateWithWhereUniqueWithoutBrandInput = {
    where: PromoImageWhereUniqueInput
    data: XOR<PromoImageUpdateWithoutBrandInput, PromoImageUncheckedUpdateWithoutBrandInput>
  }

  export type PromoImageUpdateManyWithWhereWithoutBrandInput = {
    where: PromoImageScalarWhereInput
    data: XOR<PromoImageUpdateManyMutationInput, PromoImageUncheckedUpdateManyWithoutBrandInput>
  }

  export type PromoImageScalarWhereInput = {
    AND?: PromoImageScalarWhereInput | PromoImageScalarWhereInput[]
    OR?: PromoImageScalarWhereInput[]
    NOT?: PromoImageScalarWhereInput | PromoImageScalarWhereInput[]
    id?: StringFilter<"PromoImage"> | string
    supplierId?: StringFilter<"PromoImage"> | string
    brandId?: StringNullableFilter<"PromoImage"> | string | null
    name?: StringFilter<"PromoImage"> | string
    imageData?: BytesFilter<"PromoImage"> | Buffer
    imageMimeType?: StringFilter<"PromoImage"> | string
    defaultSize?: EnumPromoSlotSizeFilter<"PromoImage"> | $Enums.PromoSlotSize
    createdAt?: DateTimeFilter<"PromoImage"> | Date | string
  }

  export type UserCreateWithoutProductsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandCreateNestedManyWithoutUserInput
    flyers?: FlyerCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandUncheckedCreateNestedManyWithoutUserInput
    flyers?: FlyerUncheckedCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type BrandCreateWithoutProductsInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserBrandCreateNestedManyWithoutBrandInput
    promoImages?: PromoImageCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserBrandUncheckedCreateNestedManyWithoutBrandInput
    promoImages?: PromoImageUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutProductsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
  }

  export type ProductIconCreateWithoutProductInput = {
    id?: string
    position: number
    icon: IconCreateNestedOneWithoutProductIconsInput
  }

  export type ProductIconUncheckedCreateWithoutProductInput = {
    id?: string
    iconId: string
    position: number
  }

  export type ProductIconCreateOrConnectWithoutProductInput = {
    where: ProductIconWhereUniqueInput
    create: XOR<ProductIconCreateWithoutProductInput, ProductIconUncheckedCreateWithoutProductInput>
  }

  export type ProductIconCreateManyProductInputEnvelope = {
    data: ProductIconCreateManyProductInput | ProductIconCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type FlyerPageSlotCreateWithoutProductInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    page: FlyerPageCreateNestedOneWithoutSlotsInput
    promoImage?: PromoImageCreateNestedOneWithoutFlyerPageSlotsInput
    promoAnchor?: FlyerPageSlotCreateNestedOneWithoutPromoSpannedSlotsInput
    promoSpannedSlots?: FlyerPageSlotCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotUncheckedCreateWithoutProductInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotCreateOrConnectWithoutProductInput = {
    where: FlyerPageSlotWhereUniqueInput
    create: XOR<FlyerPageSlotCreateWithoutProductInput, FlyerPageSlotUncheckedCreateWithoutProductInput>
  }

  export type FlyerPageSlotCreateManyProductInputEnvelope = {
    data: FlyerPageSlotCreateManyProductInput | FlyerPageSlotCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserFlyerPageProductCreateWithoutProductInput = {
    id?: string
    position: number
    page: UserFlyerPageCreateNestedOneWithoutProductsInput
  }

  export type UserFlyerPageProductUncheckedCreateWithoutProductInput = {
    id?: string
    pageId: string
    position: number
  }

  export type UserFlyerPageProductCreateOrConnectWithoutProductInput = {
    where: UserFlyerPageProductWhereUniqueInput
    create: XOR<UserFlyerPageProductCreateWithoutProductInput, UserFlyerPageProductUncheckedCreateWithoutProductInput>
  }

  export type UserFlyerPageProductCreateManyProductInputEnvelope = {
    data: UserFlyerPageProductCreateManyProductInput | UserFlyerPageProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUpdateManyWithoutUserNestedInput
    flyers?: FlyerUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUncheckedUpdateManyWithoutUserNestedInput
    flyers?: FlyerUncheckedUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BrandUpsertWithoutProductsInput = {
    update: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBrandUpdateManyWithoutBrandNestedInput
    promoImages?: PromoImageUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBrandUncheckedUpdateManyWithoutBrandNestedInput
    promoImages?: PromoImageUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type ProductIconUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductIconWhereUniqueInput
    update: XOR<ProductIconUpdateWithoutProductInput, ProductIconUncheckedUpdateWithoutProductInput>
    create: XOR<ProductIconCreateWithoutProductInput, ProductIconUncheckedCreateWithoutProductInput>
  }

  export type ProductIconUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductIconWhereUniqueInput
    data: XOR<ProductIconUpdateWithoutProductInput, ProductIconUncheckedUpdateWithoutProductInput>
  }

  export type ProductIconUpdateManyWithWhereWithoutProductInput = {
    where: ProductIconScalarWhereInput
    data: XOR<ProductIconUpdateManyMutationInput, ProductIconUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductIconScalarWhereInput = {
    AND?: ProductIconScalarWhereInput | ProductIconScalarWhereInput[]
    OR?: ProductIconScalarWhereInput[]
    NOT?: ProductIconScalarWhereInput | ProductIconScalarWhereInput[]
    id?: StringFilter<"ProductIcon"> | string
    productId?: StringFilter<"ProductIcon"> | string
    iconId?: StringFilter<"ProductIcon"> | string
    position?: IntFilter<"ProductIcon"> | number
  }

  export type FlyerPageSlotUpsertWithWhereUniqueWithoutProductInput = {
    where: FlyerPageSlotWhereUniqueInput
    update: XOR<FlyerPageSlotUpdateWithoutProductInput, FlyerPageSlotUncheckedUpdateWithoutProductInput>
    create: XOR<FlyerPageSlotCreateWithoutProductInput, FlyerPageSlotUncheckedCreateWithoutProductInput>
  }

  export type FlyerPageSlotUpdateWithWhereUniqueWithoutProductInput = {
    where: FlyerPageSlotWhereUniqueInput
    data: XOR<FlyerPageSlotUpdateWithoutProductInput, FlyerPageSlotUncheckedUpdateWithoutProductInput>
  }

  export type FlyerPageSlotUpdateManyWithWhereWithoutProductInput = {
    where: FlyerPageSlotScalarWhereInput
    data: XOR<FlyerPageSlotUpdateManyMutationInput, FlyerPageSlotUncheckedUpdateManyWithoutProductInput>
  }

  export type FlyerPageSlotScalarWhereInput = {
    AND?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
    OR?: FlyerPageSlotScalarWhereInput[]
    NOT?: FlyerPageSlotScalarWhereInput | FlyerPageSlotScalarWhereInput[]
    id?: StringFilter<"FlyerPageSlot"> | string
    pageId?: StringFilter<"FlyerPageSlot"> | string
    slotPosition?: IntFilter<"FlyerPageSlot"> | number
    slotType?: EnumSlotTypeFilter<"FlyerPageSlot"> | $Enums.SlotType
    productId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    promoImageId?: StringNullableFilter<"FlyerPageSlot"> | string | null
    promoSize?: EnumPromoSlotSizeNullableFilter<"FlyerPageSlot"> | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFilter<"FlyerPageSlot"> | boolean
    promoAnchorId?: StringNullableFilter<"FlyerPageSlot"> | string | null
  }

  export type UserFlyerPageProductUpsertWithWhereUniqueWithoutProductInput = {
    where: UserFlyerPageProductWhereUniqueInput
    update: XOR<UserFlyerPageProductUpdateWithoutProductInput, UserFlyerPageProductUncheckedUpdateWithoutProductInput>
    create: XOR<UserFlyerPageProductCreateWithoutProductInput, UserFlyerPageProductUncheckedCreateWithoutProductInput>
  }

  export type UserFlyerPageProductUpdateWithWhereUniqueWithoutProductInput = {
    where: UserFlyerPageProductWhereUniqueInput
    data: XOR<UserFlyerPageProductUpdateWithoutProductInput, UserFlyerPageProductUncheckedUpdateWithoutProductInput>
  }

  export type UserFlyerPageProductUpdateManyWithWhereWithoutProductInput = {
    where: UserFlyerPageProductScalarWhereInput
    data: XOR<UserFlyerPageProductUpdateManyMutationInput, UserFlyerPageProductUncheckedUpdateManyWithoutProductInput>
  }

  export type UserFlyerPageProductScalarWhereInput = {
    AND?: UserFlyerPageProductScalarWhereInput | UserFlyerPageProductScalarWhereInput[]
    OR?: UserFlyerPageProductScalarWhereInput[]
    NOT?: UserFlyerPageProductScalarWhereInput | UserFlyerPageProductScalarWhereInput[]
    id?: StringFilter<"UserFlyerPageProduct"> | string
    pageId?: StringFilter<"UserFlyerPageProduct"> | string
    productId?: StringFilter<"UserFlyerPageProduct"> | string
    position?: IntFilter<"UserFlyerPageProduct"> | number
  }

  export type ProductIconCreateWithoutIconInput = {
    id?: string
    position: number
    product: ProductCreateNestedOneWithoutIconsInput
  }

  export type ProductIconUncheckedCreateWithoutIconInput = {
    id?: string
    productId: string
    position: number
  }

  export type ProductIconCreateOrConnectWithoutIconInput = {
    where: ProductIconWhereUniqueInput
    create: XOR<ProductIconCreateWithoutIconInput, ProductIconUncheckedCreateWithoutIconInput>
  }

  export type ProductIconCreateManyIconInputEnvelope = {
    data: ProductIconCreateManyIconInput | ProductIconCreateManyIconInput[]
    skipDuplicates?: boolean
  }

  export type ProductIconUpsertWithWhereUniqueWithoutIconInput = {
    where: ProductIconWhereUniqueInput
    update: XOR<ProductIconUpdateWithoutIconInput, ProductIconUncheckedUpdateWithoutIconInput>
    create: XOR<ProductIconCreateWithoutIconInput, ProductIconUncheckedCreateWithoutIconInput>
  }

  export type ProductIconUpdateWithWhereUniqueWithoutIconInput = {
    where: ProductIconWhereUniqueInput
    data: XOR<ProductIconUpdateWithoutIconInput, ProductIconUncheckedUpdateWithoutIconInput>
  }

  export type ProductIconUpdateManyWithWhereWithoutIconInput = {
    where: ProductIconScalarWhereInput
    data: XOR<ProductIconUpdateManyMutationInput, ProductIconUncheckedUpdateManyWithoutIconInput>
  }

  export type ProductCreateWithoutIconsInput = {
    id?: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: UserCreateNestedOneWithoutProductsInput
    brand: BrandCreateNestedOneWithoutProductsInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutIconsInput = {
    id?: string
    supplierId: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutIconsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutIconsInput, ProductUncheckedCreateWithoutIconsInput>
  }

  export type IconCreateWithoutProductIconsInput = {
    id?: string
    name: string
    imageData: Buffer
    imageMimeType: string
    isEnergyClass?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IconUncheckedCreateWithoutProductIconsInput = {
    id?: string
    name: string
    imageData: Buffer
    imageMimeType: string
    isEnergyClass?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IconCreateOrConnectWithoutProductIconsInput = {
    where: IconWhereUniqueInput
    create: XOR<IconCreateWithoutProductIconsInput, IconUncheckedCreateWithoutProductIconsInput>
  }

  export type ProductUpsertWithoutIconsInput = {
    update: XOR<ProductUpdateWithoutIconsInput, ProductUncheckedUpdateWithoutIconsInput>
    create: XOR<ProductCreateWithoutIconsInput, ProductUncheckedCreateWithoutIconsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutIconsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutIconsInput, ProductUncheckedUpdateWithoutIconsInput>
  }

  export type ProductUpdateWithoutIconsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: UserUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutIconsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type IconUpsertWithoutProductIconsInput = {
    update: XOR<IconUpdateWithoutProductIconsInput, IconUncheckedUpdateWithoutProductIconsInput>
    create: XOR<IconCreateWithoutProductIconsInput, IconUncheckedCreateWithoutProductIconsInput>
    where?: IconWhereInput
  }

  export type IconUpdateToOneWithWhereWithoutProductIconsInput = {
    where?: IconWhereInput
    data: XOR<IconUpdateWithoutProductIconsInput, IconUncheckedUpdateWithoutProductIconsInput>
  }

  export type IconUpdateWithoutProductIconsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    isEnergyClass?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IconUncheckedUpdateWithoutProductIconsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    isEnergyClass?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateWithoutPromoImagesInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserBrandCreateNestedManyWithoutBrandInput
    products?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutPromoImagesInput = {
    id?: string
    name: string
    logoData?: Buffer | null
    logoMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserBrandUncheckedCreateNestedManyWithoutBrandInput
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutPromoImagesInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutPromoImagesInput, BrandUncheckedCreateWithoutPromoImagesInput>
  }

  export type FlyerPageSlotCreateWithoutPromoImageInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    page: FlyerPageCreateNestedOneWithoutSlotsInput
    product?: ProductCreateNestedOneWithoutFlyerPageSlotsInput
    promoAnchor?: FlyerPageSlotCreateNestedOneWithoutPromoSpannedSlotsInput
    promoSpannedSlots?: FlyerPageSlotCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotUncheckedCreateWithoutPromoImageInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotCreateOrConnectWithoutPromoImageInput = {
    where: FlyerPageSlotWhereUniqueInput
    create: XOR<FlyerPageSlotCreateWithoutPromoImageInput, FlyerPageSlotUncheckedCreateWithoutPromoImageInput>
  }

  export type FlyerPageSlotCreateManyPromoImageInputEnvelope = {
    data: FlyerPageSlotCreateManyPromoImageInput | FlyerPageSlotCreateManyPromoImageInput[]
    skipDuplicates?: boolean
  }

  export type FlyerPageCreateWithoutFooterPromoImageInput = {
    id?: string
    pageNumber: number
    flyer: FlyerCreateNestedOneWithoutPagesInput
    slots?: FlyerPageSlotCreateNestedManyWithoutPageInput
  }

  export type FlyerPageUncheckedCreateWithoutFooterPromoImageInput = {
    id?: string
    flyerId: string
    pageNumber: number
    slots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPageInput
  }

  export type FlyerPageCreateOrConnectWithoutFooterPromoImageInput = {
    where: FlyerPageWhereUniqueInput
    create: XOR<FlyerPageCreateWithoutFooterPromoImageInput, FlyerPageUncheckedCreateWithoutFooterPromoImageInput>
  }

  export type FlyerPageCreateManyFooterPromoImageInputEnvelope = {
    data: FlyerPageCreateManyFooterPromoImageInput | FlyerPageCreateManyFooterPromoImageInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutPromoImagesInput = {
    update: XOR<BrandUpdateWithoutPromoImagesInput, BrandUncheckedUpdateWithoutPromoImagesInput>
    create: XOR<BrandCreateWithoutPromoImagesInput, BrandUncheckedCreateWithoutPromoImagesInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutPromoImagesInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutPromoImagesInput, BrandUncheckedUpdateWithoutPromoImagesInput>
  }

  export type BrandUpdateWithoutPromoImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBrandUpdateManyWithoutBrandNestedInput
    products?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutPromoImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    logoData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    logoMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserBrandUncheckedUpdateManyWithoutBrandNestedInput
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type FlyerPageSlotUpsertWithWhereUniqueWithoutPromoImageInput = {
    where: FlyerPageSlotWhereUniqueInput
    update: XOR<FlyerPageSlotUpdateWithoutPromoImageInput, FlyerPageSlotUncheckedUpdateWithoutPromoImageInput>
    create: XOR<FlyerPageSlotCreateWithoutPromoImageInput, FlyerPageSlotUncheckedCreateWithoutPromoImageInput>
  }

  export type FlyerPageSlotUpdateWithWhereUniqueWithoutPromoImageInput = {
    where: FlyerPageSlotWhereUniqueInput
    data: XOR<FlyerPageSlotUpdateWithoutPromoImageInput, FlyerPageSlotUncheckedUpdateWithoutPromoImageInput>
  }

  export type FlyerPageSlotUpdateManyWithWhereWithoutPromoImageInput = {
    where: FlyerPageSlotScalarWhereInput
    data: XOR<FlyerPageSlotUpdateManyMutationInput, FlyerPageSlotUncheckedUpdateManyWithoutPromoImageInput>
  }

  export type FlyerPageUpsertWithWhereUniqueWithoutFooterPromoImageInput = {
    where: FlyerPageWhereUniqueInput
    update: XOR<FlyerPageUpdateWithoutFooterPromoImageInput, FlyerPageUncheckedUpdateWithoutFooterPromoImageInput>
    create: XOR<FlyerPageCreateWithoutFooterPromoImageInput, FlyerPageUncheckedCreateWithoutFooterPromoImageInput>
  }

  export type FlyerPageUpdateWithWhereUniqueWithoutFooterPromoImageInput = {
    where: FlyerPageWhereUniqueInput
    data: XOR<FlyerPageUpdateWithoutFooterPromoImageInput, FlyerPageUncheckedUpdateWithoutFooterPromoImageInput>
  }

  export type FlyerPageUpdateManyWithWhereWithoutFooterPromoImageInput = {
    where: FlyerPageScalarWhereInput
    data: XOR<FlyerPageUpdateManyMutationInput, FlyerPageUncheckedUpdateManyWithoutFooterPromoImageInput>
  }

  export type FlyerPageScalarWhereInput = {
    AND?: FlyerPageScalarWhereInput | FlyerPageScalarWhereInput[]
    OR?: FlyerPageScalarWhereInput[]
    NOT?: FlyerPageScalarWhereInput | FlyerPageScalarWhereInput[]
    id?: StringFilter<"FlyerPage"> | string
    flyerId?: StringFilter<"FlyerPage"> | string
    pageNumber?: IntFilter<"FlyerPage"> | number
    footerPromoImageId?: StringNullableFilter<"FlyerPage"> | string | null
  }

  export type UserCreateWithoutFlyersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlyersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlyersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlyersInput, UserUncheckedCreateWithoutFlyersInput>
  }

  export type FlyerPageCreateWithoutFlyerInput = {
    id?: string
    pageNumber: number
    slots?: FlyerPageSlotCreateNestedManyWithoutPageInput
    footerPromoImage?: PromoImageCreateNestedOneWithoutFooterPagesInput
  }

  export type FlyerPageUncheckedCreateWithoutFlyerInput = {
    id?: string
    pageNumber: number
    footerPromoImageId?: string | null
    slots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPageInput
  }

  export type FlyerPageCreateOrConnectWithoutFlyerInput = {
    where: FlyerPageWhereUniqueInput
    create: XOR<FlyerPageCreateWithoutFlyerInput, FlyerPageUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerPageCreateManyFlyerInputEnvelope = {
    data: FlyerPageCreateManyFlyerInput | FlyerPageCreateManyFlyerInput[]
    skipDuplicates?: boolean
  }

  export type VerificationLogCreateWithoutFlyerInput = {
    id?: string
    verificationDate: Date | string
    status: $Enums.VerificationStatus
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VerificationLogUncheckedCreateWithoutFlyerInput = {
    id?: string
    verificationDate: Date | string
    status: $Enums.VerificationStatus
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type VerificationLogCreateOrConnectWithoutFlyerInput = {
    where: VerificationLogWhereUniqueInput
    create: XOR<VerificationLogCreateWithoutFlyerInput, VerificationLogUncheckedCreateWithoutFlyerInput>
  }

  export type VerificationLogCreateManyFlyerInputEnvelope = {
    data: VerificationLogCreateManyFlyerInput | VerificationLogCreateManyFlyerInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutFlyerInput = {
    id?: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
    approver: UserCreateNestedOneWithoutApprovalsInput
  }

  export type ApprovalUncheckedCreateWithoutFlyerInput = {
    id?: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ApprovalCreateOrConnectWithoutFlyerInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutFlyerInput, ApprovalUncheckedCreateWithoutFlyerInput>
  }

  export type ApprovalCreateManyFlyerInputEnvelope = {
    data: ApprovalCreateManyFlyerInput | ApprovalCreateManyFlyerInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalWorkflowCreateWithoutFlyerInput = {
    id?: string
    requiredApprovers?: number
    currentApprovals?: number
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowUncheckedCreateWithoutFlyerInput = {
    id?: string
    requiredApprovers?: number
    currentApprovals?: number
    isComplete?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalWorkflowCreateOrConnectWithoutFlyerInput = {
    where: ApprovalWorkflowWhereUniqueInput
    create: XOR<ApprovalWorkflowCreateWithoutFlyerInput, ApprovalWorkflowUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerVersionCreateWithoutFlyerInput = {
    id?: string
    versionNumber: number
    snapshotData: JsonNullValueInput | InputJsonValue
    createdBy: string
    changeDescription?: string | null
    createdAt?: Date | string
  }

  export type FlyerVersionUncheckedCreateWithoutFlyerInput = {
    id?: string
    versionNumber: number
    snapshotData: JsonNullValueInput | InputJsonValue
    createdBy: string
    changeDescription?: string | null
    createdAt?: Date | string
  }

  export type FlyerVersionCreateOrConnectWithoutFlyerInput = {
    where: FlyerVersionWhereUniqueInput
    create: XOR<FlyerVersionCreateWithoutFlyerInput, FlyerVersionUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerVersionCreateManyFlyerInputEnvelope = {
    data: FlyerVersionCreateManyFlyerInput | FlyerVersionCreateManyFlyerInput[]
    skipDuplicates?: boolean
  }

  export type FlyerEditHistoryCreateWithoutFlyerInput = {
    id?: string
    userId: string
    actionType: $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlyerEditHistoryUncheckedCreateWithoutFlyerInput = {
    id?: string
    userId: string
    actionType: $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlyerEditHistoryCreateOrConnectWithoutFlyerInput = {
    where: FlyerEditHistoryWhereUniqueInput
    create: XOR<FlyerEditHistoryCreateWithoutFlyerInput, FlyerEditHistoryUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerEditHistoryCreateManyFlyerInputEnvelope = {
    data: FlyerEditHistoryCreateManyFlyerInput | FlyerEditHistoryCreateManyFlyerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFlyersInput = {
    update: XOR<UserUpdateWithoutFlyersInput, UserUncheckedUpdateWithoutFlyersInput>
    create: XOR<UserCreateWithoutFlyersInput, UserUncheckedCreateWithoutFlyersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlyersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlyersInput, UserUncheckedUpdateWithoutFlyersInput>
  }

  export type UserUpdateWithoutFlyersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlyersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FlyerPageUpsertWithWhereUniqueWithoutFlyerInput = {
    where: FlyerPageWhereUniqueInput
    update: XOR<FlyerPageUpdateWithoutFlyerInput, FlyerPageUncheckedUpdateWithoutFlyerInput>
    create: XOR<FlyerPageCreateWithoutFlyerInput, FlyerPageUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerPageUpdateWithWhereUniqueWithoutFlyerInput = {
    where: FlyerPageWhereUniqueInput
    data: XOR<FlyerPageUpdateWithoutFlyerInput, FlyerPageUncheckedUpdateWithoutFlyerInput>
  }

  export type FlyerPageUpdateManyWithWhereWithoutFlyerInput = {
    where: FlyerPageScalarWhereInput
    data: XOR<FlyerPageUpdateManyMutationInput, FlyerPageUncheckedUpdateManyWithoutFlyerInput>
  }

  export type VerificationLogUpsertWithWhereUniqueWithoutFlyerInput = {
    where: VerificationLogWhereUniqueInput
    update: XOR<VerificationLogUpdateWithoutFlyerInput, VerificationLogUncheckedUpdateWithoutFlyerInput>
    create: XOR<VerificationLogCreateWithoutFlyerInput, VerificationLogUncheckedCreateWithoutFlyerInput>
  }

  export type VerificationLogUpdateWithWhereUniqueWithoutFlyerInput = {
    where: VerificationLogWhereUniqueInput
    data: XOR<VerificationLogUpdateWithoutFlyerInput, VerificationLogUncheckedUpdateWithoutFlyerInput>
  }

  export type VerificationLogUpdateManyWithWhereWithoutFlyerInput = {
    where: VerificationLogScalarWhereInput
    data: XOR<VerificationLogUpdateManyMutationInput, VerificationLogUncheckedUpdateManyWithoutFlyerInput>
  }

  export type VerificationLogScalarWhereInput = {
    AND?: VerificationLogScalarWhereInput | VerificationLogScalarWhereInput[]
    OR?: VerificationLogScalarWhereInput[]
    NOT?: VerificationLogScalarWhereInput | VerificationLogScalarWhereInput[]
    id?: StringFilter<"VerificationLog"> | string
    flyerId?: StringFilter<"VerificationLog"> | string
    verificationDate?: DateTimeFilter<"VerificationLog"> | Date | string
    status?: EnumVerificationStatusFilter<"VerificationLog"> | $Enums.VerificationStatus
    details?: JsonFilter<"VerificationLog">
    createdAt?: DateTimeFilter<"VerificationLog"> | Date | string
  }

  export type ApprovalUpsertWithWhereUniqueWithoutFlyerInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutFlyerInput, ApprovalUncheckedUpdateWithoutFlyerInput>
    create: XOR<ApprovalCreateWithoutFlyerInput, ApprovalUncheckedCreateWithoutFlyerInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutFlyerInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutFlyerInput, ApprovalUncheckedUpdateWithoutFlyerInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutFlyerInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutFlyerInput>
  }

  export type ApprovalWorkflowUpsertWithoutFlyerInput = {
    update: XOR<ApprovalWorkflowUpdateWithoutFlyerInput, ApprovalWorkflowUncheckedUpdateWithoutFlyerInput>
    create: XOR<ApprovalWorkflowCreateWithoutFlyerInput, ApprovalWorkflowUncheckedCreateWithoutFlyerInput>
    where?: ApprovalWorkflowWhereInput
  }

  export type ApprovalWorkflowUpdateToOneWithWhereWithoutFlyerInput = {
    where?: ApprovalWorkflowWhereInput
    data: XOR<ApprovalWorkflowUpdateWithoutFlyerInput, ApprovalWorkflowUncheckedUpdateWithoutFlyerInput>
  }

  export type ApprovalWorkflowUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requiredApprovers?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalWorkflowUncheckedUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requiredApprovers?: IntFieldUpdateOperationsInput | number
    currentApprovals?: IntFieldUpdateOperationsInput | number
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionUpsertWithWhereUniqueWithoutFlyerInput = {
    where: FlyerVersionWhereUniqueInput
    update: XOR<FlyerVersionUpdateWithoutFlyerInput, FlyerVersionUncheckedUpdateWithoutFlyerInput>
    create: XOR<FlyerVersionCreateWithoutFlyerInput, FlyerVersionUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerVersionUpdateWithWhereUniqueWithoutFlyerInput = {
    where: FlyerVersionWhereUniqueInput
    data: XOR<FlyerVersionUpdateWithoutFlyerInput, FlyerVersionUncheckedUpdateWithoutFlyerInput>
  }

  export type FlyerVersionUpdateManyWithWhereWithoutFlyerInput = {
    where: FlyerVersionScalarWhereInput
    data: XOR<FlyerVersionUpdateManyMutationInput, FlyerVersionUncheckedUpdateManyWithoutFlyerInput>
  }

  export type FlyerVersionScalarWhereInput = {
    AND?: FlyerVersionScalarWhereInput | FlyerVersionScalarWhereInput[]
    OR?: FlyerVersionScalarWhereInput[]
    NOT?: FlyerVersionScalarWhereInput | FlyerVersionScalarWhereInput[]
    id?: StringFilter<"FlyerVersion"> | string
    flyerId?: StringFilter<"FlyerVersion"> | string
    versionNumber?: IntFilter<"FlyerVersion"> | number
    snapshotData?: JsonFilter<"FlyerVersion">
    createdBy?: StringFilter<"FlyerVersion"> | string
    changeDescription?: StringNullableFilter<"FlyerVersion"> | string | null
    createdAt?: DateTimeFilter<"FlyerVersion"> | Date | string
  }

  export type FlyerEditHistoryUpsertWithWhereUniqueWithoutFlyerInput = {
    where: FlyerEditHistoryWhereUniqueInput
    update: XOR<FlyerEditHistoryUpdateWithoutFlyerInput, FlyerEditHistoryUncheckedUpdateWithoutFlyerInput>
    create: XOR<FlyerEditHistoryCreateWithoutFlyerInput, FlyerEditHistoryUncheckedCreateWithoutFlyerInput>
  }

  export type FlyerEditHistoryUpdateWithWhereUniqueWithoutFlyerInput = {
    where: FlyerEditHistoryWhereUniqueInput
    data: XOR<FlyerEditHistoryUpdateWithoutFlyerInput, FlyerEditHistoryUncheckedUpdateWithoutFlyerInput>
  }

  export type FlyerEditHistoryUpdateManyWithWhereWithoutFlyerInput = {
    where: FlyerEditHistoryScalarWhereInput
    data: XOR<FlyerEditHistoryUpdateManyMutationInput, FlyerEditHistoryUncheckedUpdateManyWithoutFlyerInput>
  }

  export type FlyerEditHistoryScalarWhereInput = {
    AND?: FlyerEditHistoryScalarWhereInput | FlyerEditHistoryScalarWhereInput[]
    OR?: FlyerEditHistoryScalarWhereInput[]
    NOT?: FlyerEditHistoryScalarWhereInput | FlyerEditHistoryScalarWhereInput[]
    id?: StringFilter<"FlyerEditHistory"> | string
    flyerId?: StringFilter<"FlyerEditHistory"> | string
    userId?: StringFilter<"FlyerEditHistory"> | string
    actionType?: EnumFlyerActionTypeFilter<"FlyerEditHistory"> | $Enums.FlyerActionType
    details?: JsonNullableFilter<"FlyerEditHistory">
    createdAt?: DateTimeFilter<"FlyerEditHistory"> | Date | string
  }

  export type FlyerCreateWithoutPagesInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutPagesInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutPagesInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutPagesInput, FlyerUncheckedCreateWithoutPagesInput>
  }

  export type FlyerPageSlotCreateWithoutPageInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    product?: ProductCreateNestedOneWithoutFlyerPageSlotsInput
    promoImage?: PromoImageCreateNestedOneWithoutFlyerPageSlotsInput
    promoAnchor?: FlyerPageSlotCreateNestedOneWithoutPromoSpannedSlotsInput
    promoSpannedSlots?: FlyerPageSlotCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotUncheckedCreateWithoutPageInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotCreateOrConnectWithoutPageInput = {
    where: FlyerPageSlotWhereUniqueInput
    create: XOR<FlyerPageSlotCreateWithoutPageInput, FlyerPageSlotUncheckedCreateWithoutPageInput>
  }

  export type FlyerPageSlotCreateManyPageInputEnvelope = {
    data: FlyerPageSlotCreateManyPageInput | FlyerPageSlotCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type PromoImageCreateWithoutFooterPagesInput = {
    id?: string
    supplierId: string
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    brand?: BrandCreateNestedOneWithoutPromoImagesInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutPromoImageInput
  }

  export type PromoImageUncheckedCreateWithoutFooterPagesInput = {
    id?: string
    supplierId: string
    brandId?: string | null
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoImageInput
  }

  export type PromoImageCreateOrConnectWithoutFooterPagesInput = {
    where: PromoImageWhereUniqueInput
    create: XOR<PromoImageCreateWithoutFooterPagesInput, PromoImageUncheckedCreateWithoutFooterPagesInput>
  }

  export type FlyerUpsertWithoutPagesInput = {
    update: XOR<FlyerUpdateWithoutPagesInput, FlyerUncheckedUpdateWithoutPagesInput>
    create: XOR<FlyerCreateWithoutPagesInput, FlyerUncheckedCreateWithoutPagesInput>
    where?: FlyerWhereInput
  }

  export type FlyerUpdateToOneWithWhereWithoutPagesInput = {
    where?: FlyerWhereInput
    data: XOR<FlyerUpdateWithoutPagesInput, FlyerUncheckedUpdateWithoutPagesInput>
  }

  export type FlyerUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerPageSlotUpsertWithWhereUniqueWithoutPageInput = {
    where: FlyerPageSlotWhereUniqueInput
    update: XOR<FlyerPageSlotUpdateWithoutPageInput, FlyerPageSlotUncheckedUpdateWithoutPageInput>
    create: XOR<FlyerPageSlotCreateWithoutPageInput, FlyerPageSlotUncheckedCreateWithoutPageInput>
  }

  export type FlyerPageSlotUpdateWithWhereUniqueWithoutPageInput = {
    where: FlyerPageSlotWhereUniqueInput
    data: XOR<FlyerPageSlotUpdateWithoutPageInput, FlyerPageSlotUncheckedUpdateWithoutPageInput>
  }

  export type FlyerPageSlotUpdateManyWithWhereWithoutPageInput = {
    where: FlyerPageSlotScalarWhereInput
    data: XOR<FlyerPageSlotUpdateManyMutationInput, FlyerPageSlotUncheckedUpdateManyWithoutPageInput>
  }

  export type PromoImageUpsertWithoutFooterPagesInput = {
    update: XOR<PromoImageUpdateWithoutFooterPagesInput, PromoImageUncheckedUpdateWithoutFooterPagesInput>
    create: XOR<PromoImageCreateWithoutFooterPagesInput, PromoImageUncheckedCreateWithoutFooterPagesInput>
    where?: PromoImageWhereInput
  }

  export type PromoImageUpdateToOneWithWhereWithoutFooterPagesInput = {
    where?: PromoImageWhereInput
    data: XOR<PromoImageUpdateWithoutFooterPagesInput, PromoImageUncheckedUpdateWithoutFooterPagesInput>
  }

  export type PromoImageUpdateWithoutFooterPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneWithoutPromoImagesNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutPromoImageNestedInput
  }

  export type PromoImageUncheckedUpdateWithoutFooterPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoImageNestedInput
  }

  export type FlyerPageCreateWithoutSlotsInput = {
    id?: string
    pageNumber: number
    flyer: FlyerCreateNestedOneWithoutPagesInput
    footerPromoImage?: PromoImageCreateNestedOneWithoutFooterPagesInput
  }

  export type FlyerPageUncheckedCreateWithoutSlotsInput = {
    id?: string
    flyerId: string
    pageNumber: number
    footerPromoImageId?: string | null
  }

  export type FlyerPageCreateOrConnectWithoutSlotsInput = {
    where: FlyerPageWhereUniqueInput
    create: XOR<FlyerPageCreateWithoutSlotsInput, FlyerPageUncheckedCreateWithoutSlotsInput>
  }

  export type ProductCreateWithoutFlyerPageSlotsInput = {
    id?: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: UserCreateNestedOneWithoutProductsInput
    brand: BrandCreateNestedOneWithoutProductsInput
    icons?: ProductIconCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutFlyerPageSlotsInput = {
    id?: string
    supplierId: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ProductIconUncheckedCreateNestedManyWithoutProductInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutFlyerPageSlotsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutFlyerPageSlotsInput, ProductUncheckedCreateWithoutFlyerPageSlotsInput>
  }

  export type PromoImageCreateWithoutFlyerPageSlotsInput = {
    id?: string
    supplierId: string
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    brand?: BrandCreateNestedOneWithoutPromoImagesInput
    footerPages?: FlyerPageCreateNestedManyWithoutFooterPromoImageInput
  }

  export type PromoImageUncheckedCreateWithoutFlyerPageSlotsInput = {
    id?: string
    supplierId: string
    brandId?: string | null
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
    footerPages?: FlyerPageUncheckedCreateNestedManyWithoutFooterPromoImageInput
  }

  export type PromoImageCreateOrConnectWithoutFlyerPageSlotsInput = {
    where: PromoImageWhereUniqueInput
    create: XOR<PromoImageCreateWithoutFlyerPageSlotsInput, PromoImageUncheckedCreateWithoutFlyerPageSlotsInput>
  }

  export type FlyerPageSlotCreateWithoutPromoSpannedSlotsInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    page: FlyerPageCreateNestedOneWithoutSlotsInput
    product?: ProductCreateNestedOneWithoutFlyerPageSlotsInput
    promoImage?: PromoImageCreateNestedOneWithoutFlyerPageSlotsInput
    promoAnchor?: FlyerPageSlotCreateNestedOneWithoutPromoSpannedSlotsInput
  }

  export type FlyerPageSlotUncheckedCreateWithoutPromoSpannedSlotsInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
  }

  export type FlyerPageSlotCreateOrConnectWithoutPromoSpannedSlotsInput = {
    where: FlyerPageSlotWhereUniqueInput
    create: XOR<FlyerPageSlotCreateWithoutPromoSpannedSlotsInput, FlyerPageSlotUncheckedCreateWithoutPromoSpannedSlotsInput>
  }

  export type FlyerPageSlotCreateWithoutPromoAnchorInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    page: FlyerPageCreateNestedOneWithoutSlotsInput
    product?: ProductCreateNestedOneWithoutFlyerPageSlotsInput
    promoImage?: PromoImageCreateNestedOneWithoutFlyerPageSlotsInput
    promoSpannedSlots?: FlyerPageSlotCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoSpannedSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutPromoAnchorInput
  }

  export type FlyerPageSlotCreateOrConnectWithoutPromoAnchorInput = {
    where: FlyerPageSlotWhereUniqueInput
    create: XOR<FlyerPageSlotCreateWithoutPromoAnchorInput, FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput>
  }

  export type FlyerPageSlotCreateManyPromoAnchorInputEnvelope = {
    data: FlyerPageSlotCreateManyPromoAnchorInput | FlyerPageSlotCreateManyPromoAnchorInput[]
    skipDuplicates?: boolean
  }

  export type FlyerPageUpsertWithoutSlotsInput = {
    update: XOR<FlyerPageUpdateWithoutSlotsInput, FlyerPageUncheckedUpdateWithoutSlotsInput>
    create: XOR<FlyerPageCreateWithoutSlotsInput, FlyerPageUncheckedCreateWithoutSlotsInput>
    where?: FlyerPageWhereInput
  }

  export type FlyerPageUpdateToOneWithWhereWithoutSlotsInput = {
    where?: FlyerPageWhereInput
    data: XOR<FlyerPageUpdateWithoutSlotsInput, FlyerPageUncheckedUpdateWithoutSlotsInput>
  }

  export type FlyerPageUpdateWithoutSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    flyer?: FlyerUpdateOneRequiredWithoutPagesNestedInput
    footerPromoImage?: PromoImageUpdateOneWithoutFooterPagesNestedInput
  }

  export type FlyerPageUncheckedUpdateWithoutSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    footerPromoImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithoutFlyerPageSlotsInput = {
    update: XOR<ProductUpdateWithoutFlyerPageSlotsInput, ProductUncheckedUpdateWithoutFlyerPageSlotsInput>
    create: XOR<ProductCreateWithoutFlyerPageSlotsInput, ProductUncheckedCreateWithoutFlyerPageSlotsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutFlyerPageSlotsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutFlyerPageSlotsInput, ProductUncheckedUpdateWithoutFlyerPageSlotsInput>
  }

  export type ProductUpdateWithoutFlyerPageSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: UserUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    icons?: ProductIconUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutFlyerPageSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ProductIconUncheckedUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PromoImageUpsertWithoutFlyerPageSlotsInput = {
    update: XOR<PromoImageUpdateWithoutFlyerPageSlotsInput, PromoImageUncheckedUpdateWithoutFlyerPageSlotsInput>
    create: XOR<PromoImageCreateWithoutFlyerPageSlotsInput, PromoImageUncheckedCreateWithoutFlyerPageSlotsInput>
    where?: PromoImageWhereInput
  }

  export type PromoImageUpdateToOneWithWhereWithoutFlyerPageSlotsInput = {
    where?: PromoImageWhereInput
    data: XOR<PromoImageUpdateWithoutFlyerPageSlotsInput, PromoImageUncheckedUpdateWithoutFlyerPageSlotsInput>
  }

  export type PromoImageUpdateWithoutFlyerPageSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneWithoutPromoImagesNestedInput
    footerPages?: FlyerPageUpdateManyWithoutFooterPromoImageNestedInput
  }

  export type PromoImageUncheckedUpdateWithoutFlyerPageSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    footerPages?: FlyerPageUncheckedUpdateManyWithoutFooterPromoImageNestedInput
  }

  export type FlyerPageSlotUpsertWithoutPromoSpannedSlotsInput = {
    update: XOR<FlyerPageSlotUpdateWithoutPromoSpannedSlotsInput, FlyerPageSlotUncheckedUpdateWithoutPromoSpannedSlotsInput>
    create: XOR<FlyerPageSlotCreateWithoutPromoSpannedSlotsInput, FlyerPageSlotUncheckedCreateWithoutPromoSpannedSlotsInput>
    where?: FlyerPageSlotWhereInput
  }

  export type FlyerPageSlotUpdateToOneWithWhereWithoutPromoSpannedSlotsInput = {
    where?: FlyerPageSlotWhereInput
    data: XOR<FlyerPageSlotUpdateWithoutPromoSpannedSlotsInput, FlyerPageSlotUncheckedUpdateWithoutPromoSpannedSlotsInput>
  }

  export type FlyerPageSlotUpdateWithoutPromoSpannedSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    page?: FlyerPageUpdateOneRequiredWithoutSlotsNestedInput
    product?: ProductUpdateOneWithoutFlyerPageSlotsNestedInput
    promoImage?: PromoImageUpdateOneWithoutFlyerPageSlotsNestedInput
    promoAnchor?: FlyerPageSlotUpdateOneWithoutPromoSpannedSlotsNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateWithoutPromoSpannedSlotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlyerPageSlotUpsertWithWhereUniqueWithoutPromoAnchorInput = {
    where: FlyerPageSlotWhereUniqueInput
    update: XOR<FlyerPageSlotUpdateWithoutPromoAnchorInput, FlyerPageSlotUncheckedUpdateWithoutPromoAnchorInput>
    create: XOR<FlyerPageSlotCreateWithoutPromoAnchorInput, FlyerPageSlotUncheckedCreateWithoutPromoAnchorInput>
  }

  export type FlyerPageSlotUpdateWithWhereUniqueWithoutPromoAnchorInput = {
    where: FlyerPageSlotWhereUniqueInput
    data: XOR<FlyerPageSlotUpdateWithoutPromoAnchorInput, FlyerPageSlotUncheckedUpdateWithoutPromoAnchorInput>
  }

  export type FlyerPageSlotUpdateManyWithWhereWithoutPromoAnchorInput = {
    where: FlyerPageSlotScalarWhereInput
    data: XOR<FlyerPageSlotUpdateManyMutationInput, FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorInput>
  }

  export type FlyerCreateWithoutVerificationLogsInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutVerificationLogsInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutVerificationLogsInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutVerificationLogsInput, FlyerUncheckedCreateWithoutVerificationLogsInput>
  }

  export type FlyerUpsertWithoutVerificationLogsInput = {
    update: XOR<FlyerUpdateWithoutVerificationLogsInput, FlyerUncheckedUpdateWithoutVerificationLogsInput>
    create: XOR<FlyerCreateWithoutVerificationLogsInput, FlyerUncheckedCreateWithoutVerificationLogsInput>
    where?: FlyerWhereInput
  }

  export type FlyerUpdateToOneWithWhereWithoutVerificationLogsInput = {
    where?: FlyerWhereInput
    data: XOR<FlyerUpdateWithoutVerificationLogsInput, FlyerUncheckedUpdateWithoutVerificationLogsInput>
  }

  export type FlyerUpdateWithoutVerificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutVerificationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerCreateWithoutApprovalsInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutApprovalsInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutApprovalsInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutApprovalsInput, FlyerUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutApprovalsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSupplierInput
    flyers?: FlyerCreateNestedManyWithoutSupplierInput
    userFlyers?: UserFlyerCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovalsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    flyers?: FlyerUncheckedCreateNestedManyWithoutSupplierInput
    userFlyers?: UserFlyerUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
  }

  export type FlyerUpsertWithoutApprovalsInput = {
    update: XOR<FlyerUpdateWithoutApprovalsInput, FlyerUncheckedUpdateWithoutApprovalsInput>
    create: XOR<FlyerCreateWithoutApprovalsInput, FlyerUncheckedCreateWithoutApprovalsInput>
    where?: FlyerWhereInput
  }

  export type FlyerUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: FlyerWhereInput
    data: XOR<FlyerUpdateWithoutApprovalsInput, FlyerUncheckedUpdateWithoutApprovalsInput>
  }

  export type FlyerUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type UserUpsertWithoutApprovalsInput = {
    update: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
    create: XOR<UserCreateWithoutApprovalsInput, UserUncheckedCreateWithoutApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalsInput, UserUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUpdateManyWithoutSupplierNestedInput
    userFlyers?: UserFlyerUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUncheckedUpdateManyWithoutSupplierNestedInput
    userFlyers?: UserFlyerUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FlyerCreateWithoutApprovalWorkflowInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutApprovalWorkflowInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutApprovalWorkflowInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutApprovalWorkflowInput, FlyerUncheckedCreateWithoutApprovalWorkflowInput>
  }

  export type FlyerUpsertWithoutApprovalWorkflowInput = {
    update: XOR<FlyerUpdateWithoutApprovalWorkflowInput, FlyerUncheckedUpdateWithoutApprovalWorkflowInput>
    create: XOR<FlyerCreateWithoutApprovalWorkflowInput, FlyerUncheckedCreateWithoutApprovalWorkflowInput>
    where?: FlyerWhereInput
  }

  export type FlyerUpdateToOneWithWhereWithoutApprovalWorkflowInput = {
    where?: FlyerWhereInput
    data: XOR<FlyerUpdateWithoutApprovalWorkflowInput, FlyerUncheckedUpdateWithoutApprovalWorkflowInput>
  }

  export type FlyerUpdateWithoutApprovalWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutApprovalWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerCreateWithoutVersionsInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    editHistory?: FlyerEditHistoryCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutVersionsInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    editHistory?: FlyerEditHistoryUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutVersionsInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutVersionsInput, FlyerUncheckedCreateWithoutVersionsInput>
  }

  export type FlyerUpsertWithoutVersionsInput = {
    update: XOR<FlyerUpdateWithoutVersionsInput, FlyerUncheckedUpdateWithoutVersionsInput>
    create: XOR<FlyerCreateWithoutVersionsInput, FlyerUncheckedCreateWithoutVersionsInput>
    where?: FlyerWhereInput
  }

  export type FlyerUpdateToOneWithWhereWithoutVersionsInput = {
    where?: FlyerWhereInput
    data: XOR<FlyerUpdateWithoutVersionsInput, FlyerUncheckedUpdateWithoutVersionsInput>
  }

  export type FlyerUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerCreateWithoutEditHistoryInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    supplier: UserCreateNestedOneWithoutFlyersInput
    pages?: FlyerPageCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionCreateNestedManyWithoutFlyerInput
  }

  export type FlyerUncheckedCreateWithoutEditHistoryInput = {
    id?: string
    supplierId: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    pages?: FlyerPageUncheckedCreateNestedManyWithoutFlyerInput
    verificationLogs?: VerificationLogUncheckedCreateNestedManyWithoutFlyerInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutFlyerInput
    approvalWorkflow?: ApprovalWorkflowUncheckedCreateNestedOneWithoutFlyerInput
    versions?: FlyerVersionUncheckedCreateNestedManyWithoutFlyerInput
  }

  export type FlyerCreateOrConnectWithoutEditHistoryInput = {
    where: FlyerWhereUniqueInput
    create: XOR<FlyerCreateWithoutEditHistoryInput, FlyerUncheckedCreateWithoutEditHistoryInput>
  }

  export type FlyerUpsertWithoutEditHistoryInput = {
    update: XOR<FlyerUpdateWithoutEditHistoryInput, FlyerUncheckedUpdateWithoutEditHistoryInput>
    create: XOR<FlyerCreateWithoutEditHistoryInput, FlyerUncheckedCreateWithoutEditHistoryInput>
    where?: FlyerWhereInput
  }

  export type FlyerUpdateToOneWithWhereWithoutEditHistoryInput = {
    where?: FlyerWhereInput
    data: XOR<FlyerUpdateWithoutEditHistoryInput, FlyerUncheckedUpdateWithoutEditHistoryInput>
  }

  export type FlyerUpdateWithoutEditHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    supplier?: UserUpdateOneRequiredWithoutFlyersNestedInput
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutEditHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type UserCreateWithoutUserFlyersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSupplierInput
    flyers?: FlyerCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserFlyersInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    flyers?: FlyerUncheckedCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserFlyersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserFlyersInput, UserUncheckedCreateWithoutUserFlyersInput>
  }

  export type UserFlyerPageCreateWithoutUserFlyerInput = {
    id?: string
    pageNumber: number
    products?: UserFlyerPageProductCreateNestedManyWithoutPageInput
  }

  export type UserFlyerPageUncheckedCreateWithoutUserFlyerInput = {
    id?: string
    pageNumber: number
    products?: UserFlyerPageProductUncheckedCreateNestedManyWithoutPageInput
  }

  export type UserFlyerPageCreateOrConnectWithoutUserFlyerInput = {
    where: UserFlyerPageWhereUniqueInput
    create: XOR<UserFlyerPageCreateWithoutUserFlyerInput, UserFlyerPageUncheckedCreateWithoutUserFlyerInput>
  }

  export type UserFlyerPageCreateManyUserFlyerInputEnvelope = {
    data: UserFlyerPageCreateManyUserFlyerInput | UserFlyerPageCreateManyUserFlyerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutUserFlyersInput = {
    update: XOR<UserUpdateWithoutUserFlyersInput, UserUncheckedUpdateWithoutUserFlyersInput>
    create: XOR<UserCreateWithoutUserFlyersInput, UserUncheckedCreateWithoutUserFlyersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserFlyersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserFlyersInput, UserUncheckedUpdateWithoutUserFlyersInput>
  }

  export type UserUpdateWithoutUserFlyersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserFlyersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUncheckedUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserFlyerPageUpsertWithWhereUniqueWithoutUserFlyerInput = {
    where: UserFlyerPageWhereUniqueInput
    update: XOR<UserFlyerPageUpdateWithoutUserFlyerInput, UserFlyerPageUncheckedUpdateWithoutUserFlyerInput>
    create: XOR<UserFlyerPageCreateWithoutUserFlyerInput, UserFlyerPageUncheckedCreateWithoutUserFlyerInput>
  }

  export type UserFlyerPageUpdateWithWhereUniqueWithoutUserFlyerInput = {
    where: UserFlyerPageWhereUniqueInput
    data: XOR<UserFlyerPageUpdateWithoutUserFlyerInput, UserFlyerPageUncheckedUpdateWithoutUserFlyerInput>
  }

  export type UserFlyerPageUpdateManyWithWhereWithoutUserFlyerInput = {
    where: UserFlyerPageScalarWhereInput
    data: XOR<UserFlyerPageUpdateManyMutationInput, UserFlyerPageUncheckedUpdateManyWithoutUserFlyerInput>
  }

  export type UserFlyerPageScalarWhereInput = {
    AND?: UserFlyerPageScalarWhereInput | UserFlyerPageScalarWhereInput[]
    OR?: UserFlyerPageScalarWhereInput[]
    NOT?: UserFlyerPageScalarWhereInput | UserFlyerPageScalarWhereInput[]
    id?: StringFilter<"UserFlyerPage"> | string
    userFlyerId?: StringFilter<"UserFlyerPage"> | string
    pageNumber?: IntFilter<"UserFlyerPage"> | number
  }

  export type UserFlyerCreateWithoutPagesInput = {
    id?: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserFlyersInput
  }

  export type UserFlyerUncheckedCreateWithoutPagesInput = {
    id?: string
    userId: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserFlyerCreateOrConnectWithoutPagesInput = {
    where: UserFlyerWhereUniqueInput
    create: XOR<UserFlyerCreateWithoutPagesInput, UserFlyerUncheckedCreateWithoutPagesInput>
  }

  export type UserFlyerPageProductCreateWithoutPageInput = {
    id?: string
    position: number
    product: ProductCreateNestedOneWithoutUserFlyerPageProductsInput
  }

  export type UserFlyerPageProductUncheckedCreateWithoutPageInput = {
    id?: string
    productId: string
    position: number
  }

  export type UserFlyerPageProductCreateOrConnectWithoutPageInput = {
    where: UserFlyerPageProductWhereUniqueInput
    create: XOR<UserFlyerPageProductCreateWithoutPageInput, UserFlyerPageProductUncheckedCreateWithoutPageInput>
  }

  export type UserFlyerPageProductCreateManyPageInputEnvelope = {
    data: UserFlyerPageProductCreateManyPageInput | UserFlyerPageProductCreateManyPageInput[]
    skipDuplicates?: boolean
  }

  export type UserFlyerUpsertWithoutPagesInput = {
    update: XOR<UserFlyerUpdateWithoutPagesInput, UserFlyerUncheckedUpdateWithoutPagesInput>
    create: XOR<UserFlyerCreateWithoutPagesInput, UserFlyerUncheckedCreateWithoutPagesInput>
    where?: UserFlyerWhereInput
  }

  export type UserFlyerUpdateToOneWithWhereWithoutPagesInput = {
    where?: UserFlyerWhereInput
    data: XOR<UserFlyerUpdateWithoutPagesInput, UserFlyerUncheckedUpdateWithoutPagesInput>
  }

  export type UserFlyerUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserFlyersNestedInput
  }

  export type UserFlyerUncheckedUpdateWithoutPagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFlyerPageProductUpsertWithWhereUniqueWithoutPageInput = {
    where: UserFlyerPageProductWhereUniqueInput
    update: XOR<UserFlyerPageProductUpdateWithoutPageInput, UserFlyerPageProductUncheckedUpdateWithoutPageInput>
    create: XOR<UserFlyerPageProductCreateWithoutPageInput, UserFlyerPageProductUncheckedCreateWithoutPageInput>
  }

  export type UserFlyerPageProductUpdateWithWhereUniqueWithoutPageInput = {
    where: UserFlyerPageProductWhereUniqueInput
    data: XOR<UserFlyerPageProductUpdateWithoutPageInput, UserFlyerPageProductUncheckedUpdateWithoutPageInput>
  }

  export type UserFlyerPageProductUpdateManyWithWhereWithoutPageInput = {
    where: UserFlyerPageProductScalarWhereInput
    data: XOR<UserFlyerPageProductUpdateManyMutationInput, UserFlyerPageProductUncheckedUpdateManyWithoutPageInput>
  }

  export type UserFlyerPageCreateWithoutProductsInput = {
    id?: string
    pageNumber: number
    userFlyer: UserFlyerCreateNestedOneWithoutPagesInput
  }

  export type UserFlyerPageUncheckedCreateWithoutProductsInput = {
    id?: string
    userFlyerId: string
    pageNumber: number
  }

  export type UserFlyerPageCreateOrConnectWithoutProductsInput = {
    where: UserFlyerPageWhereUniqueInput
    create: XOR<UserFlyerPageCreateWithoutProductsInput, UserFlyerPageUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutUserFlyerPageProductsInput = {
    id?: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: UserCreateNestedOneWithoutProductsInput
    brand: BrandCreateNestedOneWithoutProductsInput
    icons?: ProductIconCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserFlyerPageProductsInput = {
    id?: string
    supplierId: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    icons?: ProductIconUncheckedCreateNestedManyWithoutProductInput
    flyerPageSlots?: FlyerPageSlotUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserFlyerPageProductsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserFlyerPageProductsInput, ProductUncheckedCreateWithoutUserFlyerPageProductsInput>
  }

  export type UserFlyerPageUpsertWithoutProductsInput = {
    update: XOR<UserFlyerPageUpdateWithoutProductsInput, UserFlyerPageUncheckedUpdateWithoutProductsInput>
    create: XOR<UserFlyerPageCreateWithoutProductsInput, UserFlyerPageUncheckedCreateWithoutProductsInput>
    where?: UserFlyerPageWhereInput
  }

  export type UserFlyerPageUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserFlyerPageWhereInput
    data: XOR<UserFlyerPageUpdateWithoutProductsInput, UserFlyerPageUncheckedUpdateWithoutProductsInput>
  }

  export type UserFlyerPageUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    userFlyer?: UserFlyerUpdateOneRequiredWithoutPagesNestedInput
  }

  export type UserFlyerPageUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userFlyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpsertWithoutUserFlyerPageProductsInput = {
    update: XOR<ProductUpdateWithoutUserFlyerPageProductsInput, ProductUncheckedUpdateWithoutUserFlyerPageProductsInput>
    create: XOR<ProductCreateWithoutUserFlyerPageProductsInput, ProductUncheckedCreateWithoutUserFlyerPageProductsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutUserFlyerPageProductsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutUserFlyerPageProductsInput, ProductUncheckedUpdateWithoutUserFlyerPageProductsInput>
  }

  export type ProductUpdateWithoutUserFlyerPageProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: UserUpdateOneRequiredWithoutProductsNestedInput
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    icons?: ProductIconUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserFlyerPageProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ProductIconUncheckedUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutProductNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutSupplierInput
    flyers?: FlyerCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    firstName?: string | null
    lastName?: string | null
    role: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    brands?: UserBrandUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutSupplierInput
    flyers?: FlyerUncheckedCreateNestedManyWithoutSupplierInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutApproverInput
    userFlyers?: UserFlyerUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    brands?: UserBrandUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutSupplierNestedInput
    flyers?: FlyerUncheckedUpdateManyWithoutSupplierNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutApproverNestedInput
    userFlyers?: UserFlyerUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserBrandCreateManyUserInput = {
    id?: string
    brandId: string
    createdAt?: Date | string
  }

  export type ProductCreateManySupplierInput = {
    id?: string
    brandId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlyerCreateManySupplierInput = {
    id?: string
    name: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    status: $Enums.FlyerStatus
    isDraft?: boolean
    rejectionReason?: string | null
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    lastEditedAt?: Date | string
    autoSaveVersion?: number
    completionPercentage?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
  }

  export type ApprovalCreateManyApproverInput = {
    id?: string
    flyerId: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserFlyerCreateManyUserInput = {
    id?: string
    name: string
    isDraft?: boolean
    lastEditedAt?: Date | string
    completionPercentage?: number
    pdfData?: Buffer | null
    pdfMimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type UserBrandUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserBrandUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBrandUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    icons?: ProductIconUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ProductIconUncheckedUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pages?: FlyerPageUncheckedUpdateManyWithoutFlyerNestedInput
    verificationLogs?: VerificationLogUncheckedUpdateManyWithoutFlyerNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutFlyerNestedInput
    approvalWorkflow?: ApprovalWorkflowUncheckedUpdateOneWithoutFlyerNestedInput
    versions?: FlyerVersionUncheckedUpdateManyWithoutFlyerNestedInput
    editHistory?: FlyerEditHistoryUncheckedUpdateManyWithoutFlyerNestedInput
  }

  export type FlyerUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFlyerStatusFieldUpdateOperationsInput | $Enums.FlyerStatus
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    autoSaveVersion?: IntFieldUpdateOperationsInput | number
    completionPercentage?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyer?: FlyerUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserFlyerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: UserFlyerPageUpdateManyWithoutUserFlyerNestedInput
  }

  export type UserFlyerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pages?: UserFlyerPageUncheckedUpdateManyWithoutUserFlyerNestedInput
  }

  export type UserFlyerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isDraft?: BoolFieldUpdateOperationsInput | boolean
    lastEditedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completionPercentage?: IntFieldUpdateOperationsInput | number
    pdfData?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    pdfMimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBrandCreateManyBrandInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ProductCreateManyBrandInput = {
    id?: string
    supplierId: string
    eanCode: string
    name: string
    description?: string | null
    imageData: Buffer
    imageMimeType: string
    price: Decimal | DecimalJsLike | number | string
    originalPrice?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PromoImageCreateManyBrandInput = {
    id?: string
    supplierId: string
    name: string
    imageData: Buffer
    imageMimeType: string
    defaultSize?: $Enums.PromoSlotSize
    createdAt?: Date | string
  }

  export type UserBrandUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBrandsNestedInput
  }

  export type UserBrandUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBrandUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: UserUpdateOneRequiredWithoutProductsNestedInput
    icons?: ProductIconUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    icons?: ProductIconUncheckedUpdateManyWithoutProductNestedInput
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutProductNestedInput
    userFlyerPageProducts?: UserFlyerPageProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    eanCode?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    originalPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PromoImageUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyerPageSlots?: FlyerPageSlotUpdateManyWithoutPromoImageNestedInput
    footerPages?: FlyerPageUpdateManyWithoutFooterPromoImageNestedInput
  }

  export type PromoImageUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flyerPageSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoImageNestedInput
    footerPages?: FlyerPageUncheckedUpdateManyWithoutFooterPromoImageNestedInput
  }

  export type PromoImageUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageData?: BytesFieldUpdateOperationsInput | Buffer
    imageMimeType?: StringFieldUpdateOperationsInput | string
    defaultSize?: EnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductIconCreateManyProductInput = {
    id?: string
    iconId: string
    position: number
  }

  export type FlyerPageSlotCreateManyProductInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
  }

  export type UserFlyerPageProductCreateManyProductInput = {
    id?: string
    pageId: string
    position: number
  }

  export type ProductIconUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    icon?: IconUpdateOneRequiredWithoutProductIconsNestedInput
  }

  export type ProductIconUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProductIconUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    iconId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type FlyerPageSlotUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    page?: FlyerPageUpdateOneRequiredWithoutSlotsNestedInput
    promoImage?: PromoImageUpdateOneWithoutFlyerPageSlotsNestedInput
    promoAnchor?: FlyerPageSlotUpdateOneWithoutPromoSpannedSlotsNestedInput
    promoSpannedSlots?: FlyerPageSlotUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserFlyerPageProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    page?: UserFlyerPageUpdateOneRequiredWithoutProductsNestedInput
  }

  export type UserFlyerPageProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProductIconCreateManyIconInput = {
    id?: string
    productId: string
    position: number
  }

  export type ProductIconUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutIconsNestedInput
  }

  export type ProductIconUncheckedUpdateWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProductIconUncheckedUpdateManyWithoutIconInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type FlyerPageSlotCreateManyPromoImageInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
  }

  export type FlyerPageCreateManyFooterPromoImageInput = {
    id?: string
    flyerId: string
    pageNumber: number
  }

  export type FlyerPageSlotUpdateWithoutPromoImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    page?: FlyerPageUpdateOneRequiredWithoutSlotsNestedInput
    product?: ProductUpdateOneWithoutFlyerPageSlotsNestedInput
    promoAnchor?: FlyerPageSlotUpdateOneWithoutPromoSpannedSlotsNestedInput
    promoSpannedSlots?: FlyerPageSlotUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateWithoutPromoImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutPromoImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlyerPageUpdateWithoutFooterPromoImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    flyer?: FlyerUpdateOneRequiredWithoutPagesNestedInput
    slots?: FlyerPageSlotUpdateManyWithoutPageNestedInput
  }

  export type FlyerPageUncheckedUpdateWithoutFooterPromoImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    slots?: FlyerPageSlotUncheckedUpdateManyWithoutPageNestedInput
  }

  export type FlyerPageUncheckedUpdateManyWithoutFooterPromoImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    flyerId?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
  }

  export type FlyerPageCreateManyFlyerInput = {
    id?: string
    pageNumber: number
    footerPromoImageId?: string | null
  }

  export type VerificationLogCreateManyFlyerInput = {
    id?: string
    verificationDate: Date | string
    status: $Enums.VerificationStatus
    details: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ApprovalCreateManyFlyerInput = {
    id?: string
    approverId: string
    status: $Enums.ApprovalStatus
    comment?: string | null
    decidedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type FlyerVersionCreateManyFlyerInput = {
    id?: string
    versionNumber: number
    snapshotData: JsonNullValueInput | InputJsonValue
    createdBy: string
    changeDescription?: string | null
    createdAt?: Date | string
  }

  export type FlyerEditHistoryCreateManyFlyerInput = {
    id?: string
    userId: string
    actionType: $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type FlyerPageUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    slots?: FlyerPageSlotUpdateManyWithoutPageNestedInput
    footerPromoImage?: PromoImageUpdateOneWithoutFooterPagesNestedInput
  }

  export type FlyerPageUncheckedUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    footerPromoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    slots?: FlyerPageSlotUncheckedUpdateManyWithoutPageNestedInput
  }

  export type FlyerPageUncheckedUpdateManyWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    footerPromoImageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationLogUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationLogUncheckedUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationLogUncheckedUpdateManyWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    verificationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    details?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    approverId?: StringFieldUpdateOperationsInput | string
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    decidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionUncheckedUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerVersionUncheckedUpdateManyWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    snapshotData?: JsonNullValueInput | InputJsonValue
    createdBy?: StringFieldUpdateOperationsInput | string
    changeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerEditHistoryUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerEditHistoryUncheckedUpdateWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerEditHistoryUncheckedUpdateManyWithoutFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumFlyerActionTypeFieldUpdateOperationsInput | $Enums.FlyerActionType
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlyerPageSlotCreateManyPageInput = {
    id?: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
    promoAnchorId?: string | null
  }

  export type FlyerPageSlotUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    product?: ProductUpdateOneWithoutFlyerPageSlotsNestedInput
    promoImage?: PromoImageUpdateOneWithoutFlyerPageSlotsNestedInput
    promoAnchor?: FlyerPageSlotUpdateOneWithoutPromoSpannedSlotsNestedInput
    promoSpannedSlots?: FlyerPageSlotUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSpannedSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoAnchorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlyerPageSlotCreateManyPromoAnchorInput = {
    id?: string
    pageId: string
    slotPosition: number
    slotType: $Enums.SlotType
    productId?: string | null
    promoImageId?: string | null
    promoSize?: $Enums.PromoSlotSize | null
    isPromoAnchor?: boolean
  }

  export type FlyerPageSlotUpdateWithoutPromoAnchorInput = {
    id?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    page?: FlyerPageUpdateOneRequiredWithoutSlotsNestedInput
    product?: ProductUpdateOneWithoutFlyerPageSlotsNestedInput
    promoImage?: PromoImageUpdateOneWithoutFlyerPageSlotsNestedInput
    promoSpannedSlots?: FlyerPageSlotUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateWithoutPromoAnchorInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
    promoSpannedSlots?: FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorNestedInput
  }

  export type FlyerPageSlotUncheckedUpdateManyWithoutPromoAnchorInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageId?: StringFieldUpdateOperationsInput | string
    slotPosition?: IntFieldUpdateOperationsInput | number
    slotType?: EnumSlotTypeFieldUpdateOperationsInput | $Enums.SlotType
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    promoImageId?: NullableStringFieldUpdateOperationsInput | string | null
    promoSize?: NullableEnumPromoSlotSizeFieldUpdateOperationsInput | $Enums.PromoSlotSize | null
    isPromoAnchor?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserFlyerPageCreateManyUserFlyerInput = {
    id?: string
    pageNumber: number
  }

  export type UserFlyerPageUpdateWithoutUserFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    products?: UserFlyerPageProductUpdateManyWithoutPageNestedInput
  }

  export type UserFlyerPageUncheckedUpdateWithoutUserFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
    products?: UserFlyerPageProductUncheckedUpdateManyWithoutPageNestedInput
  }

  export type UserFlyerPageUncheckedUpdateManyWithoutUserFlyerInput = {
    id?: StringFieldUpdateOperationsInput | string
    pageNumber?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageProductCreateManyPageInput = {
    id?: string
    productId: string
    position: number
  }

  export type UserFlyerPageProductUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutUserFlyerPageProductsNestedInput
  }

  export type UserFlyerPageProductUncheckedUpdateWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }

  export type UserFlyerPageProductUncheckedUpdateManyWithoutPageInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandCountOutputTypeDefaultArgs instead
     */
    export type BrandCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IconCountOutputTypeDefaultArgs instead
     */
    export type IconCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IconCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoImageCountOutputTypeDefaultArgs instead
     */
    export type PromoImageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoImageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerCountOutputTypeDefaultArgs instead
     */
    export type FlyerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerPageCountOutputTypeDefaultArgs instead
     */
    export type FlyerPageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerPageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerPageSlotCountOutputTypeDefaultArgs instead
     */
    export type FlyerPageSlotCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerPageSlotCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFlyerCountOutputTypeDefaultArgs instead
     */
    export type UserFlyerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFlyerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFlyerPageCountOutputTypeDefaultArgs instead
     */
    export type UserFlyerPageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFlyerPageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBrandDefaultArgs instead
     */
    export type UserBrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandDefaultArgs instead
     */
    export type BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IconDefaultArgs instead
     */
    export type IconArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IconDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductIconDefaultArgs instead
     */
    export type ProductIconArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductIconDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PromoImageDefaultArgs instead
     */
    export type PromoImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PromoImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerDefaultArgs instead
     */
    export type FlyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerPageDefaultArgs instead
     */
    export type FlyerPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerPageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerPageSlotDefaultArgs instead
     */
    export type FlyerPageSlotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerPageSlotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationLogDefaultArgs instead
     */
    export type VerificationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalDefaultArgs instead
     */
    export type ApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ApprovalWorkflowDefaultArgs instead
     */
    export type ApprovalWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ApprovalWorkflowDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerVersionDefaultArgs instead
     */
    export type FlyerVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerVersionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlyerEditHistoryDefaultArgs instead
     */
    export type FlyerEditHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlyerEditHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFlyerDefaultArgs instead
     */
    export type UserFlyerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFlyerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFlyerPageDefaultArgs instead
     */
    export type UserFlyerPageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFlyerPageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserFlyerPageProductDefaultArgs instead
     */
    export type UserFlyerPageProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserFlyerPageProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}